{"meta":{"title":"Boii","subtitle":"Mr.Boii","description":"Talk is cheap, Show me the code!","author":"Mr.Boii","url":"https://www.boii.xyz","root":"/"},"pages":[{"title":"","date":"2021-06-10T04:49:04.505Z","updated":"2021-06-10T04:49:04.505Z","comments":true,"path":"404.html","permalink":"https://www.boii.xyz/404","excerpt":"","text":"404 很抱歉，您访问的页面不存在 可能是输入地址有误或该地址已被删除"},{"title":" ","date":"2020-08-22T16:00:00.000Z","updated":"2021-06-13T03:50:18.591Z","comments":false,"path":"about/index.html","permalink":"https://www.boii.xyz/about/","excerpt":"","text":"Profile Mr.Boii 男 95后 菜鸡小学生 不爱搞事 不爱刷圈 拒绝IE 拥抱开源 喜欢的书《Python 语言从入门到上天》 —— Python是世界上最好的语言《颈椎腰椎康复指南》 —— 别治了，没救的。 喜欢的影视《让子弹飞》 —— 姜文《3 Idiot》 —— 阿米尔·汗 喜欢的话Talk is cheap. Show me the code！ 屁话少说，放码过来！ Standards are paper. I use paper to wipe my butt every day. That how much that paper is worth. 标准就是一堆纸。我每天用这堆纸擦屁股。这就是这些纸的价值所在。 I’m allways right. This time I’m just even more right than usual. 我总是正确的。这次我比平时更正确一些。 finally,My name is Linus Torvalds and I am your god. 我的名字叫Linus Torvalds，我是你们的上帝。 联系i@tcp404.com 经常不在线，有事发了也没用哈哈哈哈哈！ 声明本博客所有内容均为原创，如有雷同，算你抄我。"},{"title":"","date":"2021-05-22T16:24:30.999Z","updated":"2021-05-22T16:24:30.999Z","comments":false,"path":"artitalk/index.html","permalink":"https://www.boii.xyz/artitalk/","excerpt":"","text":""},{"title":"分类","date":"2020-08-22T10:17:14.000Z","updated":"2021-05-22T13:37:47.800Z","comments":true,"path":"categories/index.html","permalink":"https://www.boii.xyz/categories/","excerpt":"","text":""},{"title":"","date":"2021-06-14T07:44:42.035Z","updated":"2021-06-14T07:44:42.035Z","comments":true,"path":"friends/index.html","permalink":"https://www.boii.xyz/friends/","excerpt":"你在，便足矣 F R I E N D S","text":"你在，便足矣 F R I E N D S 如何添加友链 添加方式友链要求第一步：先将本站链接添加至贵站title: Boiiurl: https://www.boii.xyzavatar: https://cdn.jsdelivr.net/gh/TCP404/HEXO-CDN/images/icon/bolgger.pngscreenshot: https://cdn.jsdelivr.net/gh/TCP404/Picgo/blog/cover/site-screenshot.pngdescription: 一切皆零，万物归一第二步：复制下面的内容，按照格式填写并提交评论123456- title: &quot;博客站名&quot;, url: &quot;博客站点链接&quot;, avatar: &quot;站主头像外链&quot;, screenshot: &quot;博客截图外链&quot;, description: &quot;形容自己的博客&quot;, group: &quot;可以选&#x27;技术大佬&#x27;或者&#x27;憨憨铁&#x27;&quot;除了 “group”，其他都是必填项哦 为提高图片加载速度，建议优化头像和截图：打开 压缩图 上传自己的截图，将图片大小压缩到 1Mb以下。[在线压缩图片]将压缩后的图片上传到自己搭建的图床、去不图床 等，并使用此图片链接作为截图第三步：下方评论区留言，等待博主审核评论区记得填写QQ邮箱，博主会收到微信及邮件通知，待审核通过后刷新本页面即可显示 请确保您的博客站点能够正常访问， 拒绝死链 原则上只接收博客类网站友链，资源站、视频站等一切非博客类网站不予交换 网站不应有繁杂的广告、推广信息或者违规违法的内容"},{"title":"标签","date":"2020-04-07T02:20:07.000Z","updated":"2021-05-22T13:37:47.800Z","comments":true,"path":"tags/index.html","permalink":"https://www.boii.xyz/tags/","excerpt":"","text":""}],"posts":[{"title":"DataStruction 0x08 图-2","slug":"DataStruction [8-图2]","date":"2021-02-23T08:00:43.000Z","updated":"2021-05-23T04:26:14.439Z","comments":true,"path":"2021/02/23/DataStruction [8-图2]/","link":"","permalink":"https://www.boii.xyz/2021/02/23/DataStruction%20[8-%E5%9B%BE2]/","excerpt":"图的存储","text":"图的存储 8-图2图的ADT12345678910111213141516171819202122ADT 图 GraphData 顶点的有穷非空集合和边的集合Operation CreateGraph(*G, V, E): 按照顶点集V和边集E的定义构造图G DestoryGraph(G*): 图G存在则销毁 LocateVex(G*, v): 若图G中存在顶点v，则返回v在图中的顶点数组的下标 GetVex(G*, v): 返回图中顶点v的值 PutVex(G*, v, value): 将图G中顶点v赋值value FirstNeighbor(G*, v): 返回顶点v的第一个邻接点，若无则返回空 NextNeighbor(G*, v1, v2): 返回顶点v1相对于顶点v2的下一个邻接点，若v2是v1的最后一个邻接点则返回空 InsertVex(G*, v): 在图G中增加顶点v DeleteVex(G*, v): 删除图G中顶点v及其相关的边/弧 InsertArc(G*, v1, v2): 在图G中增加弧&lt;v1, v2&gt;，若G是无向图，还需添加对称弧&lt;v2, v1&gt; DeleteArc(G*, v1, v2): 在图G中删除弧&lt;v1, v2&gt;，若G是无向图，还需删除对称弧&lt;v2, v1&gt; DFSTraverse(G*): 对图G中进行深度优先遍历 BFSTraverse(G*): 对图G中进行广度优先遍历 Adjacent(G*, v1, v2): 判断图G中是否存在边/弧&lt;v1, v2&gt; Neighbors(G*, v): 列处图G中与顶点v邻接的边 GetEdgeValue(G*, v1, v2): 获取图G中边/弧&lt;v1, v2&gt;对应的权值 SetEdgeValue(G*, v1, v2, value): 设置图G中边/弧&lt;v1, v2&gt;对应的权值为valueendADT 图的存储结构图的顶点之间没有次序关系，且顶点的邻接情况多变，无法用统一的格式来存储。 邻接矩阵 Adjacent Matrix图的邻接矩阵的存储方式是用两个数组来表示图。一个一维数组用来存储图中的顶点集，一个二维数组（称为邻接矩阵）用来存储图中的边集。图的邻接矩阵表示法 = 一维数组 $\\times$ 1 + 二维数组 $\\times$ 1 设 图G 有 n 个顶点，则邻接矩阵是一个 $n \\times n$ 的方阵，定义为： $$Arc[i][j] =\\begin{cases}1, &amp; {(v_i, v_j) \\in E 或 \\langle v_i, v_j \\rangle \\in E} \\[3ex]0, &amp; {反之}\\end{cases}$$ 无向图理论描述顶点集很容易表示，使用顶点结构类型的一维数组来存储顶点信息。边集可以用 矩阵(Metrix) 来表示，而矩阵在计算机中可以使用二维数组来实现。 eg: 这个图的边集可以变成下面的矩阵： $$\\begin{bmatrix}0 &amp; 1 &amp; 1 &amp; 0 \\1 &amp; 0 &amp; 1 &amp; 0 \\1 &amp; 1 &amp; 0 &amp; 1 \\0 &amp; 0 &amp; 1 &amp; 0\\end{bmatrix}$$ 所以对于图 **G = (V, {E})**，可以使用一个一维数组来存储顶点集 V，再用一个二维数组来存储边集 E。于是一张图可以变成下图所示： 上图中，有一个结构体 struct Graph，结构体中包含一个一维数组 Vertex[] 和一个二维数组 Edge[][]，一个 v_count 存储顶点数，一个 e_count 存储边数。 Vertex[] 用来存储顶点信息，Edge[][] 用来存储边的信息。 例如 (v1, v2) 就将 Edge[0][1] 置为1；而 (v1, v2) 也可以表示为 (v2, v1) ，所以 Edge[1][0] 也应置为1。而简单图不会有自己邻接自己的边，所以 Edge[0][0]、Edge[1][1]、Edge[2][2]、Edge[3][3] 均为0。 稍微观察可以发现，无向图的邻接矩阵一定是一个对称矩阵[^1]，于是我们可以很容易知道图中的信息： 某个顶点的度，起始就是这个顶点 vi 在邻接矩阵中第 i 行（或第 i 列）的元素之和。eg：顶点 v3 的度就是 1+1+0+1 = 3 求顶点 vi 的所有邻接点就是在邻接矩阵中第 i 行所有元素为 1 的点。eg：顶点 v2 的所有邻接点就遍历 Edge[1][…]，其中为 Eege[1][0]、Edge[1][2] 为1，表示 v1 和 v3 为邻接点。 代码实现1234567891011121314151617181920212223242526// GraphModel.h#ifndef GRAPH_MODEL_H_INCLUDED#define GRAPH_MODEL_H_INCLUDED#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;#define MAX 4typedef enum &#123; ERROR, OK,&#125; Status;typedef enum &#123; DG, // 有向图 UDG, // 无向图 DN, // 有向网 UDN, // 无向网&#125; GraphKind;typedef char* Vertex; // 顶点数组类型typedef int Edge; // 邻接矩阵类型#endif // GRAPH_MODEL_H_INCLUDED 123456789101112131415161718192021222324252627282930// MatrixGraph.h#ifndef MATRIX_GRAPH_H_INCLUDED#define MATRIX_GRAPH_H_INCLUDED#include &quot;GraphModel.h&quot;typedef struct &#123; Vertex vers[MAX]; // 顶点数组 Edge edges[MAX][MAX]; // 邻接矩阵（边数组） size_t v_count; // 顶点总数 size_t e_count; // 边总数 GraphKind kind; // 图类型&#125; MatrixGraph;/** * @description: 创建无向图 * @param G 要操作初始化的图 * @return 成功返回OK，失败返回ERROR */Status CreatUDG(MatrixGraph* G);/** * @description: 返回某个顶点在顶点集合中的下标 * @param G 要查找的图结构 * @param v 顶点 * @return 返回下标，不存在返回-1 */int LocateVex(MatrixGraph* G, Vertex v);#endif // MATRIX_GRAPH_H_INCLUDED 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091// MatrixGraph.c#include &quot;MatrixGraph.h&quot;Status CreatUDG(MatrixGraph* G)&#123; G-&gt;kind = UDG; printf(&quot;Please type the count of Vertex : &quot;); scanf(&quot;%d&quot;, &amp;G-&gt;v_count); printf(&quot;Please type the count of Edge : &quot;); scanf(&quot;%d&quot;, &amp;G-&gt;e_count); // 录入顶点数组 printf(&quot;Please type Vertex in turn.\\n&quot;); for (int i = 0; i &lt; G-&gt;v_count; i++) &#123; G-&gt;vers[i] = calloc(10, sizeof(Vertex)); printf(&quot;Vertex %d :&quot;, i); scanf(&quot;%s&quot;, G-&gt;vers[i]); &#125; // 初始化邻接矩阵，所有边的权值设置为0 for (int i = 0; i &lt; G-&gt;v_count; i++) &#123; for (int j = 0; j &lt; G-&gt;v_count; j++) &#123; G-&gt;edges[i][j] = 0; &#125; &#125; // 录入邻接矩阵 printf(&quot;Please type Vertex and Adjacent. \\n&quot;); for (int i = 0; i &lt; G-&gt;e_count; i++) &#123; Vertex v1 = calloc(10, sizeof(Vertex)); Vertex v2 = calloc(10, sizeof(Vertex)); printf(&quot;Vertex %d : &quot;, i + 1); scanf(&quot;%s&quot;, v1); printf(&quot;Adjacent %d : &quot;, i + 1); scanf(&quot;%s&quot;, v2); /** 核心代码 begin */ // 获取顶点的下标 int x = LocateVex(G, v1); int y = LocateVex(G, v2); if (x == -1 || y == -1) return ERROR; // 对应位置置为1 G-&gt;edges[x][y] = 1; G-&gt;edges[y][x] = 1; /** 核心代码 end */ free(v1); free(v2); &#125; return OK;&#125;int LocateVex(MatrixGraph* G, Vertex v)&#123; int index = 0; while (index &lt; G-&gt;v_count) &#123; if (strcmp(v, G-&gt;vers[index]) == 0) &#123; break; &#125; index++; &#125; return index == G-&gt;v_count ? -1 : index;&#125;void Test()&#123; MatrixGraph G; Status status = CreatUDG(&amp;G); if (status = ERROR) &#123; printf(&quot;Create Graph Failed~&quot;); return; &#125; printf(&quot;The Adjacent Matrix: \\n&quot;); printf(&quot;\\t&quot;); for (int i = 0; i &lt; G.v_count; i++) &#123; printf(&quot;\\t%s&quot;, G.vers[i]); &#125; printf(&quot;\\n&quot;); for (int i = 0; i &lt; G.e_count; i++) &#123; printf(&quot;\\t%s&quot;, G.vers[i]); for (int j = 0; j &lt; G.e_count; j++) &#123; printf(&quot;\\t%d&quot;, G.edges[i][j]); &#125; printf(&quot;\\n&quot;); &#125;&#125; 1234567#include &quot;MatrixGraph.c&quot;int main(int argc, char const* argv[])&#123; Test(); return 0;&#125; 有向图理论描述有向图和无向图的区别在于邻接矩阵。 在有向图邻接矩阵中，第 i 行含义：以结点 vi 为尾的弧（即出度边）第 i 列含义：以结点 vi 为头的弧（即入度边） 其特点为： 无向图的邻接矩阵一定是对称的，当有向图的邻接矩阵不一定是对称的。 顶点 vi 的出度 = 第 i 行元素之和 顶点 vi 的入度 = 第 i 列元素之和 顶点 vi 的度 = 第 i 行元素之和 + 第 i 列元素之和 口诀：Arc[行][列]Arc[出][入]列头入，行尾出：即 列为弧头、入度；行为弧尾、出度。 代码实现在代码实现上，有向图与无向图唯一的区别在于：录入弧的数据之后，只需要执行赋值一次就可以。 12G-&gt;edges[x][y] = 1;// G-&gt;edges[y][x] = 1; 这里我将有向图和无向图的创建合并在一起，在调用函数时多传入一个 GraphKind 类型参数来区分。 123456789101112131415161718192021222324252627282930313233343536Status CreatGraph(MatrixGraph* G, GraphKind kind)&#123; G-&gt;kind = kind; // 录入顶点数和边数 ... // 录入顶点数组 ... // 初始化邻接矩阵，所有边的权值设置为0 ... // 录入邻接矩阵 printf(&quot;Please type %s and %s. \\n&quot;, kind == UDG ? &quot;Vertex&quot; : &quot;InDegree&quot;, kind == UDG ? &quot;Adjacent&quot; : &quot;OutDegree&quot;); for (int i = 0; i &lt; G-&gt;e_count; i++) &#123; Vertex v1 = calloc(10, sizeof(Vertex)); Vertex v2 = calloc(10, sizeof(Vertex)); printf(&quot;%s %d : &quot;, kind == UDG ? &quot;Vertex&quot; : &quot;OutDegree&quot;, i + 1); scanf(&quot;%s&quot;, v1); printf(&quot;%s %d : &quot;, kind == UDG ? &quot;Adjacent&quot; : &quot;InDegree&quot;, i + 1); scanf(&quot;%s&quot;, v2); int x = LocateVex(G, v1); int y = LocateVex(G, v2); if (x == -1 || y == -1) return ERROR; G-&gt;edges[x][y] = 1; G-&gt;edges[y][x] = kind == UDG ? 1 : 0; // 无向图置为1，有向图保持默认 free(v1); free(v2); &#125; return OK;&#125;// Status status = CreatGraph(&amp;G);Status status = CreatGraph(&amp;G, DG); 同时，有向图的顶点的度 = 出度 + 入度，可以实现一个函数根据图的类型来返回顶点的度。 12345678910111213141516171819/** * @description: 获取某个顶点的度 * @param G 要查找的图 * @param v 要查询度的顶点 * @return 该顶点的度 */size_t GetDegree(MatrixGraph* G, Vertex v)&#123; // 获取无向图的度：累加第i行或第i列的元素之和 // 获取有向图的度：累加第i行和第i列的元素之和并相加 int index = LocateVex(G, v); int inDegree = 0; int outDegree = 0; for (int i = 0; i &lt; G-&gt;e_count; i++) &#123; inDegree += G-&gt;edges[i][index]; outDegree += G-&gt;edges[index][i]; &#125; return G-&gt;kind == UDG ? inDegree : inDegree + outDegree;&#125; 无向图的度只需要返回行的和或列的和就行，有向图的度则需要相加再返回。 网边或弧带权的图即为网。 理论描述设 图G 有 n 个顶点，则邻接矩阵是一个 $n \\times n$ 的方阵，定义为： $$Arc[i][j] =\\begin{cases}W_{ij}, &amp; {(v_i, v_j) \\in E 或 \\langle v_i, v_j \\rangle \\in E} \\[1ex]0, &amp; {i=j} \\[1ex]∞, &amp; {反之}\\end{cases}$$ 这里 $W_{ij}$ 表示 $\\langle v_i, v_j \\rangle$ 或 $(v_i, v_j)$ 上的权值。∞表示一个计算机允许的、大于所有边上权值的值，即一个不可能的极限值，在C语言中可以使用 INT_MAX 来表示无穷。 代码实现网的大部分代码与有向图和无向图的相同的，只有几处需要修改。 123456// 初始化邻接矩阵，所有边的权值设置为0for (int i = 0; i &lt; G-&gt;v_count; i++) &#123; for (int j = 0; j &lt; G-&gt;v_count; j++) &#123; G-&gt;edges[i][j] = INT_MAX; &#125;&#125; 在初始化时，不能初始化为0，而要初始化为 INT_MAX。 12345678910111213141516171819202122232425// 录入邻接矩阵 printf(&quot;Please type %s and %s. \\n&quot;, kind == UDN ? &quot;Vertex&quot; : &quot;InDegree&quot;, kind == UDN ? &quot;Adjacent&quot; : &quot;OutDegree&quot;); for (int i = 0; i &lt; G-&gt;e_count; i++) &#123; Vertex v1 = calloc(10, sizeof(Vertex)); Vertex v2 = calloc(10, sizeof(Vertex)); int weight = 0; // 权值 printf(&quot;%s %d : &quot;, kind == UDN ? &quot;Vertex&quot; : &quot;OutDegree&quot;, i + 1); scanf(&quot;%s&quot;, v1); printf(&quot;%s %d : &quot;, kind == UDN ? &quot;Adjacent&quot; : &quot;InDegree&quot;, i + 1); scanf(&quot;%s&quot;, v2); printf(&quot;Value %d: &quot;, i + 1); scanf(&quot;%s&quot;, &amp;weight); int x = LocateVex(G, v1); int y = LocateVex(G, v2); if (x == -1 || y == -1) return ERROR; G-&gt;edges[x][y] = weight; G-&gt;edges[y][x] = kind == UDN ? weight : INT_MAX; free(v1); free(v2); &#125; 录入邻接矩阵时也需要多录入一个权值。 12345678// 邻接矩阵for (int i = 0; i &lt; G.e_count; i++) &#123; printf(&quot;\\t%s&quot;, G.vers[i]); for (int j = 0; j &lt; G.e_count; j++) &#123; printf(&quot;\\t%s&quot;, G.edges[i][j] == INT_MAX ? &quot;∞&quot; : (char*)G.edges[i][j]); &#125; printf(&quot;\\n&quot;);&#125; 打印时也稍作处理。 邻接表 Adjacent List邻接矩阵适合处理稠密图，对于稀疏图，邻接矩阵会造成巨大的浪费。在数据结构中，解决浪费问题需要往链式结构的方向去想。 图的邻接表的存储方式是用一维数组和单链表来表示图。一个一维数组用来存储图中的顶点集，多个单链表用来存储图中的边集。图的邻接矩阵表示法 = 一维数组 $\\times$ 1 + 单链表 $\\times$ n 无向图的邻接表邻接表的处理方法如下： 图的顶点集用一维数组存储，数组元素为 数据域 + 首邻接点域； 图的边/弧集用单链表存储，链表结点由 邻接点域 + 指针域 构成； 首邻接点域 指的是顶点的第一个边链表结点的地址，链表中的 邻接点域 存储的是邻接点的在顶点数组中的下标。 从上图可以看出，一个无向图可以用一个顶点类型的一维数组来存储顶点，每个顶点都各自有一条边链表，存储着该顶点的所有邻接点； 顶点数组中的某个顶点 Vertex[i] 和 对应边链表中的任一个结点构成了一条边。 eg： $v_1$ 的邻接点是 $v_2$ 和 $v_3$，在顶点数组中 $v_1$ 的下标是 0； 在 Vertex[0] 数据域中存着 $v_1$，首邻接点域存储着边链的第一个结点的地址； 在边链的第一个结点中，邻接点域存储着 $v_2$ 的下标 1，然后指针域指向下一个结点； 下一个结点的邻接点域存储着 $v_3$ 的下标 2，后面不再有了，所以指针域为空。 仔细观察可以发现以下特点： 无向图的邻接表重复存储着数据（邻接矩阵里也是），但总比邻接矩阵节省空间。 边链中的结点，除了与顶点数组中的元素，相互之间没有关系。 顶点的度 = 它的边链的结点数 求顶点的所有邻接点 = 遍历顶点的边链并取邻接点域 如果有 n 条边，则边链表会有 2n 个结点 有向图的邻接表有向图的邻接表是类似的，但有向图区分方向。 我们以顶点为弧尾来存储边链表，并称这样的边链表为出边表，或正邻接表我们以顶点为弧头来存储边链表，并称这样的边链表为入边表，或逆邻接表 右上为出边表，右下为入边表 出边表中，顶点 v1 作为弧尾，邻接弧头 v2，所以首邻接点与指向出边表的第一个结点，结点中的数据域存储着弧头 v2 的下标 1。所以 v1 和 Vertex[1] 共同组成一条弧。 而顶点 v2 有 2 个出度，所以 v2 的出边表中有 2 个结点。 入边表中，顶点 v3 作为弧头，邻接弧尾 v2 和 v4，所以首邻接点指向入边表的第一个结点，结点中存着 v2 的下标 1，第二个结点存着 v4 下标 3。 观察两个表，可以发现以下特点： 使用入边表表示图时，顶点的入度 = 对应入边表的结点数量，要计算出度只能遍历所有边链表 使用出边表表示图时，顶点的出度 = 对应出边表的结点数量，要计算入度只能遍历所有边链表 边链表中的结点，除了与顶点元素，相互之间没有关系 弧的总数 = 所有边链表的结点的总数之和 有向网的邻接表有向网和无向网的邻接表仅仅只是在边链表中的结点增加一个变量 weight 来存储权值。同样有有向无向、出边入边之分。 代码实现12345678910111213141516171819202122// 边链表结点类型typedef struct node&#123; int adjvex; // 邻接点域、邻接点下标 struct node* next; // 指针域&#125; EdgeNode, ArcNode;// 顶点类型typedef char* Vertex;// 顶点结点类型typedef struct &#123; Vertex data; // 数据域 EdgeNode firstEdge; // 首邻接点域&#125; VertexNode;// 图类型typedef struct &#123; VertexNode vexs[MAX]; // 顶点结点数组 int v_count; // 顶点数量 int e_count; // 边/弧数量 GraphKind kind; // 图类型&#125; AdjListGraph; 十字链表 Orthogonal List十字链表主要针对有向图，适用于需要频繁获取顶点的入度和出度，频繁地判断一个点是不是另一个点的邻接点等的情况。其核心思想是将出边表和入边表整合起来。 有向图的邻接表只有表示出度的出边表，或者表示入度的入边表，鱼和熊掌不可兼得。 对于这种情况，小孩子才做选择，大人全都要！ 于是我们可以改造一下顶点数组，让一个顶点数组的元素包含 顶点、出边表的首邻接点域、入边表的首邻接点域 data 表示顶点，iFirst 表示入边表的首邻接点域，oFirst 表示出边表的首邻接点域。 于是我们可以得到一个这样的双邻接表： 最左边是图结构，中间上面是出边表，中间下面是入边表，将它们结合，就成了最右边的双邻接表 下一步我们改造一下边链表的结点，让它由 弧尾下标 + 弧尾边链的指针域 + 弧头下标 + 弧头边链的指针域 构成。 oVex 表示弧中出边的结点，即弧尾结点，的下标；oNext 替代了原出边表结点里的指针域；iVex 表示弧中入边的结点，即弧头结点，的下标；iNext 替代了原入边表结点里的指针域； 现在对双邻接表进行改造： 然后我们会发现有很多重复的结点，我们保留一个，删除一个： 接着把被删除的地方的链指向保留下来的那个结点： 例如 v1 的出边表第一个结点（v1 红色线条指向的那个 0 和 1 的结点） 和 v2 的入边表的第一个节点（v2 蓝色线条指向的那个 0 和 1 的结点）， 这两个结点相同， 于是我删掉其中 v2 的那个，然后让 v2 的蓝色线指向 v1 的第一个结点，其他结点也是同样操作。 最后整理一下就是下图的样子： 对比一下该图的顶点 v2 的出边表和十字链表： 可以看到没有损失任何信息。 代码实现1234567891011121314151617181920212223242526/** 顶点类型 */typedef char* Vertex;/** 十字链表结点 */typedef struct node&#123; Vertex oVex; // 弧头下标 Vertex iVex; // 弧尾下标 struct node* oNext; // 出边表指针域 struct node* iNext; // 入边表指针域 int weight; // 权值&#125; OrthoNode;/** 顶点数组元素类型 */typedef struct &#123; Vertex data; // 顶点 OrthoNode iFirst; // 入边表的首个结点 OrthoNode oFirst; // 出边表的首个节点&#125; VertexNode;/** 图结构 */typedef struct &#123; VertexNode vexArray[MAX]; // 顶点数组 int v_count; // 顶点数量 int a_count; // 弧的数量 GraphKind kind; // 图的类型（有向图/有向网）&#125; OrthoGraph; 总结十字链表5步走：生成有向图的出边表和入边表组合成双邻接表改造链表结点删除重复结点连接 邻接多重表 Adjacent Multilist List邻接多重表主要是针对无向图。 从图中可以发现边链结点很多都是重复的。当删除一条边时，需要到两条边链中删除。例如删除 边(v1, v3)，需要找到 v1 的边链，删除第二个结点，然后还要找到 v3 的边链，然后删除第一个结点。显然这是比较繁琐的。 所以邻接多重表就在邻接表的基础上对边链的结点进行改造。 邻接表的结点由 邻接点的下标 + 下一结点指针 构成邻接多重表的结点由 顶点下标 + 顶点的下一结点的指针 + 邻接点下标 + 邻接点的下一结点的指针 构成 其思想是将所有顶点的边链整合起来，即节省空间，也提高了操作效率。 下面介绍一下如何将邻接表改为邻接多重表： 首先将 边链的结点进行改造：边链结点中不仅要填入邻接点的下标，还要填入顶点自己的下标。 例如 顶点 v1 有两个邻接点 v2 和 v3，所以要在两个结点中的 ivex 处填入 v1 的下标 0。其他结点同理。看不懂可以对比两个图的边链。 例如 v1 的第一个边链结点中有 0 和 1，代表 v1 的地址和 v2 的地址；v2 的第一个边链结点也有 1 和 0，所以随便保留哪一个都可以。 图中将 v2 的第一个边链结点删除，然后让 v1 的第一个边链结点也成为 v2 的边链结点。 这一步怎么删，删完指向谁可能有点乱，请看下面的图。 这里左侧两个图结构是同一个，第二个图结构多做了4条辅助线用来对照，实际真正的图是第一个的图结构，不要混淆。对照第二个的图结构，和右侧的邻接多重表： 顶点 v1 有两条边，邻接 v2 和 v3，在邻接多重表中用红色线连接起来了。单独观察 VertexNode[0] 和 红色线连接的两个结点，是不是跟邻接表相似？ 同样道理可以继续观察 v2、v3、v4。 我们会发现邻接多重表的结点数少了，而且结点总数刚好就是边数。 现在再来体会那句：将所有边链整合起来，再体会体会为什么要增加 inext 和 jnext 两个元素在结点中，其实就是为了保留原本的信息。 邻接多重表中边链的结点不分是谁的，只记录边两头两个顶点的下标。 扩展一下，如果无向网使用邻接多重表表示，是不是只要将边链结点多加一个 权值 的成员即可？如果还要再来个是否被搜索过的标记，是不是再加个 布尔值 的成员即可？ 边集数组 Edgeset Array边集数组是由两个一维数组构成，一个是存储顶点的信息，另一个是存储边的信息。这个边数组的每个元素由一条边的起点下标 (begin) 、终点下标 (end) 和权 (weight) 组成。边集数组关注的是边的集合。在边集数组中要查找一个顶点的度需要扫描整个边数组，效率不高，因此更适合对边依次进行处理的操作，而不适合对顶点相关的操作。 图的遍历深度优先搜索 DFS深度优先遍历 (Depth-First-Search) 是仿树的前序遍历，该算法是利用栈来实现，也就是递归，所以在 DFS 中会有递归和回溯的说法。 DFS 需要借助一个数组来记录访问状态，这里将其称作**状态数组 (Status Array) **；该数组长度为顶点总数，次序与顶点数组相同。 从某一个顶点 vi 出发，则当前顶点为 vi； 先将该顶点标记为已访问，然后遍历其所有邻接点，找到 第一个未访问的邻接点 vj 并置为当前顶点； 接着从该顶点 vj 出发，先标记为已访问，然后遍历找到 第一个未访问的邻接点 vk 并置为当前顶点… 以此类推 例如上图左边是一个图，我们可以转换一下思维，像右图一样把那两条边当作没有，就可以看成一棵二叉树 运用树的前序遍历法可以得到：v0 -&gt; v1 -&gt; v5 -&gt; v2 -&gt; v4 -&gt; v3，而这正好就是 DFS 的结果。 回过头来重新看着左边的图，假设从 v0 出发（其实图是无序的，从任何一点出发都可以）； v0 有两个邻接点 v1 和 v3，我们先选择 v1，然后从 v1 出发； v1 有两个邻接点 v5 和 v0，v0 已经访问过了，只能选择 v5，然后从 v5 出发； v5 有三个邻接点 v1、v2、v3，v1 已经访问过了，我们先选择 v2 ，然后从 v2 出发； v2 有两个邻接点 v5 和 v4，v5 已经访问过了，只能选择 v4，然后从 v4 出发； v4 有两个邻接点 v2 和 v3，v2 已经访问过了，只能选择 v3，然后从 v3 出发； v3 有三个邻接点 v4、v5、v0，全都访问过了，到此遍历也就结束了。 如果仔细阅读上面6个步骤会发现，当我们遍历时，我们需要知道这个顶点是不是被访问过了，所以我们需要一个状态数组来记录； 而当有多个邻接点可以访问时，我们选择的依据，其实是顶点在顶点数组中存储的顺序所决定的。 例如在 v5 的时候，选择了 v2 而不是 v3，其实是我们默认顶点数组是按照 v0、v1、v2、v3、v4、v5 的顺序存储，假设是按照 v0、v1、v3、v2、v4、v5 存储，v3 在 v2 前，则会先访问 v3。 邻接矩阵的 DFS 先将图的边用矩阵表示，在计算机中使用二维数组存储。然后设置一个状态数组，长度和顶点数组相同。 接下来就可以执行 DFS 了。 第一步：先初始化状态数组为未访问状态，即最开始所有顶点都未访问。第二步：遍历顶点数组，让数组里每个顶点都放入遍历执行函数中，不过在调用遍历执行函数之前要先判断顶点是否已被访问。 12345678910111213141516171819int visited[MAX];/** DFS begin *//** * @description: 深度优先遍历算法 * @param G 需要被遍历的图 * @return 无 */void DFSTraverse_AMG(MatrixGraph* G)&#123; // 初始化状态数组 for (int i = 0; i &lt; G-&gt;v_count; i++) visited[i] = UNVISITED; // DFS 遍历 for (int i = 0; i &lt; G-&gt;v_count; i++) if (!visited[i]) // 如果某个顶点未访问 DFS_AMG(G, i); // 调用遍历执行函数&#125; 遍历执行函数就是 DFS 的核心算法了。该函数接收顶点的下标，并做3件事： 访问当前顶点 更改顶点的访问状态 获取第一个未访问的邻接点下标，然后递归进去，找不到则回溯 12345678910111213141516/** * @description: 深度优先搜索的核心算法 * @param G 要搜索的图 * @param index 要搜索的顶点的下标 * @return 无 */void DFS_AMG(MatrixGraph* G, int index)&#123; printf(&quot;-&gt; %s &quot;, G-&gt;vexes[index]); // 访问当前顶点 visited[index] = VISITED; // 更改当前顶点的访问状态 for (int j = 0; j &lt; G-&gt;v_count; j++) if (G-&gt;matrix[index][j] &amp;&amp; !visited[j]) // 获取第一个未访问的邻接点下标然后递归进去 DFS_AMG(G, j);&#125;/** DFS end */ 在邻接矩阵中，获取某个顶点的所有邻接点就是遍历其所在的行，找到第一个未访问的邻接点。 从邻接矩阵中看如上图 最开始从第 0 行进行（箭头1），找到第一个邻接点的下标，其列标为 1，于是跳到第 1 行（箭头2） 第 1 行第一个邻接点是 v0 ，已经访问过，所以跳过（箭头3），一直找到 v5 这个邻接点，其列标为 5，于是跳到第 5 行（箭头4） 第 5 行第一个邻接点的 v1，已经访问过，所以跳过（箭头5），接下去找到第二个邻接点 v2，其列标为 2，于是跳到第 2 行（箭头6） 接下去的步骤都是这个思路，画出来太乱就没画了。 邻接表的 DFS邻接表的具体代码实现跟邻接矩阵稍稍不同而已，只不过把数组处理换成了链表处理 最开始从 v1 开始（箭头1），访问 v1 的边链上第一个结点（箭头2），得到了 v2 的下标，于是跳到 v2（箭头3） 接着从 v2 开始，先访问 v2，然后遍历 v2 的边链上的结点（箭头4），第一个结点 0 是 v1 的下标，已经访问过了，于是继续下一个结点，得到了 v3 的下标，于是跳到 v3（箭头5） 接着从 v3 开始，先访问 v3，然后遍历 v3 的边链上的结点（箭头6），第一和第二个结点是 v1 和 v2 的下标，已经访问过，所以接着下一个结点，得到 v4 的下标，于是跳到 v4（箭头7） 接着从 v4 开始，先访问 v4，然后遍历 v4 的边链上的结点，发现得到的是 v3 的下标，已经访问过了，再下去没有了，于是结束。 123456789101112131415161718192021222324void DFSTraverse_ALG(AdjListGraph* G)&#123; // 初始化状态数组 for (int i = 0; i &lt; G-&gt;v_count; i++) visited[i] = UNVISITED; // DFS遍历 for (int i = 0; i &lt; G-&gt;v_count; i++) if (!visited[i]) // 如果顶点没有被访问，就递归调用 DFS_ALG(G, i);&#125;void DFS_ALG(AdjListGraph* G, int index)&#123; printf(&quot; -&gt; %s&quot;, G-&gt;vexes[index].data); // 访问顶点 visited[index] = VISITED; // 更改状态 // 寻找邻接点 EdgeNode* eNode = G-&gt;vexes[index].firstEdge; while (eNode) &#123; if (!visited[eNode-&gt;adjvex]) // 如果邻接点未访问就递归访问 DFS_ALG(G, eNode-&gt;adjvex); eNode = eNode-&gt;nextEdge; &#125;&#125; DFSTraverse_ALG() 和 DFSTraverse_AMG() 是一样的，初始化状态数组，然后遍历顶点数组，调用 DFS 算法 DFS_AMG() 中是遍历某一行，DFS_ALG() 中是遍历某一条链表，执行的逻辑都是如果邻接点为访问就递归。 广度优先 BFS广度优先遍历 (Breadth-First-Search) 是仿树的层次遍历。该算法是利用队列实现的。 BFS 的思想是，把顶点都放到队列中，当访问一个顶点，即为出队一个元素；当出队一个元素时，需将其所有未访问的邻接点入队。 先从 v0 开始遍历，打印 v0，然后 v0 入队 队列不为空，v0 出队，同时 v0 的未入队且未访问的邻接点 v1、v3 入队，然后访问 v1、v3 队列不为空，v1 出队，同时 v1 的未入队且未访问的邻接点 v5、v6 入队，然后访问 v5、v6 队列不为空，v3 出队，同时 v3 的未入队且未访问的邻接点 v4 入队，然后访问 v4 队列不为空，v5 出队，同时 v5 的未入队且未访问的邻接点 v2 入队，然后访问 v2 队列不为空，v6 出队，同时 v6 已经没有未入队且为访问的邻接点了，不做入队操作 队列不为空，v4 出队 队列不为空，v2 出队队列为空，结束到此 BFS 执行完毕 所以该图的 BFS 顺序为 v0 -&gt; v1 -&gt; v3 -&gt; v5 -&gt; v6 -&gt; v4 -&gt; v2。 队列BFS 需要借助队列实现，下面是队列的代码： 1234567891011121314151617181920212223242526// LinkQueue.h#ifndef LINK_QUEUE_H_INCLUDED#define LINK_QUEUE_H_INCLUDED#include &quot;GraphModel.h&quot;typedef Vertex Element;// 结点typedef struct QueueNode &#123; Element data; struct QueueNode* next;&#125; QueueNode;// 队列typedef struct &#123; QueueNode* front; QueueNode* rear;&#125; LinkedQueue;Status InitLinkedQueue(LinkedQueue* q);Status EnQueue(LinkedQueue* q, Element e);Status DeQueue(LinkedQueue* q, Element* e);bool isEmptyQueue(LinkedQueue* q);void PrintLinkedQueue(LinkedQueue* q);#endif // LINK_QUEUE_H_INCLUDED 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566// LinkQueue.c#include &quot;LinkQueue.h&quot;Status InitLinkedQueue(LinkedQueue* q)&#123; q-&gt;front = NULL; q-&gt;rear = NULL; return OK;&#125;Status EnQueue(LinkedQueue* q, Element e)&#123; QueueNode* new = malloc(sizeof(QueueNode)); new-&gt;data = e; new-&gt;next = NULL; if (isEmptyQueue(q)) &#123; // 处理空队情况 q-&gt;front = q-&gt;rear = new; return OK; &#125; else &#123; // 处理非空队情况 q-&gt;rear-&gt;next = new; // 原队尾结点的next指向新结点 q-&gt;rear = new; // 更新队尾指针 return OK; &#125; return ERROR;&#125;Status DeQueue(LinkedQueue* q, Element* e)&#123; if (isEmptyQueue(q)) &#123; // 空队直接返回 e = NULL; return OK; &#125; if (q-&gt;front == q-&gt;rear) &#123; // 处理队中只有一个结点的情况 *e = q-&gt;front-&gt;data; free(q-&gt;front); q-&gt;front = q-&gt;rear = NULL; return OK; &#125; // 处理队中不止一个结点的情况 QueueNode* del = q-&gt;front; // 标记队头结点 q-&gt;front = del-&gt;next; // 队头指针指向下一个结点 *e = del-&gt;data; // 取数据 free(del); // 删除原队头结点 del = NULL; return OK;&#125;bool isEmptyQueue(LinkedQueue* q)&#123; return q-&gt;front == NULL || q-&gt;rear == NULL;&#125;void PrintLinkedQueue(LinkedQueue* q)&#123; if (isEmptyQueue(q)) &#123; printf(&quot;Queue Empty&quot;); &#125; QueueNode* p = q-&gt;front; while (p) &#123; printf(&quot;\\t%s &quot;, p-&gt;data); p = p-&gt;next; &#125;&#125; 邻接矩阵的 BFS12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667/** BFS begin */void BFSTraverse_AMG(MatrixGraph* G)&#123; for (int i = 0; i &lt; G-&gt;v_count; i++) visited[i] = UNVISITED; // 循环遍历每个顶点 for (int i = 0; i &lt; G-&gt;v_count; i++) if (!visited[i]) // 如果没有访问过就遍历访问 BFS_AMG(G, i);&#125;void BFS_AMG(MatrixGraph* G, int index)&#123; printf(&quot;-&gt; %s &quot;, G-&gt;vexes[index]); // 访问顶点 visited[index] = VISITED; // 更改访问状态 LinkQueue queue; InitLinkedQueue(&amp;queue); // 初始化队列 EnQueue(&amp;queue, G-&gt;vexes[index]); // 当前顶点入队，对应上图中第一步的 v0 入队 while (!isEmptyQueue(&amp;queue)) &#123; // 取出队头元素，遍历队头顶点的所有邻接点 Vertex vex; DeQueue(&amp;queue, &amp;vex); // 取出的队头顶点 // 获取该顶点的所有邻接点 for (int i = FirstAdjVex_AMG(G, vex); i; i = SecondAdjVex_AMG(G, vex, G-&gt;vexes[i])) &#123; if (!visited[i]) &#123; printf(&quot;-&gt; %s &quot;, G-&gt;vexes[i]); // 遇到顶点的邻接点先访问 visited[i] = VISITED; EnQueue(&amp;queue, G-&gt;vexes[i]); // 再入队 &#125; &#125; &#125;&#125;int FirstAdjVex_AMG(MatrixGraph* G, Vertex v)&#123; int defaultWeight = G-&gt;kind &lt;= 1 ? 0 : INT_MAX; // 图/网 的默认权重 int vex_index = LocateVex(G, v); // 获取顶点下标 if (vex_index == -1) return ERROR; // 搜索图的邻接矩阵中域顶点v的第一个邻接点下标 for (int j = 0; j &lt; G-&gt;v_count; j++) if (G-&gt;matrix[vex_index][j] != defaultWeight) return j; return 0;&#125;int SecondAdjVex_AMG(MatrixGraph* G, Vertex v1, Vertex v2)&#123; int defaultWeight = G-&gt;kind &lt;= 1 ? 0 : INT_MAX; // 图/网 的默认权重 int index1 = LocateVex(G, v1); int index2 = LocateVex(G, v2); if (index1 == -1 || index2 == -1) return 0; for (int i = index2 + 1; i &lt; G-&gt;v_count; i++) if (G-&gt;matrix[index1][i] != defaultWeight) return i; return 0;&#125;/** BFS end */ 邻接表的 BFS按理来说邻接矩阵的 BFS 和邻接表的 BFS 应该是一样的，至少在无向图中是一样的。但是如果邻接表是用的头插法，那可能结果是不一样的 12345678910111213141516171819202122232425262728293031323334void BFSTraverse_ALG(AdjListGraph* G)&#123; for (int i = 0; i &lt; G-&gt;v_count; i++) // 初始化状态数组 visited[i] = UNVISITED; for (int i = 0; i &lt; G-&gt;v_count; i++) // 遍历顶点数组，逐一对每一个未访问的顶点执行 BFS if (!visited[i]) BFS_ALG(G, i);&#125;void BFS_ALG(AdjListGraph* G, int index)&#123; printf(&quot;-&gt; %s &quot;, G-&gt;vexes[index].data); // 访问顶点 visited[index] = VISITED; // 更改顶点状态 LinkQueue queue; InitLinkedQueue(&amp;queue); EnQueue(&amp;queue, G-&gt;vexes[index].data); // 当前顶点入队 while (!isEmptyQueue(&amp;queue)) &#123; // 取出队头元素，遍历队头顶点的所有邻接点 Vertex vex; DeQueue(&amp;queue, &amp;vex); // 取出队头元素 // 遍历所有邻接点 EdgeNode* node = G-&gt;vexes[LocateVex_ADJ(G, vex)].firstEdge; while (node) &#123; if (!visited[node-&gt;adjvex]) &#123; printf(&quot;-&gt; %s &quot;, G-&gt;vexes[node-&gt;adjvex].data); // 邻接点先访问 visited[node-&gt;adjvex] = VISITED; EnQueue(&amp;queue, G-&gt;vexes[node-&gt;adjvex].data); // 再入队 &#125; node = node-&gt;nextEdge; &#125; &#125;&#125; 总结 存储结构： 邻接矩阵：一维数组存储顶点集+二维数组存储边/弧 邻接表：一维数组存储顶点集+单链表存储边/弧 出边表：链表的结点存储的是弧头的下标 入边表：链表的结点存储的是弧尾的下标 十字链表：将出边表和入边表整合起来，主要针对有向图 邻接多重表：将所有边链的结点整合起来，去除重复的结点，主要针对无向图 边集数组：一维数组存储顶点集+一维数组存储边集，关注的是边 图的遍历： 深度优先搜索 DFS 和 广度优先搜索 BFS 是图的最基本的遍历方式。 DFS 是仿树的前序遍历，利用栈做辅助，具体实现是不断将当前顶点的第一个未访问邻接点拿去递归。 BFS 是仿树的层序遍历，利用队列做辅助，具体实现是每当出队一个元素时，就访问其所有未访问且未入队的邻接点，并将这些邻接点入队。 使用邻接矩阵存储和使用邻接表存储的图在做 DFS 或 BFS 时没什么区别，只不过邻接矩阵是操作二维数组，邻接表是操作链表。 [^1]: 对称矩阵：n阶矩阵的元满足 $a_{ij} = a_{ji}, (0 \\leq i, j \\leq n)$，即从矩阵左上角到右下角的主对角线为轴，右上角的元与左下角相对应的元完全相等。","categories":[{"name":"DataStruction","slug":"DataStruction","permalink":"https://www.boii.xyz/categories/DataStruction/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"https://www.boii.xyz/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"DataStruction","slug":"DataStruction","permalink":"https://www.boii.xyz/tags/DataStruction/"}]},{"title":"DataStruction 0x07 图-1","slug":"DataStruction [7-图1]","date":"2021-02-23T08:00:42.000Z","updated":"2021-05-23T04:26:11.992Z","comments":true,"path":"2021/02/23/DataStruction [7-图1]/","link":"","permalink":"https://www.boii.xyz/2021/02/23/DataStruction%20[7-%E5%9B%BE1]/","excerpt":"什么是图？","text":"什么是图？ 7-图图 是有顶点的有穷非空集合和顶点之间边的集合组成，通常表示为：G（ V, E ）其中 G 表示一个图，V 是顶点集合，E 是边的集合。 线性表的数据元素 -&gt; 元素 Element树中的数据元素 -&gt; 结点 Node图中的数据元素 -&gt; 顶点 Vertex[^0] 线性表没有数据元素 -&gt; 空表树中没有数据元素 -&gt; 空树图中没有数据元素 -&gt; 不行！ 线性表中，相邻的元素之间具有线性关系树中，相邻的两层之间具有层次关系图中，任意两个顶点之间都可能有关系。顶点之间的逻辑关系用边来表示。边集可以为空。 定义无向边若顶点 vi 到 vj 之间的边没有方向，则称这条边为无向边（Edge）[^1]，用无序偶对（vi, vj） 来表示。如果图中任意两个顶点之间的边都是无向边，则称该图为无向图（Undirected graphs）[^2]。 上图就是一个无向图，K 到 T 之间的边可以表示成无序对（K, T）或者（T, K）。而整个图可以描述成为 **G1 = (V1，{E1})**，其中顶点集合 V1={G, Z, K, T, C}；边集合 E1 = { (G, Z), (G, K), (Z, K), (Z, T), (K, T), (K, C), (T, C) }； 有向边若顶点 vi 到 vj 之间的边有方向，则称这条边为弧（Arc）[^3]。用无序偶对 &lt;vi, vj&gt; 来表示，vi 称为弧尾（Tail），即指出去的那个，vj 称为弧头（Head），即被指的那个。如果图中任意两个顶点之间的边都是有向边，则称该图为有向图（Directed graphs）[^4]。 上图就是一个有向图，连接 G 到 K 的边就是弧，K 是弧头，被指向的那个，G 是弧尾，指出去的那个。&lt;G, k&gt; 表示弧，不能写为 &lt;K, G&gt;。而整个图可以描述成为 **G2 = (V2, {E2})**，其中顶点集合 V2 = &#123;G, Z, K, T, C&#125;；弧集合 E2 = &#123; &lt;G, K&gt;, &lt;Z, G&gt;, &lt;Z, K&gt;, &lt;K, T&gt;, &lt;T, Z&gt;, &lt;T, C&gt;, &lt;C, K&gt; &#125;； 注意：无向边用 () 表示， 有向边用 &lt; &gt; 表示。 简单图在图中若不存在顶点到其自身的边，且同一条边不重复出现，则称这样的图为简单图[^5]。在无向图中，如果任意两个顶点之间都存在边，则称该图为无向完全图[^6]在有向图中，如果任意两个顶点之间都存在方向互为相反的两条弧，则称该图为有向完全图。[^7] 含有 n 个顶点的无向完全图有 $\\frac {n(n-1)} 2$ 条边，如上图的无向完全图有4个顶点，边数为 $4 \\times 3 \\div 2 = 6$ 含有 n 个顶点的有向完全图有 $n \\times (n-1)$ 条边，如上图的有向完全图有4个顶点，边数为 $4 \\times 3 = 12$ 推广一下：在非完全的图中，设图具有 n 个顶点和 e 条边，若该图为无向图则 $0 \\leq e \\leq \\frac {n(n-1)} 2$若该图为有向图则 $0 \\leq e \\leq n(n-1)$ 有很少条边或弧称为稀疏图，反之称为稠密图。稀疏和稠密的相对的概念，没有严格定义。 权、网图的边或弧有相关的数值，这个数叫做权（Weight）[^6]，可以表示一个顶点到另一个顶点的距离或耗费等等。这种带全的图通常称为网（Network）[^7]。 子图假设两个图 G = (V, {E}) 和 G’ = (V’, {E’})，如果 $V’ \\subseteq V$ 且 $E’ \\subseteq E$，则称 G’ 为 G 的子图（Subgraph）[^8]。 图的顶点和边间的关系度无向图的度对于无向图 G = (V, {E}) 如果边 $(v, v’) \\in E$，则称顶点 v 和 v’ 互为 邻接点（Adjacent），即 v 和 v’ 相邻接。 边 (v, v’) 依附（incident） 于顶点 v 和 v’，即边（v, v’）与顶点 v 和 v’ 相关联。 顶点 v 的度（Degree）[^9] 是和 v 相关的边的数量，记为 **TD(v)**。 eg: 例如这个图，顶点 G 和 K 互为邻接点，边 （G, K）依附于 G 和 K 上，K顶点的度为 3。 图的边数为 5，各个顶点的度的和 = 3+3+2+2 = 10，其中重复两次计数，所以边数应为个顶点度数之和的一半。 记作 $$e= \\frac 1 2 \\sum_{i=1}^n TD(v_i)$$ 有向图的度对于有向图 G = (V, {E}) 如果弧 $\\langle v, v’ \\rangle \\in E$，则称：顶点 v 邻接到 v’，顶点 v’ 邻接自 v。顶点 v 和 v’ 互为邻接点（Adjacent）。 弧 &lt;v, v’&gt; 依附（incident） 于顶点 v 和 v’，即弧 &lt;v, v’&gt; 与 顶点 v 和 v’ 相关联。 以顶点 v 为头的弧的数量称为 v 的入度（InDegree）[^10]，记为 ID(v); 以顶点 v 为尾的弧的数量称为 v 的出度（OutDegree）[^11]，记为 OD(v); 顶点 v 的度（Degree） 为 **TD(v) = ID(v) + OD(v)**。 eg: 例如这个图，顶点 G 和 K 互为邻接点，顶点 G 邻接到 K，K 邻接自 G。 边 （G, K）依附于 G 和 K 上，顶点 K 的入度为 2，$ID(K) = 2$，出度为 1，$OD(K) = 1$，度为 $TD(K) = ID(K) + OD(K) = 3$ 图的弧数为 5，各个顶点的入度和 = 1+2+2+0 = 5，出度和 = 1+1+0+3 = 5； 由此可得有向图的弧数: $$e= \\sum_{i=1}^n ID(V_i) = \\sum_{i=1}^n OD(v_i)$$。 路径无向图G = (V, {E})中从顶点 v 到顶点 v’ 的路径（Path）[^12]是一个顶点序列 $(v = v_{i,0}, v_{i,1}, …, v_{i,m} = v’)$，其中 $(v_{i,j-1}, v_{i,j}) \\in E, 1\\leq j \\leq m$。 G 到 T 有四种路径。 如果 G 是有向图，则路径也是有向的，顶点序列应满足 $\\langle v_{i,j-1}, v_{i,j}\\rangle \\in E, 1 \\leq j \\leq m$。 上图种 G 到 T 只有一种路径，其他路径都不行。因为 G 到 Z 不存在路径。 路径的长度[^13]是路径上的边或弧的数量。例如上图的有向图，G到T的路径长度为2。 第一个顶点到最后一个顶点相同的路径称为回路（circuit）或环（Cycle）[^14]。 序列种顶点不重复出现的路径为简单路径[^15]。 除了第一个顶点和最后一个顶点之外，其余顶点不重复出现的回路，称为简单回路（Simple circuit）或简单环（Simple Cycle）。 左边图路径为 {B, C, D, A, B}，第一个顶点和最后一个顶点都是 B，且 C、D、A没有重复出现，所以是一个简单环右边图路径为 {B, C, D, A, C, B}，由于 C 重复，所以不是简单环。 连通图无向连通图 无向图中：任意两个顶点之间都有直接或间接的路径，即都能到达，则称这个图为连通图（Connected Graph）[^16]。例如 图1 就是非连通图，图2、3、4 就是连通图。 无向图中的极大连通子图（Great Connected Subgraph）称为连通分量（Connected Component）[^17]，它强调： 必须是子图（子图） 子图是连通的（连通） 连通子图含有极大顶点数（有极大顶点数） 具有极大顶点数的连通子图包含依附于这些顶点的所有边。（含有边） 例如 图1就是一个无向非连通图，但是它有两个连通分量 图2 和 图3，而 图4 虽然是 图1 的子图，但是不满足连通子图的极大顶点数（图2 满足），所以不是连通分量。 有向连通图 有向图中：任意两个顶点都有直接路径或间接路径，则称这个图为强连通图（Strong Connected Graph）[^18]。有向图中的极大强连通子图（Great Strong Connected Subgraph）称作有向图的强连通分量（Strong Connected Component）[^19]。 例如 图1 就不是一个强连通图，因为 1 到 4 有路径，而 4 到 1 没路径。而 图2 就是 图1 的极大强连通子图，即它的强连通分量。 生成树、生成森林生成树对连通图进行遍历，过程中所经过的边和顶点的组合可看做是一棵普通树，通常称为生成树（Spanning Tree）[^20]。 左边是一张连通图，右边则是其对应的两种生成树。连通图中，任意两顶点之间可能还有多条路径，遍历连通图的方式有多种，往往一张连通图可能有多种不同的生成树与之对应。 连通图中的生成树必须满足以下2个条件：包含连通图中所有的顶点；任意两顶点之间有且仅有一条通路；因此，连通图的生成树具有这样的特征：生成树中 边的数量 = 顶点数 - 1。 生成森林生成树的对于连通图来说的，而生成森林则是对应非连通图来说的。非连通图可以分解为多个连通分量，而每个连通分量又各自对应多棵生成树，因此与整个非连通图相对应的，是由多棵生成树组成的生成森林（Spanning Forest）[^21]。 上图左边是一张非连通图，可以分解为右边三个连通分量，其中各个连通分量对应的生成树如下所示： 上图只是列出各个连通分量的其中一种生成树。 总结 图由顶点和边组成，无向图由顶点和边构成，有向图由顶点和弧构成，弧分弧头弧尾。 任两个顶点之间都存在边叫完全图，分有向完全图和无向完全图。同一条边不重复出现的图叫简单图 顶点之间有邻接点、依附的概念，无向图的顶点的边数叫度，有向图的顶点分出度和入度，度 = 出+入。 从图的顶点集和边集中取一小部分组成新的图，称为原图的子图。 带数值的边叫权，顶点和权构成网 图中顶点间存在路径，两顶点存在路径则说明是连通的，如果路径最终回到起始点则称为环，当中顶点没有重复过称为简单路径。若任意两顶点都是连通的，则图是连通图，有向则是强连通图。图中有子图，若子图极大连通则称连通分量，有向则称强连通分量。 无向图中连通且边数= 顶点数 - 1 的树叫生成树，无向非连通图的连通分量生成的生成树一起构成生成森林。 有向图中一个顶点入度为0，其他顶点的入度为1的叫有向树。一个有向图由若干棵有向树构成生成森林。 [^0]: 顶点 -&gt; 图的数据元素[^1]: 边 -&gt; 边没有方向[^2]: 无向图 -&gt; 边没有方向的图，n个顶点的无向图最多有 $\\frac {n(n-1)} 2$ 条边[^3]: 弧 -&gt; 边有方向；弧有弧头弧尾之分[^4]: 有向图 -&gt; 边有方向的图，n个顶点的有向图最多有 $n(n-1)$ 条边[^5]: 简单图 -&gt; 同一条边不重复出现的图[^6]: 无向完全图 -&gt; 任意两个顶点之间都有边，共有 $\\frac {n(n-1} 2$ 条边[^7]: 有向完全图 -&gt; 任意两个顶点之间都有弧，共有 $n(n-1)$ 条弧 [^6]: 权 -&gt; 有数值的边[^7]: 网 -&gt; 顶点+权 [^8]: 子图 -&gt; 从原图中拆出来的图[^9]: 度 -&gt;顶点的边数[^10]: 入度 -&gt; 邻接到顶点的边的数量[^11]: 出度 -&gt; 顶点邻接出去的边的数量[^12]: 路径 -&gt; 两个顶点之间的直接线路或间接线路的边集序列，注意是序列，所以可能不止一条[^13]: 路径长度 -&gt; 两个顶点之间的线路的边数[^14]: 回路或环 -&gt; 从起始点离开最后到达起始点的路径[^15]: 简单路径 -&gt; 回路上没有重复的点的路径[^16]: 连通图 -&gt; 任意两顶点都是连通的无向图[^17]: 连通分量 -&gt; 无向图的极大连通的子图[^18]: 强连通图 -&gt; 任意两顶点都是连通的有向图[^19]: 强连通分量 -&gt; 有向图的极大连通的子图[^20]: 生成树 -&gt; 无向连通图生成的 边的数量 = 顶点数 -1 的树[^21]:生成森林 -&gt; 无向非连通图的连通分量生成的生成树一起构成生成森林","categories":[{"name":"DataStruction","slug":"DataStruction","permalink":"https://www.boii.xyz/categories/DataStruction/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"https://www.boii.xyz/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"DataStruction","slug":"DataStruction","permalink":"https://www.boii.xyz/tags/DataStruction/"}]},{"title":"DataStruction 0x06 树","slug":"DataStruction [6-树]","date":"2021-02-23T08:00:41.000Z","updated":"2021-05-23T04:26:09.535Z","comments":true,"path":"2021/02/23/DataStruction [6-树]/","link":"","permalink":"https://www.boii.xyz/2021/02/23/DataStruction%20[6-%E6%A0%91]/","excerpt":"什么是数据结构？","text":"什么是数据结构？ 6-树定义n个结点的有限集。n=0时称为空树。n&gt;1时，有且仅有一个特定的根节点 root，其余结点可分为 m（m&gt;0）个互不相交的有限集 T1、T2、…、Tm，其中每个集合本身又是一棵树，称为子树。 名词解释 名词 解释 示例 结点 树中的一个独立单元。包含一个数据元素及若干指向其他子树的分支。 eg：图中每一个圆圈都是结点。 结点的度 结点拥有的子树的数量。 eg：A的度为3，B的读为2，C的度为1。 树的度 树内各结点的度的最大值。 eg：上面的树的度为3。 树的高度（深度） 树中的最大层数。 eg：图中树的深度（高度）为 4。 叶子结点 度为0的结点。，也称终端结点。 eg：K、L、F、G、M、I、J 都是叶子结点。 分支结点 度不为0的结点，也称非终端结点。 eg： A、B、C、D、E、H 都是非终端结点。 双亲结点 一个结点的直接前驱结点称为其双亲结点。 eg：E的双亲为B，G的双亲为C。 孩子结点 一个结点的所有直接后继结点称为其孩子结点。 eg：B的子结点为E、F，H的子结点为M。 兄弟结点 同一个双亲的子结点之间互称兄弟结点。 eg：H的兄弟结点为I、J。 祖先 从一个结点到根节点所经分支上的所有结点。 eg：K的祖先为E、B、A。 子孙 一个结点所有直接和间接后继结点。 eg：D的子孙为H、I、J、M。 堂兄弟 双亲在同一层的结点互为堂兄弟。 eg：G与E、F、H、I、J 互为堂兄弟。 层 根为第一层，根的孩子为第二层，以此类推 eg：A为1层，B、C、D为2层，K、L、M为3层。 有序树、无序树：树中的结点从左至右依次有序不能互换，称为有序，否则称为无序。有序树中最左边的子树称为根节点的第一个孩子，最右边称为根节点的最后一个孩子。森林：m棵不相交的树的集合。 ADT12345678910111213141516171819ADT TreeData 树是由一个根结点和若干子树构成。树中结点具有相同数据类型及层次关系。Operation InitTree(T*): 构造空树T DestoryTree(T*): 销毁树T CreateTree(T*, definition): 按definition中给出的树的定义来构造树 ClearTree(T*): 若树T存在，则将树T清空为空树 TreeEmpty(T): 若T为控诉，返回true，否则返回false TreeDepth(T): 返回树T的深度 Root(T): 返回T的根节点 Value(T, cur_e): cur_e 是树T中一个结点，返回此结点的值 Assign(T, cur_e, value): 给树T的结点cur_e赋值为 value Parent(T, cur_e): 若 cur_e 是树T的非根结点，则返回它的双亲，否则返回空 LeftChild(T, cur_e): 若 cur_e 是树T的非叶结点，则返回它的最左孩子，否则返回空 RightSibling(T, cur_e): 若 cur_e 有右兄弟，则返回它的右兄弟，否则返回空 InsertChild(T*, p*, i, c): 其中p指向树T的某个结点，i为所指结点p的度+1，非空树c与T不相交，操作结果为插入c为树T中p指结点的第i棵子树 DeleteChild(T*, p*, i): 其中p指向树T的某个结点，i为所指结点p的度，操作结果为删除T中p所指结点的第i棵子树endADT 存储结构顺序结构双亲表示法除了根节点，其他结点一定有双亲结点 双亲表示法有两种： 只能简单的记录结点关系的一维数组 带数据域和指示域的多维数组 我们利用一维数组，下标表示树中的结点，数组元素的内容表示该结点的双亲结点。 用结构数组，每个结点附设一个指示器指示其双亲结点在表中的位置。上图的树用多维数组表示为： 下标 数据 双亲 0 A -1 1 B 1 2 C 1 3 D 2 4 E 2 5 F 3 6 G 3 7 H 4 用代码实现如下： 1234567891011121314151617181920#define MAX_TREE_SIZE 100typedef char Element; // 数据元素类型，暂定为字符型typedef struct &#123; Element data; // 数据域 int parent; // 双亲位置&#125; PTNode;typedef struct &#123; PTNode nodes[MAX_TREE_SIZE]; // 结点数组 int root, node_count; // 根的位置和结点数&#125; PTree;Status insert(PTree* pt, Element e, int p) &#123; pt-&gt;nodes[pt-&gt;node_count].data = e; pt-&gt;nodes[pt-&gt;node_count].parent = p; if (p == -1) pt-&gt;root = pt-&gt;node_count; pt-&gt;node_count++;&#125; 这种结构的话很容易找到一个结点的双亲结点，如果parent为-1即表示此结点为根节点。但是如果要找结点的孩子，只能遍历整个数组。 链式结构二叉树 Binary Tree定义二叉树是 n（n &gt;= 0）个结点的有限集合，该集合或者为空集，或者有一个根结点和两棵不相交的分别称为根结点的左子树和右子树的二叉树组成。 一棵树的度为 n 时，又称 n 叉树。所以二叉树的度为2，即每个结点最多有2个子结点。 特点 每个结点最多有两棵子树，所以二叉树中不存在度 &gt; 2 的结点。 左子树和右子树是有顺序的，次序不能任意颠倒。就像左手是左手，右手是右手，不能互换。 即使树中某结点只有一棵子树，也要区分是左子树还是右子树。就像摔伤了左手还是右手，对你生活的影响程度是不一样的。 二叉树有5种基本形态： 空二叉树 只有根节点 根节点+左子树 根节点+右子树 根节点+左子树+右子树 斜树所有结点都只有左子树的二叉树叫左斜树所有结点都只有右子树的二叉树叫右斜树 斜树有很明显的特点，每一层都只有一个结点，结点的个数与二叉树的深度相同。 满二叉树 在一棵二叉树中，所有分支节点都有左子树和右子树，且所有叶结点都在同一层，则称为 满二叉树。 注意单是每个结点都存在左右子树还不够，那样只算完全二叉树，还需要叶子节点都在同一层。满二叉树的特点有： 叶结点只能出现在最下层，其他层出现就不可能达成平衡 分支结点的度必须 = 2，否则就是缺胳膊少腿了。 在同样深度的二叉树中，满二叉树的结点树最多，叶子最多。 完全二叉树对一棵具有 n 个结点的二叉树按层序编号，如果编号为 i（1 &lt;= i &lt;= n）的结点与同样深度的满二叉树中编号为i的结点在二叉树中位置完全相同，则这棵二叉树称为完全二叉树。 一棵满二叉树一定是完全二叉树，一棵完全二叉树不一定是满二叉树。 注意完全二叉树是按层序编号 第2棵树虽然有些结点没有连续，但是因为每个结点都是按层序编号，和满二叉树能对应第3棵树由于叶结点出现在最后一层（编号8、9、10）和倒数第三层（编号3）第4棵树应为12的结点编号为11，所以不是完全二叉树。 完全二叉树的特点： 叶子结点只能出现在最下面两层。 最下层的叶子一定集中在左部连续位置。 倒数两层，若有叶子结点，一定都在右部连续位置 如果结点度为1，则该结点只有左孩子，不能只有右孩子。 同样结点数的二叉树，完全二叉树的深度最小。 上图这两颗就是正确的完全二叉树。左边为满二叉树，右边为完全二叉树。 看右边那棵，叶结点只在最下两层（7、8、9、10、11、12），度为1时只有左孩子（6 -&gt; 12） 性质 性质1：在二叉树的第 i 层上最多有 $2^{i-1}$ 个结点。第一层是根结点，只有1个结点，$2^{1-1} = 2^0 = 1$第二层最多有2个结点，$2^{2-1} = 2^1 = 2$第三层最多有4个结点，$2^{3-1} = 2^2 = 4$第四层最多有8个结点，$2^{4-1} = 2^3 = 8$通过归纳法，可以得出：二叉树的第i层最多有 $2^{i-1}$ 个结点。推广一下：一棵树的度为 n 时，又称n 叉树。如果一棵三叉树、四叉树，在第i层上最多有 $3^{i-1}$、$4^{i-1}$ 个结点。由此可得：一棵 n 叉树在第i层上最多有 $n^{i-1}$个结点。 性质2：深度为 k 的二叉树总结点数最多有 $2^k - 1$个（k &gt;= 1）。如果有一层，最多共1个结点。$2^1 - 1 = 1$如果有两层，最多共3个结点。$2^2 - 1 = 3$如果有三层，最多共7个结点。$2^3 - 1 = 7$如果有四层，最多共15个结点。$2^4 - 1 = 15$通过归纳法，可以得出：深度为 k 的二叉树总结点数最多有 $2^k - 1$ 个。 性质3：对任何一棵二叉树 T，如果其叶子结点总数为 n0，度为 2 的结点总数为 n2，则 n0 = n2 + 1。例如上图右边的完全二叉树，叶子结点为7、8、9、10、11、12共6个，所以 n0 = 6；而度为2的结点1、2、3、4、5共5个，n2 = 5。所以 n0 = n2 + 1。 性质4：总结点数为 n 的完全二叉树的深度为 $⌊log_2 n⌋ + 1$。 ⌊x⌋ 表示对 x 向下取整。 例如上图左边的满二叉树，总结点数为 15，深度为 $⌊log_2 15⌋ + 1 = 4$。 性质5：若对一颗总结点数为 n 的完全二叉树（其深度为 $⌊log_2 n⌋ + 1$）的结点按层序编号，对任一结点 i （1 &lt;= i &lt;= n）有：- 如果 i = 1，则结点 i 是二叉树的根，无双亲，- 如果 i > 1，则其双亲结点是 $⌊i/2⌋$ 个。- 如果2i > n，则结点 i 无左孩子（结点 i 为叶子结点）；否则其左孩子是结点 2i。- 如果2i+1 > n，则结点 i 无右孩子；否则其右孩子是结点 2i+1。 例如这样一棵完全二叉树。总结点数 10；高度 4。 如果 i = 1，根节点。如果 i = 7，双亲就是 $⌊7/2⌋ = ⌊3.5⌋ = 3$如果 i = 6，(2i = 2*6 = 12) &gt; (10 = n)，所以6无左孩子如果 i = 4，(2i + 1 = 9) &gt; 10，所以4的右孩子是9. 总结一下就是： i = 1，为根结点 i 的双亲是 ⌊i/2⌋ i 的左孩子是 2i i 的右孩子是 2i + 1 存储结构顺序结构适用性不强，还是用链表结构比较好。 每个结点包含一个数据域和两个左右孩子指针域，当然也可以包含一个双亲域。 12345678910111213141516typedef struct &#123; int id; char* name;&#125; Elem;typedef struct BTNode&#123; Elem data; // 数据域 struct BTNode* lchild; // 左孩子 struct BTNode* rchild; // 右孩子&#125; BTNode;typedef struct &#123; BTNode* root; // 根结点 int depth; // 树的度 int count; // 总结点数&#125; BTree; 遍历 前序遍历法 DLR即先打印根结点，再打印左孩子，最后打印右孩子，以此类推 上面的打印顺序为：ABDHKECFIGJ 123456void PreOrderTraverse(BTree T) &#123; if (T == NULL) return; printf(&quot;%c&quot;, T-&gt;data); PreOrderTraverse(T-&gt;lchild); PreOrderTraverse(T-&gt;rchild);&#125; 中序遍历法 LDR即先打印左孩子，再打印根结点，最后打印右孩子，以此类推 上面的打印顺序为：HKDBEAIFCGJ 123456void InOrderTraverse(BTree T) &#123; if (T == NULL) return; InOrderTraverse(T-&gt;lchild); printf(&quot;%c&quot;, T-&gt;data); InOrderTraverse(T-&gt;rchild);&#125; 后序遍历法 LRD即先打印左孩子，再打印右孩子，最后打印根结点，以此类推 上面的打印顺序为：KHDEBIFJGCA 123456void PostOrderTraverse(BTree T) &#123; if (T == NULL) return; PostOrderTraverse(T-&gt;lchild); PostOrderTraverse(T-&gt;rchild); printf(&quot;%c&quot;, T-&gt;data);&#125; 层序遍历法即按层从左到右依次打印上面打印顺序为：ABCDEFGHIJK 总结前序就是根结点在前面中序就是根结点在中间后序就是根结点在后面 像这棵比较小的树，前序 DLR：ABDEC中序 LDR：DBEAC后序 LRD：DEBCA层次遍历 ：ABCDE 例题如果一棵二叉树的前序遍历序列为 ABCDEF，中序遍历序列为 CBAEDF，请问后序遍历序列为？解题思路： 前序的第一位或后序的最后一位，一定是根节点，所以这题的根结点就是 A。 接着看 A 在中序序列的位置，可以看出 CB 是 A 的左孩子，EDF是 A 的右孩子；然后在前序中就可以确定 BC 为一组，DEF 为一组。 二叉树的子树也是二叉树。根据这个道理，从前序中可以知道 B是左子树的根结点，同理D是右子树的根结点。 拿着 B 和 D 到中序序列中分析，分出左右子树，以此类推。 核心就是：从前序的第一个 或 后序的最后一个确定根结点，然后到中序里区分左右子树。 所以这道题应该是这样一棵树： 后序应该为： CBEFDA 线索二叉树 Threading Tree线索二叉树 = （前 | 中 | 后）遍历 + 二叉树。 虽然采用链式结构存储，每个结点存储本身数据和左右孩子的指针，但还是会带来一个问题：叶子结点没有子树，它们的孩子指针必然为 NULL，叶子越多，NULL 越多，这就导致不管什么树，都必然会浪费一定的空间。 例下图： 现在思考如何将那些 ^ 利用起来。如果一个结点没有孩子，则让孩子指针指向双亲？这样有的指有的不指，很奇怪，且实现起来很不方便。如果结合遍历顺序怎么样？可以。 因为在没有遍历的情况下，我们不知道一个结点的前驱是谁，后继是谁，不如在创建树时，如果没有子树，就换成记录前驱元素或后继元素。 这样创建出来的树，就叫线索二叉树。 线索二叉树的核心思想为： 如果有左子树，则左指针域指向左子树；如果没有左子树，则左指针指向前驱元素 如果有右子树，则右指针域指向右子树；如果没有右子树，则右指针指向后继元素 这里的前驱和后继指的是 某个结点在 遍历后得到的序列中 的前驱和后继。 例如： 后序遍历得到序列：CBEFDA。其中 E 是 F 的前驱，D 是 F 的后继。 即：线索二叉树 = （前 | 中 | 后）遍历 + 二叉树。 我们在将左右指针指向子树还是前驱后继这个行为叫做线索化。 实现细节定义了二叉树，我们需要讨论：如何知道一个结点的孩子指针是指向子树还是指向前驱后继？为了解决这个问题，还需要在每个结点中增加两个变量 ltag 、rtag。当 ltag 或 rtag 为 0 时表示有孩子，指针域指向子树，为 1 时表示没有孩子，指针域指向前驱或后继。 1234567typedef struct BTNode&#123; Elem data; // 数据域 struct BTNode* lchild; // 左孩子 struct BTNode* rchild; // 右孩子 int ltag; int rtag;&#125; BTNode; 这样在创建一棵树时，如果某个结点有左子树，ltag 为 0，lchild 指向左子树；如果没有左子树，ltag 为 1，lchild 指向前驱。eg：这样一棵二叉树，经过中序线索化以后，变成下面这样： 12345678910111213141516171819TTNode* pre; // 全局变量，指向刚刚访问过的结点void InThreading(TTNode* T) &#123; if(T) &#123; InThreading(T-&gt;lchild); // 递归左子树线索化 if(!T-&gt;lchild) &#123; // 没有左孩子 T-&gt;lchild = pre; // 指向前驱元素 T-&gt;ltag = 1; // 线索标志 &#125; if(!pre-&gt;rchild) &#123; // 前驱结点没有右孩子 pre-&gt;rchild = T; // 前驱右指针指向当前指针 pre-&gt;rtag = 1; // 线索标志 &#125; pre = T; // 保持 pre 指向 T 的前驱 InThreading(T-&gt;rchild); // 递归右子树线索化 &#125;&#125; 转换树转二叉树一棵不规则的树，在一定程度上可以转换为一棵二叉树。 转换方法： 连接：兄弟之间连线 断开：双亲结点只保留最左孩子，其余都断开 旋转：调整好位置 保留的做左子树，连接的做右子树 将这样一棵树转成二叉树。 第一步：兄弟结点之间连接起来。例如 BCD之间都连接起来了。第二步：除了双亲跟左孩子，其他联系都断开。例如A只保留与B，断开与CD的关系。第三步：旋转调整。保留下来的作为左子树，连接得来的作为右子树。例如B是保留下来的，作为左子树，CD是连接出来的，作为右子树。 口诀：一连接、二断开、三旋转、保留左子树、连接右子树。 二叉树转树二叉树转树 是 树转二叉树的逆过程 一旋转、二断开、三连接即可。 第一步：旋转，将右子树都旋转都同一层第二步：连接右子树结点与双亲结点第三步：断开兄弟间的连线 二叉树转森林判断一棵树是普通树还是二叉树，看它根结点有没有右子树。有就是二叉树，没有就是普通树。 二叉树转森林只需要把每个有孩子的右子树拆开作为单独一棵树即可。 哈夫曼树","categories":[{"name":"DataStruction","slug":"DataStruction","permalink":"https://www.boii.xyz/categories/DataStruction/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"https://www.boii.xyz/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"DataStruction","slug":"DataStruction","permalink":"https://www.boii.xyz/tags/DataStruction/"}]},{"title":"DataStruction 0x05 串","slug":"DataStruction [5-串]","date":"2021-02-23T08:00:40.000Z","updated":"2021-05-23T04:26:07.249Z","comments":true,"path":"2021/02/23/DataStruction [5-串]/","link":"","permalink":"https://www.boii.xyz/2021/02/23/DataStruction%20[5-%E4%B8%B2]/","excerpt":"什么是串？","text":"什么是串？ 5-串 串：0或N个字符组成的有限序列，一种限定了元素为字符的线性表。 长度：字符个数空串：0个元素子串：串中任意连续字符组成的子序列主串：包含子串的串 存储结构：串的实现可以用定长数组，也可以用变长的动态数组实现。 1234567// 定长数组#define MAX_SIZE 100typedef struct &#123; char str[MAX_SIZE + 1]; int length;&#125;Str; 123456// 变长动态数组typedef struct &#123; char *str; // 串 int length; // 串长度&#125;Str; 基本操作：赋值、取长度、比较、连接、复制、求子串、清空 当然串的操作还有非常多，比如返回字符在字符串中的位置，返回子串在字符串中的位置等等。 代码实现定义12345678910111213141516// DataElement.h#ifndef DATAELEMENT_H_INCLUDED#define DATAELEMENT_H_INCLUDED#define OK 1#define ERROR 0typedef int Status;/** 串结构 */typedef struct &#123; char* str; int length;&#125; Str;#endif // DATAELEMENT_H_INCLUDED 赋值12345678910111213141516171819202122232425262728Status Assign(Str* s, char* ch)&#123; int ch_length = 0; char* c = ch; while (*c) &#123; // 计算ch字符串长度 ++ch_length; ++c; &#125; if (ch_length == 0) &#123; // 如果是空串 s-&gt;str = NULL; s-&gt;length = 0; return OK; &#125; else &#123; // 开辟一块空间，+1 是为了放 \\0 结束符 s-&gt;str = (char*)calloc(ch_length + 1, sizeof(char)); // 分配失败返回ERROR if (s-&gt;str == NULL) return ERROR; // 逐个将ch的字符复制到s-&gt;str for (int i = 0; i &lt;= ch_length; i++) s-&gt;str[i] = *(ch + i); s-&gt;length = ch_length; return OK; &#125;&#125; 取长度1234int Length(Str* s)&#123; return s-&gt;length;&#125; 比较12345678910int compare(Str* s1, Str* s2)&#123; // 遍历时将两个字符串逐个比较 for (int i = 0; i &lt; s1-&gt;length &amp;&amp; i &lt; s2-&gt;length; i++) &#123; if (s1-&gt;str[i] != s2-&gt;str[i]) &#123; return s1-&gt;str[i] - s2-&gt;str[i]; &#125; &#125; return 0;&#125; 遍历是串中较为重要的操作。 逐个比较字符的ASCII码，若s1小于s2，返回负数；若s1大于s2，返回正数；若s1等于s2，返回0. 连接连接分两种情况讨论 一种是定长数组实现的字符串的连接 如果A有剩余空间且剩余空间大于B长度，循环B长度逐个复制到A 如果A无剩余空间或剩余空间小于B长度，将A扩容，再循环B长度逐个复制到A 一种是变长数组实现的字符串的连接 变长数组一般没有剩余空间的情况，后面的空间是否是空闲空间也无从得知，所以变长数组的字符串在连接时，通常是开辟一块新的空间，长度为A的长度+B的长度，然后遍历A，逐个复制到新字符串，遍历B，逐个复制到新字符串A的后面，最后补\\0。 123456789101112131415161718192021char* contact(Str* s1, Str* s2)&#123; // 创建一块新字符串空间，长度为 s1 + s2 char* new = (char*)calloc(s1-&gt;length + s2-&gt;length, sizeof(char)); int i = 0; while (i &lt; s1-&gt;length) &#123; // 把 s1 逐个字符赋值给新字符串 new[i] = s1-&gt;str[i]; i++; &#125; i = 0; while (i &lt; s2-&gt;length) &#123; // 把 s2 逐个字符赋值给新字符串 new[s1-&gt;length + i] = s2-&gt;str[i]; i++; &#125; new[s1-&gt;length + s2-&gt;length] = &#x27;\\0&#x27;; s1-&gt;length += s2-&gt;length; s1-&gt;str = new; // 让 s1 指向新字符串 return new;&#125; 复制12345678910char* copy(Str* dest, Str* src)&#123; int count = src-&gt;length &lt; dest-&gt;length ? src-&gt;length : dest-&gt;length; for (int i = 0; i &lt; count; i++) &#123; dest-&gt;str[i] = src-&gt;str[i]; &#125; dest-&gt;str[count] = &#x27;\\0&#x27;; return dest-&gt;str;&#125; 复制的时候，逐个将 src 字符串的字符 复制到 dest 字符串。 要注意的是，假设 dest 的长度为10，src 的长度为5，则将 src 覆盖到 dest 上，dest 上后面的几个字符但是不会被读取到 反过来则是 src 将 dest 整个覆盖，但是只能覆盖 dest 的字符个数，src 超出 dest 长度的字符会被丢弃。 所以在调用时要保证 dest 的长度比 src 的长。 取子串1234567891011121314151617181920/** * @description 从主串 base 的第 idx+1 个开始截取 len 个字符组成新的字符串 * @param base 主串 * @param idx 截取的起始下标 * @param len 截取字符数 */char* sub(Str* base, int idx, int len)&#123; // 越界或主串为空 if (idx + len &gt; base-&gt;length || base-&gt;length == 0) &#123; return NULL; &#125; // 分配空间，然后逐字符复制 char* substring = (char*)calloc(len, sizeof(char)); for (int i = 0; i &lt; len; i++) &#123; substring[i] = base-&gt;str[idx + i]; &#125; return substring;&#125; 清空1234567891011Status clear(Str* s)&#123; if (s-&gt;length == 0) &#123; return OK; &#125; for (int i = 0; i &lt; s-&gt;length; i++) &#123; s-&gt;str[i] = &#x27;\\0&#x27;; &#125; s-&gt;length = 0; return OK;&#125; 串的模式匹配 对某子串的定位操作。 主串也称作目标串 子串也称作模式串 思想：从主串首个位置起和模式串的首个字符比较，若相等，则逐一比较后续字符，否则从主串第二个字符开始，逐一比较后续字符，以此类推。匹配成功则返回模式串在主串中的位置，匹配失败则返回0. KMP 算法模式匹配主要有 BF 算法 和 KMP 算法。 BF 算法主要是一种暴力穷举，和上面介绍的思想一致。 KMP 算法就聪明多了，该算法充分体现了“失败是成功他妈”的道理，积极从上一次失败匹配中汲取信息，并应用到下一次匹配中，比起 BF 那种穷举法，KMP 会将模式串与失败位置对其再重新匹配。","categories":[{"name":"DataStruction","slug":"DataStruction","permalink":"https://www.boii.xyz/categories/DataStruction/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"https://www.boii.xyz/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"DataStruction","slug":"DataStruction","permalink":"https://www.boii.xyz/tags/DataStruction/"}]},{"title":"DataStruction 0x04 队列","slug":"DataStruction [4-队列]","date":"2021-02-23T08:00:39.000Z","updated":"2021-05-23T04:26:04.412Z","comments":true,"path":"2021/02/23/DataStruction [4-队列]/","link":"","permalink":"https://www.boii.xyz/2021/02/23/DataStruction%20[4-%E9%98%9F%E5%88%97]/","excerpt":"什么是队列？","text":"什么是队列？ 4-队列队列是只允许在一端进行插入操作，在另一端进行删除操作的受限的线性表。 队列是一种先进先出（FIFO）的线性表，就像水管一样，从一头进去，从另一头出来 队列有两个指针，一个指向队头，只允许删除，一个指向队尾，只允许插入。 对于队列的操作有插入和删除，也称作入队和出队，不能从中间取。 顺序队：队列的每一个元素在一段连续的内存空间，用数组实现。 链队：队列的每一个元素不一定紧挨着，用链表实现。 循环队：队头连接着队尾。 队的主要操作包括：创建、初始化、入队、出队、判空、判满、清空队列。 循环队顺序队是基于数组实现的，当入队一个元素的时候，队尾指针+1，当队尾指针=MAX_SIZE时队满；当出队一个元素的时候，队头指针+1，当队头指针=MAX_SIZE时，说明队空。 但是！！ 当队头和队尾都 = MAX_SIZE 时，实际上队空，但是却无法入队新元素，这种现象称之为假溢出。 所以为了解决这个问题，我们可以用循环队列。 ↑ 由空队入队两个元素，此时 fron == 0, rear == 2 ↑ 入队4个元素，出队3个元素，此时 front == 3, rear == 6 ↑ 入队2个元素，出队4个元素，此时 front == 7, rear == 0 ↑ 队空条件：front == rear ↑ 队满条件：(rear + 1)%MAX_SIZE == front 要实现循环队列，最重要的是怎么做才能让队头队尾指针在一个周期中循环。 答案是 front = (front + 1) % MAX_SIZE、rear = (rear + 1) % MAX_SIZE。 假设 MAX_SIZE == 8, front == 1，(front + 1) % MAX_SIZE等价于2 % 8 == 2 所以这条表达式，可以让队头队尾指针在 0~MAX_SIZE-1 这个周期中循环，也就是在 0, 1, 2, ... MAX_SIZE-1 中循环。 要素循环队列的两个状态 队空： q-&gt;rear == q-&gt;front 队满： (q-&gt;rear + 1) % MAX_SIZE == q-&gt;front 入队： 12q-&gt;rear = (q-&gt;rear + 1) % MAX_SIZE; q-&gt;data[q-&gt;rear] = x; 出队： 12q-&gt;front = (q-&gt;front + 1) % MAX_SIZE;X = q-&gt;data[q-&gt;front]; 定义123456789101112131415161718192021222324// DataElement.h#ifndef DATAELEMENT_H_INCLUDED#define DATAELEMENT_H_INCLUDED#define MAX_SIZE 10#define OK 1#define ERROR 0#define TRUE 1#define FALSE 0typedef int Status;typedef int Bool;typedef struct &#123; int id; char* name;&#125; Element;typedef struct &#123; Element datas[MAX_SIZE]; int front; int rear;&#125; SqQueue;#endif // DATAELEMENT_H_INCLUDED 创建12345Status Create(SqQueue* q)&#123; q-&gt;front = 0; q-&gt;rear = 0;&#125; 初始化12345678910111213Status Init(SqQueue* q, Element* datas, int length)&#123; if (length &gt; MAX_SIZE) &#123; return ERROR; &#125; if (!(q-&gt;front &amp;&amp; q-&gt;rear)) Create(q); for (int i = 0; i &lt; length; i++) &#123; EnQueue(q, datas[i]); &#125;&#125; 入队12345678910Status EnQueue(SqQueue* q, Element e)&#123; // 如果队满, 无法入队 if (isFull(q)) return ERROR; q-&gt;rear = (q-&gt;rear + 1) % MAX_SIZE; // 先把队尾移动一格 q-&gt;datas[q-&gt;rear] = e; // 再把数据放进去 return OK;&#125; 出队12345678910Status DeQueue(SqQueue* q, Element* e)&#123; // 如果队空，无法出队 if (isEmpty(q)) return ERROR; q-&gt;front = (q-&gt;front + 1) % MAX_SIZE; *e = q-&gt;datas[q-&gt;front]; return OK;&#125; 判空1234Bool isEmpty(SqQueue* q)&#123; return q-&gt;front == q-&gt;rear;&#125; 判满1234Bool isFull(SqQueue* q)&#123; return q-&gt;front == (q-&gt;rear + 1) % MAX_SIZE;&#125; 打印队列123456789void Print(SqQueue* q)&#123; if (isEmpty(q)) printf(&quot;队列为空！&quot;); for (int i = q-&gt;front + 1; i &lt; q-&gt;rear + 1; i++) &#123; printf(&quot;%d \\t %s \\n&quot;, q-&gt;datas[i].id, q-&gt;datas[i].name); &#125;&#125; 测试数据123456789101112131415161718192021222324252627282930313233// main.c#include &quot;SqQueue.c&quot;#define len(X) sizeof(X) / sizeof(X[0])Element datas[] = &#123; &#123; 1, &quot;Iron Man&quot; &#125;, &#123; 2, &quot;Thor&quot; &#125;, &#123; 3, &quot;Captain&quot; &#125;, &#123; 4, &quot;Green Man&quot; &#125;&#125;;void main()&#123; SqQueue q; Create(&amp;q); Init(&amp;q, datas, len(datas)); printf(&quot;After Init(): \\n&quot;); Print(&amp;q); printf(&quot;\\n-------------------------------------\\n&quot;); Element el = &#123; 5, &quot;Big Man&quot; &#125;; EnQueue(&amp;q, el); printf(&quot;After EnQueue(): \\n&quot;); Print(&amp;q); printf(&quot;\\n-------------------------------------\\n&quot;); DeQueue(&amp;q, &amp;el); printf(&quot;After DeQueue(): \\n&quot;); printf(&quot;%d \\t %s&quot;, el.id, el.name);&#125;","categories":[{"name":"DataStruction","slug":"DataStruction","permalink":"https://www.boii.xyz/categories/DataStruction/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"https://www.boii.xyz/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"DataStruction","slug":"DataStruction","permalink":"https://www.boii.xyz/tags/DataStruction/"}]},{"title":"DataStruction 0x03 栈","slug":"DataStruction [3-栈]","date":"2021-02-23T08:00:38.000Z","updated":"2021-05-23T04:26:02.125Z","comments":true,"path":"2021/02/23/DataStruction [3-栈]/","link":"","permalink":"https://www.boii.xyz/2021/02/23/DataStruction%20[3-%E6%A0%88]/","excerpt":"什么是栈？","text":"什么是栈？ 3-栈栈是一种只允许在一端进行插入和删除操作的操作受限的线性表。 栈的主要特点是先进后出（FILO），就像子弹夹一样，最先压进去的子弹最后打出来。 栈有一个指针，永远指向栈的最顶部，称作栈顶指针。 栈的另外一个概念是栈底，在顺序栈中可不实现，在链栈中必须实现。 对于栈的操作有插入和删除，也称作入栈和出栈，不能从中间取出，只有一个口。 顺序栈：栈的每一个元素存储在一段连续的内存空间，用数组实现。 链栈：栈的每一个元素不一定紧挨着，用链表实现。 栈的主要操作包括：创建、初始化、入栈、出栈、判空、判满、获取栈顶元素、清空栈。 顺序栈定义12345678910111213141516171819202122232425#ifndef DATAELEMENT_H_INCLUDED#define DATAELEMENT_H_INCLUDED#define MAX_SIZE 10#define OK 1#define ERROR 0#define TRUE 1#define FALSE 0typedef int Bool;typedef int Status;/** 数据元素 */typedef struct &#123; int id; char* name;&#125; Element;/** 栈 */typedef struct &#123; Element datas[MAX_SIZE]; int top; // 栈顶指针&#125; Stack;#endif // DATAELEMENT_H_INCLUDED 创建1234Status Create(Stack *s) &#123; s-&gt;top = -1; return OK;&#125; 栈空条件有两种：s-&gt;top == -1、s-&gt;top == 0 这里采用第一种，原因是不需要浪费一个元素大小的空间，另外操作起来也方便，因为数组下标是从0开始的。 初始化1234567891011Status Init(Stack* s, Element* datas, int length) &#123; if (length &gt; MAX_SIZE) return ERROR; if (s-&gt;top != -1) Create(s); for (int i = 0; i &lt; length; i++) push(s, datas[i]); return OK;&#125; 入栈1234567Status push(Stack* s, Element e) &#123; if (s-&gt;top &gt;= MAX_SIZE - 1) return ERROR; s-&gt;datas[++s-&gt;top] = e; return OK;&#125; 我们采用的是第一种栈空表示方式，栈顶指针永远指向栈顶元素，所以在将元素赋值压入栈之前，要先把栈顶指针抬起来1格。 s-&gt;datas[++s-&gt;top] = e 等价于 s-&gt;top++; s-&gt;datas[s-&gt;top] = e。 出栈123Element pop(Stack* s) &#123; return s-&gt;datas[s-&gt;top--];&#125; 出栈的道理相同，先把元素取出来，然后栈顶指针降下去1格。 s-&gt;datas[s-&gt;top--] 等价于 s-&gt;datas[s-&gt;top]; s-&gt;top--;。 获取栈顶元素获取栈顶元素不会出栈，就像把弹夹取下来看一眼，并不是打出去。 123Element get(Stack* s) &#123; return s-&gt;datas[s-&gt;top];&#125; 判空我们采用的是第一种栈空表示方式，所以只要判断栈顶指针是不是 -&gt;top == -1即可。 123Bool isEmpty(Stack* s) &#123; return s-&gt;top == -1;&#125; 判满123Bool isFull(Stack* s) &#123; return s-&gt;top == MAX_SIZE - 1 ? TRUE : FALSE;&#125; 清空栈1234Status Clean(Stack* s) &#123; s-&gt;top = -1; return OK;&#125; 顺序栈的清空很简单，只需要把栈顶指针指向栈底即可，虽然原本的数据没有被销毁，但是后续push的数据会将其覆盖。即使没有覆盖，在栈中我们只需要关注栈顶指针 top 的指向即可，top 所指即为栈顶，不论 top 之上有没有数据。 至于销毁栈，需要在定义 Stack s 的地方 free(s) 。 打印栈1234void Show(Stack* s) &#123; for (int i = 0; i &lt;= s-&gt;top; i++) printf(&quot;%d \\t %s \\n&quot;, s-&gt;datas[i].id, s-&gt;datas[i].name);&#125; 测试数据12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#include &quot;SqStack.c&quot;Element datas[] = &#123; &#123; 1, &quot;Iron Man&quot; &#125;, &#123; 2, &quot;Green Man&quot; &#125;, &#123; 3, &quot;Thor&quot; &#125;, &#123; 4, &quot;Doctor&quot; &#125;&#125;;int main()&#123; Stack s; Create(&amp;s); Init(&amp;s, datas, sizeof datas / sizeof datas[0]); Show(&amp;s); printf(&quot;\\n----------------------------------\\n&quot;); Element e = &#123; 5, &quot;Big Man&quot; &#125;; push(&amp;s, e); Show(&amp;s); printf(&quot;\\n----------------------------------\\n&quot;); Element pe = pop(&amp;s); pop(&amp;s); Show(&amp;s); return 0;&#125;// ---------------------------------------------------// Output:1 Iron Man 2 Green Man 3 Thor 4 Doctor ----------------------------------1 Iron Man 2 Green Man 3 Thor 4 Doctor 5 Big Man ----------------------------------1 Iron Man 2 Green Man 3 Thor 链栈定义12345678910111213141516171819202122232425262728293031#ifndef DATAELEMENT_H_INCLUDED#define DATAELEMENT_H_INCLUDED#define MAX_SIZE 10#define OK 1#define ERROR 0#define TRUE 1#define FALSE 0typedef int Status;typedef int Bool;/** 数据元素 */typedef struct &#123; int id; char* name;&#125; Element;/** 链栈结点 */typedef struct Node &#123; Element data; struct Node* next;&#125; Node;/** 链栈 */typedef struct &#123; Node* next; int top;&#125; LStack;#endif // DATAELEMENT_H_INCLUDED 链栈稍微比顺序栈复杂一点点，但是换来不限栈大小的好处，所以在链栈中没有栈满的概念。 同时，链栈在入栈的时候需要手动分配空间，在出栈的时候需要把结点中的数据保存起来，销毁结点，再把数据返回。 创建12345Status Create(LStack* s) &#123; s-&gt;next = NULL; s-&gt;top = -1; return OK;&#125; 初始化123456789Status Init(LStack* s, Element* datas, int length) &#123; if (s-&gt;top != -1) Create(s); for (int i = 0; i &lt; length; i++) push(s, datas[i]); return OK;&#125; 入栈12345678910111213Status push(LStack* s, Element e) &#123;4// 建立新结点，分配空间 Node* new = (Node*)malloc(sizeof(Node)); // 判断分配空间是否成功 if (!new) return ERROR; new-&gt;data = e; // 插入到链表的首元结点，成为栈顶元素 new-&gt;next = s-&gt;next; s-&gt;next = new; s-&gt;top++;&#125; 这里的入栈使用的是头插法，即每个新插入的元素都会插在链表的首元结点的位置。 出栈1234567891011Element pop(LStack* s) &#123; Element res = s-&gt;next-&gt;data; // 将栈顶元素的数据复制一份 // 改链，原本指向栈顶元素，现在指向栈顶的下一个元素，使其成为新的栈顶 Node* p = s-&gt;next; s-&gt;next = p-&gt;next; // 将旧的栈顶元素释放空间 free(p); s-&gt;top--; return res;&#125; 链栈的出栈操作要记得把被弹出栈的旧栈顶元素释放。 获取栈顶元素123Element get(LStack* s) &#123; return s-&gt;next-&gt;data;&#125; 判空123Bool isEmpty(LStack* s) &#123; return s-&gt;top == -1;&#125; 清空栈12345678910111213141516171819Status Clean(LStack* s)&#123; if (s-&gt;top == -1) &#123; return OK; &#125; Node* deleted = s-&gt;next; Node* p; while (deleted) &#123; p = deleted-&gt;next; free(deleted); deleted = p; &#125; // s-&gt;next = NULL; // s-&gt;top = -1; Create(s); return OK;&#125; 清空链栈和销毁链表的操作是相同的，需要定义两个结点指针，相互配合实现整表销毁。 最后将栈置空，栈顶指针恢复到初试状态，所以这里调用了 Create()，等价于上面两句表达式。 打印链栈123456789101112void Show(LStack* s) &#123; if (s-&gt;top == -1) &#123; printf(&quot;Stack is EMPTY!&quot;); return; &#125; Node* p = s-&gt;next; for (int i = s-&gt;top; i &gt; -1; i--) &#123; printf(&quot;%d \\t %s \\n&quot;, p-&gt;data.id, p-&gt;data.name); p = p-&gt;next; &#125;&#125; 测试数据123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657#include &quot;LinkStack.c&quot;Element datas[] = &#123; &#123; 1, &quot;Iron Man&quot; &#125;, &#123; 2, &quot;Green Man&quot; &#125;, &#123; 3, &quot;Thor&quot; &#125;, &#123; 4, &quot;Doctor&quot; &#125;&#125;;int main()&#123; LStack s; Init(&amp;s, datas, 4); Show(&amp;s); printf(&quot;\\n----------------------------------\\n&quot;); Element e = &#123; 5, &quot;Big Man&quot; &#125;; push(&amp;s, e); Show(&amp;s); printf(&quot;\\n----------------------------------\\n&quot;); Element pe = pop(&amp;s); pop(&amp;s); Show(&amp;s); printf(&quot;\\n----------------------------------\\n&quot;); Clean(&amp;s); Show(&amp;s); return 0;&#125;// ---------------------------------------------------// Output:4 Doctor 3 Thor 2 Green Man 1 Iron Man ----------------------------------5 Big Man 4 Doctor 3 Thor 2 Green Man 1 Iron Man ----------------------------------3 Thor 2 Green Man 1 Iron Man ----------------------------------Stack is EMPTY! 共享栈 共享栈：指的是两个栈共用一个内存空间的一种栈结构。共享栈不需要用链式结构，因为共享栈为的是节省空间，用链式没有意义。 两个栈的栈底固定不变，讲两个栈顶设置在数组的两端，即 左边的栈 s0 的栈底设在 0 处，右边的栈 s1 的栈底设在 MAX_SIZE - 1 处。创建共享栈时，左栈的栈顶指针 topL = -1，右栈的栈顶指针 topR = MAX_SIZE，当两个栈顶相遇时栈满，这样可以尽可能地利用空间。 栈空 ↓ （topL == -1 &amp;&amp; topR == MAX_SIZE） 栈满 ↓ (topL == topR - 1) 普通状态 ↓ 定义共享栈的定义稍稍不同。 1234567891011121314151617181920212223242526#ifndef DATAELEMENT_H_INCLUDED#define DATAELEMENT_H_INCLUDED#define MAX_SIZE 10#define OK 1#define ERROR 0#define TRUE 1#define FALSE 0#define LEFT 1 // 和顺序栈的定义相比多一个 LEFT 和 RIGHT 来标记方向#define RIGHT 999typedef int Bool;typedef int Status;typedef struct &#123; int id; char* name;&#125; Element;typedef struct &#123; Element datas[MAX_SIZE]; // 栈的存储空间，用数组来存储 int topL; // 左栈的栈顶指针 int topR; // 右栈的栈顶指针&#125; ShareStack;#endif // DATAELEMENT_H_INCLUDED 创建123456Status Create(ShareStack* s)&#123; s-&gt;topL = -1; s-&gt;topR = MAX_SIZE; return OK;&#125; 创建时，讲两个指针初始化 初始化123456789101112131415161718Status Init(ShareStack* s, Element* datas, int length, int direction)&#123; if (length &gt; MAX_SIZE) &#123; return ERROR; &#125; if (direction == LEFT &amp;&amp; !isEmptyL(s)) &#123; s-&gt;topL == -1; &#125; if (direction == RIGHT &amp;&amp; !isEmptyR(s)) &#123; s-&gt;topR = MAX_SIZE; &#125; for (int i = 0; i &lt; length; i++) &#123; push(s, datas[i], direction); &#125; return OK;&#125; 共享栈需要多一个参数 direction，来指定将元素放入左栈还是右栈。 入栈1234567891011121314151617181920Status push(ShareStack* s, Element e, int direction)&#123; if (isFull(s)) &#123; return ERROR; &#125; switch (direction) &#123; case LEFT: s-&gt;datas[++s-&gt;topL] = e; return OK; case RIGHT: s-&gt;datas[--s-&gt;topR] = e; return OK; default: printf(&quot;Direction is ILLEGAL PARAMETER!&quot;); return ERROR; &#125;&#125; 出栈1234567891011121314151617181920212223Element pop(ShareStack* s, int direction)&#123; Element e; switch (direction) &#123; case LEFT: if (isEmptyL(s)) &#123; return e; &#125; e = s-&gt;datas[s-&gt;topL--]; return e; case RIGHT: if (isEmptyR(s)) &#123; return e; &#125; e = s-&gt;datas[s-&gt;topR--]; return e; default: printf(&quot;Direction is ILLEGAL PARAMETER!&quot;); break; &#125;&#125; 获取栈顶元素1234Element get(ShareStack* s, int direction)&#123; return s-&gt;datas[direction == LEFT ? s-&gt;topL : s-&gt;topR];&#125; 判空1234567891011121314Bool isEmpty(ShareStack* s)&#123; return s-&gt;topL == -1 &amp;&amp; s-&gt;topR == MAX_SIZE;&#125;Bool isEmptyL(ShareStack* s)&#123; return s-&gt;topL == -1;&#125;Bool isEmptyR(ShareStack* s)&#123; return s-&gt;topR == MAX_SIZE;&#125; 判满1234Bool isFull(ShareStack* s)&#123; return s-&gt;topL == s-&gt;topR - 1;&#125; 清空栈1234567891011121314151617181920Status Clean(ShareStack* s, int direction)&#123; if (isEmpty(s)) &#123; return OK; &#125; switch (direction) &#123; case LEFT: s-&gt;topL = -1; break; case RIGHT: s-&gt;topR = MAX_SIZE; break; default: return ERROR; &#125; return OK;&#125; 打印栈12345678910111213141516171819202122232425262728293031323334353637383940void Show(ShareStack* s, int direction)&#123; if (isEmpty(s)) &#123; printf(&quot;The Whole Share stack is EMPTY!\\n&quot;); &#125; switch (direction) &#123; // 打印左栈 case LEFT: if (isEmptyL(s)) &#123; printf(&quot;The Left Share stack is EMPTY!\\n&quot;); return; &#125; for (int i = 0, j = 1; i &lt;= s-&gt;topL; i++, j++) &#123; printf(&quot;No. %d is: %d \\t %s \\n&quot;, j, s-&gt;datas[i].id, s-&gt;datas[i].name); &#125; break; // 打印右栈 case RIGHT: if (isEmptyR(s)) &#123; printf(&quot;The Right Share stack is EMPTY!\\n&quot;); return; &#125; for (int i = s-&gt;topR, j = 1; i &lt; MAX_SIZE; i++, j++) &#123; printf(&quot;No. %d is: %d \\t %s \\n&quot;, j, s-&gt;datas[i].id, s-&gt;datas[i].name); &#125; break; // 如果传进来的不是 LEFT 也不是 RIGHT，则打印整个栈 default: for (int i = 0; i &lt; MAX_SIZE; i++) &#123; if (i &gt; s-&gt;topL &amp;&amp; i &lt; s-&gt;topR) &#123; // 超过左栈没到右栈的这段空白 printf(&quot;No. %d is EMPTY.\\n&quot;, i + 1); &#125; else &#123; printf(&quot;No. %d is: %d \\t %s \\n&quot;, i + 1, s-&gt;datas[i].id, s-&gt;datas[i].name); &#125; &#125; break; &#125;&#125; 测试数据1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859#include &quot;ShareStack.c&quot;#define len(X) sizeof(X) / sizeof(X[0])Element datas1[] = &#123; &#123; 1, &quot;Iron Man&quot; &#125;, &#123; 2, &quot;Green Man&quot; &#125;, &#123; 3, &quot;Thor&quot; &#125;, &#123; 4, &quot;Doctor&quot; &#125;&#125;;Element datas2[] = &#123; &#123; 12, &quot;Spider Man&quot; &#125;, &#123; 24, &quot;Wonder Woman&quot; &#125;, &#123; 35, &quot;Bat Man&quot; &#125;, &#123; 40, &quot;Super Man&quot; &#125;&#125;;int main()&#123; ShareStack ss; Create(&amp;ss); Init(&amp;ss, datas2, len(datas2), RIGHT); Show(&amp;ss, RIGHT); printf(&quot;\\n----------------------------------\\n&quot;); Init(&amp;ss, datas1, len(datas1), LEFT); Show(&amp;ss, LEFT); printf(&quot;\\n----------------------------------\\n&quot;); Show(&amp;ss, 10); return 0;&#125;// ---------------------------------------------------// Output:No. 1 is: 40 Super Man No. 2 is: 35 Bat Man No. 3 is: 24 Wonder Woman No. 4 is: 12 Spider Man ----------------------------------No. 1 is: 1 Iron Man No. 2 is: 2 Green Man No. 3 is: 3 Thor No. 4 is: 4 Doctor ----------------------------------No. 1 is: 1 Iron Man No. 2 is: 2 Green Man No. 3 is: 3 Thor No. 4 is: 4 Doctor No. 5 is EMPTY.No. 6 is EMPTY.No. 7 is: 40 Super Man No. 8 is: 35 Bat Man No. 9 is: 24 Wonder Woman No. 10 is: 12 Spider Man","categories":[{"name":"DataStruction","slug":"DataStruction","permalink":"https://www.boii.xyz/categories/DataStruction/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"https://www.boii.xyz/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"DataStruction","slug":"DataStruction","permalink":"https://www.boii.xyz/tags/DataStruction/"}]},{"title":"DataStruction 0x02 线性表","slug":"DataStruction [2-线性表]","date":"2021-02-23T08:00:37.000Z","updated":"2021-05-31T12:25:32.933Z","comments":true,"path":"2021/02/23/DataStruction [2-线性表]/","link":"","permalink":"https://www.boii.xyz/2021/02/23/DataStruction%20[2-%E7%BA%BF%E6%80%A7%E8%A1%A8]/","excerpt":"什么是线性表？","text":"什么是线性表？ 2-线性表 0或n个数据元素的有限序列 特点： 元素之间有序 元素个数有限 第一个无直接前驱元素 最后一个无直接后继元素 其余元素都有唯一一个直接前驱元素和唯一一个直接后继元素 线性表元素的个数 $n(n&gt;=0)$ 即为线性表的长度；当 n=0 时，称为空表。 非空表中每个数据元素都有一个确定的位置，如$a_1$是首个元素，$a_n$是最后元素，$a_i$是第$i$个元素（称 $i$ 为数据元素 $a_i$ 在线性表中的位序） ADT12345678910111213ADT 线性表(List)Data 线性表是数据对象集合为&#123;a1, a2, ..., an&#125;，每个元素的类型均为DataType。Operation InitList(*L): 初始化操作，建立一个空的线性表L。 ListEmpty(L): 线性表为空返回True， 否则返回False ClearList(*L): 将线性表清空。 GetElem(L, i, *e): 将线性表L中第i个位置元素的值返回给e。 LocateElem(L, e): 在线性表L中查找与给定值e相等的元素，查找成功返回元素在表中的序号，失败返回O。 ListInsert(*L, i, e): 在线性表L中第i个位置插入新元素e。 ListDelete(*L, i, *e): 删除线性表L中第i个位置元素，并用e返回其值。 ListLength(L): 返回线性表L的元素个数。endADT 顺序结构的线性表 线性表的顺序存储结构，指的是用一段连续的存储单元一次存储线性表的数据元素。例如数组，知道了第一个元素的地址，后面的元素都可以快速的计算出来。假设第一个元素的地址为 A，每个元素占 k 个字节，则可知第 i 个元素的地址为 A + i * k。 顺序结构在查找时，不论要查找的元素在任何位置，时间复杂度都为 $O(1)$，但在插入和删除时，平均时间复杂度为 $O(n)$。 顺序结构代码实现 先放上各专业术语的关系图，以做对照。 数据元素各种操作的基本单位是数据元素，数据元素又由各数据项构成。 在代码中，用 结构体类型(C语言中是结构体，Java等语言是类) 来实现数据元素，用各种 基本类型(int、char、float、其他结构体等) 来实现数据项。（注意数据项也可以是结构体） 1234567// 定义结构体struct Student&#123; char name[10]; int age;&#125;;typedef struct Student Student; // 为结构体起别名，后续写代码的时候比较方便 或者写成这种： 1234typedef struct&#123; char name[10]; int age;&#125;Student; 在实际应用中数据元素（结构体）名字以实际业务为准在以下例子中，则用 Element 指代 数据元素结构体。 1234typedef struct&#123; char name[10]; int age;&#125;Element; 数据对象这里数据对象指的就是线性表了。线性表中需要包含N个数据元素，N个数据元素要使用数组存放；再加上一个count来统计数据元素个数。 注意是元素个数 (count of data elemment) 不是数组长度(length of array)。 数组长度一开始要预留好，是固定不变的；元素个数是变化的，增删插入之后都会变化，而数组长度不会。 123456789// DataElement.h#define len(X) sizeof X / sizeof X[0]#defind MAX_SIZE 5typedef struct&#123; Element elemArr[MAX_SIZE]; int count; // Count of data element.&#125;SqList; 初始化12345678Status Init(SqList *L, Student *studArr)&#123; int length = len(studArr); // 获取数组长度 if(length &gt; MAX_SIZE) return ERROR; // 检查数组长度是否超出预设长度 L-&gt;count = 0; for(int i = 0; i &lt; length; i++) Insert(L, i, studArr[i]); return OK;&#125; 12345678910// main.c#include &quot;DataElement.h&quot;int main()&#123; SqList L; SqList *pL = &amp;L; Init(pL); return 0;&#125; 获得元素12345678910111213141516171819#define OK 1#define ERROR 0typedef int Structs;/** * 用e返回 在线性表L中第position个元素 * @param *L 要操作是顺序表 * @param position 要查找的元素位置 * @param *e 负责带回元素的元素指针 * @return 获得成功返回OK，失败返回ERROR */Status GetElem(SqList *L, int position, Element *pe)&#123; if(L-&gt;count == 0 || position &lt; 1 || position &gt; L-&gt;count) return ERROR; *pe = L-&gt;data[position-1]; return OK;&#125; 123456789//------------------------------------------------// 调用时SqList L;SqList *pL = &amp;L;Element e;Element *pe = &amp;e;if(GetElem(pL, 3, pe)) printf(&quot;%s %d&quot;, pe-&gt;name, pe-&gt;age); 函数中先是判断顺序表是否为空表（空表时 count 为 0），接着对位置进行判断，看看是否在合法范围内；如果满足其中一个条件则返回 ERROR。最后对将目标元素赋值给 pe。 参数中使用的是 *L，即直接操作目标顺序表position 代表的是位置，从1开始的（注意不是下标，下标是从0开始的），所以是将 data[position-1] 返回去例如查找第5个元素，应该返回 data[4] 插入123456789101112131415Status Insert(SqList *L, int idx, Element *pe)&#123; // 如果顺序表已满、或下标越界，返回ERROR if(L-&gt;count == MAX_SIZE || idx &lt; 0 || idx &gt; L-&gt;count) return ERROR; // 如果要插入的位置不在末尾 if(idx &lt; L-&gt;count) for(int i = L-&gt;count - 1; i &gt;= idx; i--) L-&gt;data[i + 1] = L-&gt;data[i]; L-&gt;data[i] = *pe; L-count++; return OK;&#125; 思路： 表满时，插入失败 下标小于 0 或大于 count - 1 时，插入失败 插入位置在表尾，即 idx = count，直接插入 插入位置不在表尾，即 idx &lt; count，从末尾开始后一位给前一位，直到把 data[idx] 空出来 删除12345678910111213141516Status Delete(SqList *L, int position, Element *e)&#123; // 如果空表或者位置超出范围，返回ERROR if(L-&gt;count == 0 || position &lt; 1 || position &gt; L-&gt;count) return ERROR; // 将要删除的元素保存起来 *e = L-&gt;data[position - 1]; // 如果删除的不是末尾元素 if (position &lt; L-&gt;count) for(int i = position; i &lt; L-&gt;count; i++) L-&gt;data[i - 1] = L-&gt;data[i]; // 元素个数-1 L-&gt;count--; return OK;&#125; 思路： 如果空表，或者位置超出范围[1, count]，删除失败 先将要删除的元素保存起来 如果删除的不是末尾元素，从删除位置开始到顺序表末尾，后一个赋值给前一个，最后元素个数-1 如果删除的是末尾元素，直接元素个数-1 总结数组在查询时，不管元素在哪个位置，时间复杂度都为 O(1)，在删除和插入时，如果位置靠后则挪动的少，如果位置在最前，则整个数组都要挪动。换言之，插入或删除第 i 个元素，需要移动 i - 1个元素。平均移动次数为 (n - 1)/2。所以时间复杂度为O(n)。 顺序结构比较适合元素个数不太变化，而是更多存取数据的应用。 链式结构的线性表 线性表的链式结构是指，指的是用不连续的存储单元存储线性表的数据元素。 在链式结构中，除了存储数据元素之外，还要存储其后继元素的地址。存储数据元素信息的域称为数据域，存储后继元素地址的域称为指针域；这两部分组成一个结点，n个结点链结成一个链表，即为线性表的链式存储结构。 因此，每个结点只包含一个后继指针域（指向后继元素的指针域），称为单链表；每个结点包含一个后继指针域（指向后继元素的指针域）和一个前驱指针域（指向前驱元素的指针域），称为双链表； 链表的起始结点称为头结点，头结点中的指针域称为头指针。头结点的数据域可以不存储任何信息，也可以存储线性表长度等附加信息；头结点的指针域指向第一个结点（第一个结点可以称为首元结点）；头结点的指针域为空时（即头指针为空时），为空链表。 链表的最后一个结点称为尾结点，尾结点的指针域可以为空（通常用 NULL 或 ^ 表示）尾结点的后继指针域为空时，称为单向链表；尾结点的后继指针域指向首元结点的地址时（指向首元结点不是头结点），称为循环链表。 同理，尾结点的后继指针域指 -&gt; 向首元结点的地址，首元结点的前驱指针域指 -&gt; 向尾结点时，称为双向循环链表。 单链表的代码实现定义结点1234567891011121314151617181920// 定义数据元素typedef struct Element &#123; char *name; int age;&#125;Element;// 定义结点typedef struct Node &#123; Element data; // 数据域 struct Node* next; // 指针域，指向本身类型定，称为自引用&#125;Node;// 为结点指针定义别名typedef Node* PNode;// 定义头结点typedef struct HeadNode &#123; int length; struct Node* next;&#125;HeadNode; 代码中，先是定义了数据元素的结构，然后定义结点。 定义结点的时候，分别定义了数据域和指针域。可以看到指针域其实是自身的指针，这样的实现称为自引用。 假设p是指向第 i 个结点的移动指针，则 p-&gt;data 的值第 i 个结点的数据，而 p-&gt;next 的值为下一个结点（即第 i + 1个结点）的地址。用 p = p-&gt;next; 可以让移动指针移动到第 i + 1 个结点，这时再使用 p-&gt;data 的值就为第 i + 1 个结点的数据。 最后为了方便表示，为这个结点类型的指针定义了一个类型别名 PNode。 1PNode p; 创建链表创建链表其实就是创建一个头结点，这个头结点很重要，对链表的操作都是从头结点开始的。 这里形参用的是指针形式，即直接操作该指针。所以在调用Create() 时取了link的地址。 123456789Status Create(HeadNode *head) &#123; head-&gt;length = 0; head-&gt;next = null; return OK;&#125;// 调用时HeadNode link;Create(&amp;link); 插入结点插入节点的思路为： 创建新结点并给结点的数据域赋值 如果要插入的位置为1（即首元节点），则将头结点的 next 给新节点，然后头结点的 next 指向新节点，长度+1； 如果要插入的位置不为1，则利用一个 node 指针遍历链表找到要插入位置的前一个结点，将前一个结点的 next 给新节点，然后前一个结点的 next 指向 新节点，长度+1； 1234567891011121314151617181920212223242526272829303132Status Insert(HeadNode *head, Element e, int pos) &#123; // 如果插入位置超过数组长度，则返回ERROR if(pos &gt; head-&gt;length)&#123; return ERROR; &#125;4// 1. 创建新节点并给新结点的数据域赋值 Node* newNode = (Node*)malloc(sizeof Node); newNode-&gt;data = e; newNode-&gt;next = NULL; // 2. 如果插入的位置为首元节点 if(pos == 1)&#123; newNode-&gt;next = head-&gt;next; head-&gt;next = newNode; head-&gt;length++; return OK; &#125; // 3. 如果插入的位置不是首元节点 // 声明一个移动指针遍历遍历直到达到要插入的位置的前一个结点 // 因为要到达前一个结点，所以这里走到 pos - 1 即可 Node* p = head-&gt;next; for(int i = 1; p &amp;&amp; i &lt; pos - 1; i++)&#123; p = p-&gt;next; &#125; newNode-&gt;next = p-&gt;next; p-&gt;next = newNode; head-&gt;length++; return OK;&#125;// 调用时Element e = &#123;&quot;Boii&quot;, 18&#125;;Insert(&amp;head, e, 4); 链表插入的重点在于要先将 前一个结点的指针域 新节点的指针域 newNode-&gt;next = p-&gt;next ，然后再把 新节点的地址给前一个结点的指针域 p-&gt;next = newNode ，这两者顺序不能颠倒，否则会插入失败。 创建一个新结点 newNode-&gt;next = p-&gt;next p-&gt;next = newNode 初始化链表初始化链表时需要将头结点和元素数组传给函数 上面我们已经定义好了 创建链表函数，插入结点函数，所以在初始化时非常方便，只需要调用Create()创建链表，然后遍历元素数组，调用Insert()即可。 1234567891011121314151617181920Status Init(HeadNode *head, Element *datas)&#123; // 创建链表 if(Create(head))&#123; // 遍历元素数组 for(int i = 0; i &lt; (sizeof datas / sizeof datas[0]); i++) Insert(head, datas[i], i + 1); return OK; &#125; return ERROR;&#125;// 调用时Element datas = &#123; &#123;&quot;Alice&quot;, 18&#125;, &#123;&quot;Boii&quot;, 20&#125;, &#123;&quot;Candy&quot;, 22&#125;&#125;;HeadNode head;Init(&amp;head, datas); 读取结点假设现在要读取第 i 个结点，在读取结点之前，要先找到结点，然后把数据保存起来。 获得链表第 i 个数据的思路： 声明一个移动指针 p，让 p 指向第一个结点； 声明一个计数器 j， 初始化 j 从 1 开始（因为 j 是用来和 i 做比较的，i 是从1开始算的）； 当 j &lt; i 时，就遍历链表，一直让移动指针 p 向后移动并且 j++，直到 j == i； 若到链表末尾 p 为空，则说明没找到第 i 个数据； 否则查找成功，返回 p 指向的结点的数据。 123456789101112131415Status GetElem(PNode List, int i, Element *e) &#123; PNode p = List-&gt;next; // 指向头结点； int j = 1; // 初始化计数器 while(j &lt; i || p ) &#123; p = p-&gt;next; // 让移动指针指向下一个结点 j++; &#125; // 如果 p 为空 或者 j &gt; i, 返回 error if(!p || j &gt; i) return ERROR; *e = p-&gt;data; return OK;&#125; 删除结点删除思路： 创建一个结点指针 Node*来暂存要被删除的结点的地址 找到要被删除的结点的前一个结点 让前一个结点的 next 指向被删结点的 下一个结点 free 释放被删结点的内存 1234567891011121314151617181920212223242526Status Delete(HeadNode *head, int pos)&#123; if(pos &gt; head-&gt;length)&#123; return ERROR; &#125; Node* p = head-&gt;next; /* 1. 如果删除的是首元节点 */ if(pos == 1)&#123; head-&gt;next = p-&gt;next; head-&gt;length--; free(p); return OK; &#125; /* 2. 如果删除的不是首元结点 */ /* 先找到要删除结点的前一个结点 */ for(int i = 1; p &amp;&amp; i &lt; pos - 1; i++)&#123; p = p-&gt;next; &#125; /* 然后删除目标结点 */ Node *q = p-&gt;next; // 创建一个Node型指针暂存被删结点 p-&gt;next = q-&gt;next; // 让被删结点的前驱元素的 next 指向被删结点的后驱元素 head-&gt;length--; // 长度-1 free(q); // 释放被删结点的空间 q = p = NULL; // 指针置空 return OK;&#125; C语言需要自己管理内存，自己管理指针释放指针，所以在删除之前要先将被删除结点保存起来，改链（p-&gt;next = q-&gt;next）之后将被删除结点的内存释放，最后把函数里创建的指针置空。 删除 i 结点其实就是让 i - 1 结点指向 i + 1. 删除之前的样子 Node* q = p-&gt;next p-&gt;next = q-&gt;next free(q) 循环链表 循环链表与单链表相比多了一个尾元结点指向首元节点。可以把尾元结点的指针称为尾指针。 当遍历循环链表时，可以通过判断 尾元结点-&gt;next == 头结点-&gt;next得知是否遍历了一圈了。 其实循环链表可以有2种实现形式： 尾指针指向头结点 尾指针指向首元结点 可根据需要选择相应的设计。 在操作上，循环链表和单链表的区别主要在插入和删除上。 插入操作循环链表的插入操作要考虑4种情况 链表是否为空 插入位置为首元节点 插入位置为尾元结点 插入位置为中间结点 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758Status Insert(HeadNode *head, Element e, int pos)&#123; if(pos &gt; head-&gt;length) return ERROR; // 创建新结点 Node *newNode = (Node*)malloc(sizeof Node); newNode-&gt;data = e; newNode-&gt;next = NULL; /** 1. 链表为空 */ if(!head-&gt;length)&#123; newNode-&gt;next = newNode; // 让新结点指向自己 head-&gt;next = newNode; // 让头结点指向新结点 head-&gt;length++; return OK; &#125; /** 链表不为空 */ /** 2. 插入位置为首元结点 */ if(pos == 1)&#123; // 先把新结点做插入操作 newNode-&gt;next = head-&gt;next; head-&gt;next = newNode; head-&gt;length++; // 找到尾结点 Node *last = head-&gt;next; for(int i = 0; i &lt; head-&gt;length; i++) last = last-&gt;next; // 让尾指针指向新结点 last-&gt;next = newNode;44return OK; &#125; /** 3. 插入位置为尾元结点 */ if(pos == head-&gt;length)&#123; // 找到尾结点 Node *last = head-&gt;next; for(int i = 0; i &lt; head-&gt;length; i++) last = last-&gt;next; // 让新结点指向头结点，让尾结点指向新结点 newNode-&gt;next = head-&gt;next; last-&gt;next = newNode; head-&gt;length++; return OK; &#125; /** 4. 插入位置为中间结点*/ if(pos != head-&gt;length)&#123; // 找到目标位置的前一个 Node *p = head-&gt;next; for(int i = 1; p &amp;&amp; i &lt; pos - 1; i++) p = p-&gt;next; // 做普通插入操作 newNode-&gt;next = p-&gt;next; p-&gt;next = newNode; head-&gt;length++; return OK; &#125; &#125; 当链表为空时，插入新结点只需要让新结点指向自己，然后让头结点指向新结点即可 当链表不为空 插入位置为首元结点时，先做一个普通的插入操作，然后找到尾结点让尾指针指向新结点即可 插入位置为尾元结点时，找到尾元结点，让新结点指向头结点，让尾指针指向新结点即可 插入位置为中间结点时，找到目标位置前一个结点，做一个普通插入操作即可 循环链表删除操作1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859Status DeteleCLinkList(HeadNode* head, int pos)&#123; // 判断位置是否正确，或是否为空链表 if (isEmptyC(head) || pos &gt; head-&gt;length) return ERROR; // 如果是删除首元结点 if (pos == 1) &#123; Node* first = head-&gt;next; head-&gt;next = first-&gt;next; Node* last = GetLast(head); last-&gt;next-&gt;next = head-&gt;next; head-&gt;length--; free(first); return OK; &#125; // 如果是删除尾元结点 if (pos == head-&gt;length) &#123; Node* last = GetLast(head); last-&gt;next = head-&gt;next; head-&gt;length--; free(last); return OK; &#125; // 1、找到目标结点 Node* current = head-&gt;next; for (int i = 1; i &lt; pos - 1; i++) &#123; current = current-&gt;next; &#125; // 2、进行删除操作 Node* q = current-&gt;next; current-&gt;next = q-&gt;next; head-&gt;length--; free(q); return OK;&#125;/** 返回尾结点的前驱结点 */Node* GetLast(HeadNode* head)&#123; if (!head-&gt;length) &#123; printf(&quot;链表为空！&quot;); &#125; if (head-&gt;length == 1) &#123; return head-&gt;next; &#125; Node* last = head-&gt;next; for (int i = 0; i &lt; head-&gt;length - 1; i++) &#123; last = last-&gt;next; &#125; return last;&#125;","categories":[{"name":"DataStruction","slug":"DataStruction","permalink":"https://www.boii.xyz/categories/DataStruction/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"https://www.boii.xyz/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"DataStruction","slug":"DataStruction","permalink":"https://www.boii.xyz/tags/DataStruction/"}]},{"title":"DataStruction 0x01 算法","slug":"DataStruction [1-算法]","date":"2021-02-23T08:00:36.000Z","updated":"2021-05-27T16:37:47.397Z","comments":true,"path":"2021/02/23/DataStruction [1-算法]/","link":"","permalink":"https://www.boii.xyz/2021/02/23/DataStruction%20[1-%E7%AE%97%E6%B3%95]/","excerpt":"什么是算法？","text":"什么是算法？ 1-算法算法：是解决特定问题求解步骤的描述；在计算机中表现为指令的有限序列，并且每条指令表示一个或多个操作。 算法特性： 输入：算法具有0或n个输入； 输出：算法至少有1或n个输出； 有穷性：算法在执行有限的步骤之后，自动结束而不会出现无限循环，并且每一步骤在可接受的时间内完成； 确定性：算法的每一步骤都具有确定的含义，不会出现二义性； 可行性：算法的每一步骤都能够通过执行有限次数完成。 算法设计的要求： 正确性：指算法至少应该具有输入、输出和加工处理无歧义性、能正确反映问题的需求、能得到问题的正确答案； 可读性：算法设计的另一目的是为了便于阅读、理解和交流； 健壮性：当输入不合法数据时，算法也能做出相关处理，而不是产生异常； 高效性：算法设计应该尽量满足时间效率高和存储量低的需求。 算法效率的度量方法一个程序的运行时间，依赖于算法的好坏和问题的输入规模（输入规模：输入量的多少）。 测定运算时间最可靠的方法就是计算对运行时间有消耗的基本操作的执行次数。在分析程序运行时间时，最重要的是把程序看成是独立于程序设计语言的算法或一系列步骤。 当输入规模变大以后，常数项、非最高阶项的影响微乎其微，所以判断一个算法的效率时，函数中的参数和其他次要项常常可以忽略，应该更关注主项（最高阶项）的阶数。 算法时间复杂度 在进行算法分析时，语句总的执行次数 $T(n)$ 是关于问题规模 $n$的函数，进而分析 $T(n)$ 随 $n$ 的变化情况并确定 $T(n)$ 的数量级。算法的时间复杂度，记作：$T(n) = O(f(n))$。表示随着问题规模 $n$ 的增大，算法执行时间的增长率和 $f(n)$ 的增长率相同。 算法时间复杂度常用大O表示法$O(1)$常数阶、$O(n)$线性阶、$O(n^2)$平方阶 大O阶的推导步骤为： 用常数1取代运行时间中所有的常数 只保留最高阶 除了$O(1)$，去除最高阶的系数 时间复杂度排序：$O(1) &lt; O(logn) &lt; O(n) &lt; O(nlogn) &lt; O(n^2) &lt; O(n^3) &lt; O(2^n) &lt; O(n!) &lt; O(n^n)$","categories":[{"name":"DataStruction","slug":"DataStruction","permalink":"https://www.boii.xyz/categories/DataStruction/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"https://www.boii.xyz/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"DataStruction","slug":"DataStruction","permalink":"https://www.boii.xyz/tags/DataStruction/"}]},{"title":"DataStruction 0x00 绪论","slug":"DataStruction [0-绪论]","date":"2021-02-23T08:00:35.000Z","updated":"2021-05-27T16:33:59.019Z","comments":true,"path":"2021/02/23/DataStruction [0-绪论]/","link":"","permalink":"https://www.boii.xyz/2021/02/23/DataStruction%20[0-%E7%BB%AA%E8%AE%BA]/","excerpt":"什么是数据结构？","text":"什么是数据结构？ 绪论声明：本系列文章系个人总结所写，执笔上偏于新手向，会有诸多用词不严谨之处，只为了方便理解。欢迎指正，拒绝指责。 正文： 程序 是一系列指令的集合。程序设计 = 数据结构 + 算法 数据，由 N 个 0 和 1 组成，本质上是一串二进制代码，利于计算机计算，但不利于人类阅读思考。所以在此之上经过层层抽象，将计算机中的数据抽象出诸如 对象、实例、结点、数据对象 等概念。 数据结构，就是以 对象、实例、结点、数据对象 为单位，研究各个单位之间的关系。由此明确，在数据结构中需要研究两个东西： 单位、关系 单位数据的单位在数据结构中通常称为 数据对象，数据对象可以是一个人、一辆车、一个数字、一个字符、或者多种数据的组合。 例如一个人，会有多种数据：名字（name）、年龄（age）、学号（ID），在代码中表现为结构体变量或对象。 而名字、年龄、学号这些，我们称为 数据项。 即N个数据项构成了数据对象 每个人都有学号、姓名、年龄，例如张三李四王五，但张三不是李四、王五不是赵六，他们都是各自独立的。 但他们都是人类，所以我们把人类称为 数据元素，在代码中表现为结构体定义或类定义。 关系说完单位，剩下就是关系了。 这些单位之间的关系，理论上有很多种：线性表、广义表、链表、栈、队、树、图；这种我们称为 逻辑结构。 而在代码、或者说物理上的实现，只有两种：顺序存储结构、链式存储结构；这些我们称为 物理结构。 逻辑结构逻辑上的各种关系可以分为 4 大类： 集合结构：各个单位之间，除了同属一个集合，没有别的关系；各个单位是“平等”的。 线性结构：各个单位之间是一对一的关系 树形结构：各个单位之间是一对多的关系 图形结构：各个单位之间是多对多的关系 集合结构比较少见，这里暂时不做讨论。我们主要讨论常见的线性、树形、图形结构。 物理结构程序是运行在内存中的，而内存是顺序排列的，没那么多花里胡哨的，而且受计算机物理实现所束缚，物理结构中： 要么是一个挨着一个的顺序存储结构，要么是单位（数据对象）之间并不一定挨着的链式存储结构。 两种结构都有各自的特点。 顺序存储结构 特点：数据对象之间在物理上一个挨着一个、有序，只要知道了第一个数据对象的地址，可以很快找到后面其他的数据对象。与此同时，为了保持这种一个挨着一个和有序的特点，当插入或者删除某一个数据对象时，后面的数据对象要一个一个往后挪腾出中间的位置，或者一个一个往前挪填补中间的空缺，导致插入和删除很慢。 优点：查找速度快。 缺点：插入和删除慢。 链式存储结构 特点：数据对象之间在物理上并不一定相互挨着、无序，要查找某一个数据对象时需要从第一个数据对象开始，一个接着一个往后一路查下去才能找到。与此同时，因为物理上不一定相互挨着，所以插入和删除时只需要修改前后的链条即可。 优点：插入和删除快。 缺点：查找速度慢。 这里的快慢，指的是计算机需要执行多次计算称为慢，计算机需要执行少量计算称为快。 ADT 抽象数据类型抽象数据类型是用来表示某一种逻辑结构（栈、队、树、...）的具体信息，具有什么样的操作 等等。 描述 ADT 的标准格式： 1234567891011121314ADT 抽象数据类型名Data 数据元素之间逻辑关系的定义Operation 操作1 初始条件 操作结果描述 操作2 ... ... 操作n ... ...endAD 总结","categories":[{"name":"DataStruction","slug":"DataStruction","permalink":"https://www.boii.xyz/categories/DataStruction/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"https://www.boii.xyz/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"DataStruction","slug":"DataStruction","permalink":"https://www.boii.xyz/tags/DataStruction/"}]},{"title":"Hexo-文件下载功能","slug":"Hexo-文件下载功能","date":"2020-08-23T08:00:35.000Z","updated":"2021-05-22T13:37:47.740Z","comments":true,"path":"2020/08/23/Hexo-文件下载功能/","link":"","permalink":"https://www.boii.xyz/2020/08/23/Hexo-%E6%96%87%E4%BB%B6%E4%B8%8B%E8%BD%BD%E5%8A%9F%E8%83%BD/","excerpt":"So easy~","text":"So easy~ 操作方法效果：点击下载 在source目录下，新建download目录，和_posts、About、tags、categories等目录并列 将你需要分享的文件或者需要展示的图片之类，统一放到该download下 在写文章时，通过诸如 [点击下载](/download/xx.exe) 这样的链接，直接写入。其他，照旧 在 volantis主题下，可以这样写 &#123;% btn 点击下载, /download/xx.exe, fas fa-download %&#125; 注意： 全半角不要搞错。 必须是压缩文件（.exe | .zip | .rar | 7z |…），否则跳过去直接给你展示了不会触发下载的。","categories":[{"name":"HEXO","slug":"HEXO","permalink":"https://www.boii.xyz/categories/HEXO/"},{"name":"Note","slug":"Note","permalink":"https://www.boii.xyz/categories/Note/"},{"name":"Git","slug":"Git","permalink":"https://www.boii.xyz/categories/Git/"}],"tags":[{"name":"HEXO","slug":"HEXO","permalink":"https://www.boii.xyz/tags/HEXO/"},{"name":"note","slug":"note","permalink":"https://www.boii.xyz/tags/note/"},{"name":"git","slug":"git","permalink":"https://www.boii.xyz/tags/git/"}]},{"title":"Python【Crawler】通用爬虫","slug":"Python【Crawler】1-通用爬虫","date":"2020-08-20T06:17:48.000Z","updated":"2021-05-22T13:37:47.723Z","comments":true,"path":"2020/08/20/Python【Crawler】1-通用爬虫/","link":"","permalink":"https://www.boii.xyz/2020/08/20/Python%E3%80%90Crawler%E3%80%911-%E9%80%9A%E7%94%A8%E7%88%AC%E8%99%AB/","excerpt":"爬虫的基本用法","text":"爬虫的基本用法 Python 中原生的一款基于网络请求的模块，功能强大，简单便捷，效率极高。 &gt;_: pip install requests 基本使用 指定URL UA伪装 发起请求 —— requests.get() 或 requests.post() 获取响应数据 —— .json()或.text 持久化存储 —— f.write() 或 json.dump() 12345678910111213141516171819import requestsdef main(): # 1. 指定url url = &quot;https://www.sou.com&quot; # 2. UA伪装 header = &#123;&quot;User-Agent&quot;: &quot;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/84.0.4147.89 Safari/537.36 Edg/84.0.522.44&quot;&#125; # 3. 发起请求 response = requests.get(url=url, headers=header) # 4. 获取响应数据 page_text = response.text # 5. 持久化存储 with open(&quot;sogou.html&quot;, &quot;w&quot;, &quot;utf-8&quot;) as f: f.wirte(page_text) print(&quot;END&quot;)if __naim__ == &#x27;__main__&#x27;: main() 这种就是最基本的模拟浏览器进行爬取。通过requests就可以进行网络请求，从返回对象中得到数据。 url的获取方式主要通过自己查找分析如果只是普通的浏览网页，一般使用的是get方式如果携带参数，需要观察url中 ？ 后面的字段。 携带参数http协议中的请求方式分为get、post、put、patch、head、delete。最常用的请求为 get() 和 post()，这两种请求方式都可以携带参数。在浏览器中分析的时候可以观察 ? 后面的字段，有的是query，有的是q，可以通过浏览器中抓包工具进行分析 由此就可以确定 ? 前面是我们要的url： https://www.sogou.com/web?；url中的问号?可写可不写 接着可以确定查询字段是query，用个字典包装起来：param = &#123;&#39;query&#39;: &#39;python&#39;&#125; 同时在请求url下面可以看到请求方式是get，所以可以使用get方法进行请求：res = requests.get(url, param, headers=header) 观察响应标头的Content-Type发现，返回格式为text，则调用res.text获得返回内容：res_text = res.text 将返回的内容存储起来。搞定。 完整代码 1234567891011121314151617181920212223242526import requestsheader = &#123;&#x27;User-Agent&#x27;: &quot;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/84.0.4147.89 Safari/537.36 Edg/84.0.522.44&quot;&#125;def main(): # 1. 指定url url = &quot;https://www.sogou.com/web?&quot; # 2. 获取查询内容 q = input(&#x27;Enter the contend you want to search: &#x27;) # 3. 设置好传输参数 param = &#123;&#x27;query&#x27;: q&#125; # 4. 发送请求 res = requests.get(url=url, params=param, headers=header) # 5. 获取返回内容 res_text = res.text # 6. 写入文件 with open(&#x27;./sogou.html&#x27;, &#x27;w&#x27;, encoding=&#x27;utf-8&#x27;) as f: f.write(res_text)if __name__ == &#x27;__main__&#x27;: main()--------------------------------------------------# Output:Enter the contend you want to search: Python 1234567891011121314151617181920212223# sogou.html&lt;!DOCTYPE html&gt;&lt;html data-vtype=&quot;default&quot;&gt;&lt;head&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=Edge&quot;&gt; &lt;meta http-equiv=&quot;x-dns-prefetch-control&quot; content=&quot;on&quot;&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;meta name=&quot;referrer&quot; content=&quot;always&quot;&gt;...... &lt;/script&gt;&lt;!-- BottomViewEnd opt --&gt; &lt;script crossorigin=&quot;anonymous&quot; src=&quot;//dlweb.sogoucdn.com/hhytrace/trace_2020072915.js&quot; async&gt;&lt;/script&gt;&lt;/body&gt;&lt;!-- bodyViewEnd --&gt;&lt;/html&gt;&lt;!-- 1596006531756 --&gt;&lt;!--STATUS total 14 time 1596006531756 page 0 maxEnd 1000 totalItems 8955--&gt;&lt;!--real_pageno:1--&gt;&lt;!--nodeserverinfo:rsync.doc04.web.1.gd.ted--&gt;&lt;!--searchhubserverinfo:doc09.web.1.gd.ted:5555--&gt;&lt;!--zly--&gt; requests模块中的get()、post()、put()等请求方法其实都是调用了request()方法。 request(method, url, **kwargs)get(url, params=None, **kwargs)post(url, data=None, json=None, **kwargs) 这里注意区分，get的参数是params，post的参数的data 抓取动态内容网页中有些数据不是静态的，而是动态获取，通过Ajax局部刷新。例如百度翻译 红框中的内容会根据输入框中内容的变化而变化，这就是动态获取当内容改变的时候，返回来的结果只会改变页面中红框的部分，这就是局部刷新 这种数据直接抓取页面是无效的，所以我们要通过浏览器抓包工具进行观察 可以把筛选器设置到 XHR ，这样可以只查看刷新时返回的数据 通过观察可以发现每输入一个字符就会发送一个sug，所以请求url应该是https://fanyi.baidu.com/sug才对 请求方式是post，携带参数是kw，所以参数部分应该这样写：data = &#123;kw: &#39;document&#39;&#125; 接着看到 Content-Type，返回数据格式是 json，那么就需要用 json 模块来处理。res_json = res.json() 最后可以使用 json.dump()将json格式直接写入数据，或者使用json.loads()转换成python对象，再用f.write()写入文件。 1234567891011121314151617181920import requestsheader = &#123;&#x27;User-Agent&#x27;: &quot;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/84.0.4147.89 Safari/537.36 Edg/84.0.522.44&quot;&#125;def main(): # 1. 指定url url = &#x27;https://fanyi.baidu.com/sug&#x27; # 2. 获取查询内容，设置好请求参数 query = input(&quot;Enter the word you want to translate: &quot;) data = &#123;&#x27;kw&#x27;: query&#125; # 3. 发送请求 res = requests.post(url=url, data=data, headers=header) # 4. 获取返回内容 res_json = res.json() # 5. 写入文件 with open(&#x27;./translation.json&#x27;, &#x27;w&#x27;, encoding=&#x27;utf-8&#x27;) as f: json.dump(res_json, fp, ensure_ascii=False)if __name__ == &#x27;__main__&#x27;: main()","categories":[{"name":"Python","slug":"Python","permalink":"https://www.boii.xyz/categories/Python/"},{"name":"爬虫","slug":"Python/爬虫","permalink":"https://www.boii.xyz/categories/Python/%E7%88%AC%E8%99%AB/"},{"name":"基础","slug":"Python/爬虫/基础","permalink":"https://www.boii.xyz/categories/Python/%E7%88%AC%E8%99%AB/%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"Python","slug":"Python","permalink":"https://www.boii.xyz/tags/Python/"},{"name":"爬虫","slug":"爬虫","permalink":"https://www.boii.xyz/tags/%E7%88%AC%E8%99%AB/"}]},{"title":"Python【Crawler】聚焦爬虫","slug":"Python【Crawler】2-聚焦爬虫","date":"2020-08-20T06:17:48.000Z","updated":"2021-05-22T13:37:47.740Z","comments":true,"path":"2020/08/20/Python【Crawler】2-聚焦爬虫/","link":"","permalink":"https://www.boii.xyz/2020/08/20/Python%E3%80%90Crawler%E3%80%912-%E8%81%9A%E7%84%A6%E7%88%AC%E8%99%AB/","excerpt":"过滤爬取到的数据，取出想要的部分","text":"过滤爬取到的数据，取出想要的部分 聚焦爬虫：爬取页面中指定的页面内容 编码流程 指定url 发起请求 获取响应数据 数据解析 持久化存储 数据解析分类 正则表达式 bs4 xpath (*) 数据解析原理 - 解析的局部文本内容都会在标签之间或标签的属性中存储 - 1. 进行标签的定位 - 2. 标签或者标签对应的属性中存储的数据值进行提取（即解析~~~~） 正则表达式爬取12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970import osimport requestsimport re# UA伪装UA = &#x27;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/84.0.4147.89 Safari/537.36 Edg/84.0.522.44&#x27;header = &#123;&#x27;User-Agent&#x27;: UA&#125;# 存储目录folder = &#x27;./qiushi&#x27;if not os.path.exists(folder): os.mkdir(folder)def main(): # 分页处理 for i in range(1, 3): url = f&quot;https://www.qiushibaike.com/imgrank/page/&#123;i&#125;/&quot; # 1. 爬取整张页面 page_text = requests.get(url=url, headers=header).text # 2. 使用聚焦爬虫进行数据解析 images = data_parse(page_text) length = len(images) # 进度条所需 for index, image in enumerate(images): # 3. 发起请求并获得数据 image_content = requests.get(url=image, headers=header).content # 4. 持久化存储 image_name = image.split(&#x27;/&#x27;)[-1] image_path = os.path.join(folder, image_name) with open(image_path, &#x27;wb&#x27;) as f: f.write(image_content) # 进度打印 print(image_name + &#x27; 下载成功！&#x27;) print(f&#x27;&#123;index&#125; / &#123;length&#125;&#x27;, end=&#x27;\\r&#x27;) print(str(i) + &quot;/ 2 page&quot;)def data_parse(page_text): &quot;&quot;&quot; 解析出每张图片的url &quot;&quot;&quot; # 分析网页后整理出正则表达式 ex = r&#x27;&lt;div class=&quot;thumb&quot;&gt;.*?&lt;img src=&quot;(.*?)&quot; alt.*?&gt;&lt;/div&gt;&#x27; images = re.findall(ex, page_text, re.S) images = [&#x27;https:&#x27; + x for x in images] # 解析出来没有协议头，给增加上 return imagesif __name__ == &quot;__main__&quot;: main()--------------------------------------------------# Output:K7EUFEUIV3QY37P1.jpg 下载成功！DFIAAL32X5J35JP2.jpg 下载成功！...NXUA4X1CMQP22UPP.jpg 下载成功！FQILIKXCVMUIRXL8.jpg 下载成功！1/ 2 page95GRCYEUZANQ361J.jpg 下载成功！2SXBFKSSK3JD3G2M.jpg 下载成功！...5YTNS4JH0PLZAO58.jpg 下载成功！59CN77YAL198SM6M.jpg 下载成功！2/ 2 page 示例网页123456789101112131415161718192021222324252627282930313233343536373839&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;测试bs4&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;div&gt; &lt;p&gt;百里守约&lt;/p&gt; &lt;/div&gt; &lt;div class=&quot;song&quot;&gt; &lt;p&gt;李清照&lt;/p&gt; &lt;p&gt;王安石&lt;/p&gt; &lt;p&gt;苏轼&lt;/p&gt; &lt;p&gt;柳宗元&lt;/p&gt; &lt;a href=&quot;https://www.song.com&quot; title=&quot;赵匡胤&quot; target=&quot;_self&quot;&gt; &lt;span&gt;this is span&lt;/span&gt; 宋朝是最强大的王朝，不是军队的强大，而是经济很强大，国民都很有钱 &lt;/a&gt; &lt;a href=&quot;&quot; class=&quot;du&quot;&gt;总为浮云能避日，长安不见使人愁&lt;/a&gt; &lt;img src=&quot;https://www.baidu.com/meinv.jpg&quot; alt=&quot;&quot;&gt; &lt;/div&gt; &lt;div class=&quot;tang&quot;&gt; &lt;ul&gt; &lt;li&gt;&lt;a href=&quot;https://www.baidu.com&quot; title=&quot;qing&quot;&gt;清明时节雨纷纷，路上行人欲断魂。借问酒家何处有，牧童遥指杏花村。&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;https://www.163.com&quot; title=&quot;qin&quot;&gt;秦时明月汉时光，万里长征人未还。但使龙城飞将在，不教胡马度阴山。&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;https://www.126.com&quot; alt=&quot;qi&quot;&gt;岐王宅里寻常见，崔久堂前几度闻。正是江南好风景，落花时节又逢君。&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;https://www.sina.com&quot; class=&quot;du&quot;&gt;杜甫&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;https://www.dudu.com&quot; class=&quot;du&quot;&gt;杜牧&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;b&gt;杜小月&lt;/b&gt;&lt;/li&gt; &lt;li&gt;&lt;i&gt;度蜜月&lt;/i&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;https://www.haha.com&quot; id=&quot;feng&quot;&gt;凤凰台上凤凰游，凤去台空江自流。吴宫花草埋幽径，晋代衣冠成古丘。&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 以下爬虫示例均以此网页示例为基础有点丑，将就一下。 bs4爬取安装win 下：&gt;_ pip install bs4&gt;_ pip install lxml Linux 下：&gt;_ pip install Beautifulsoup4 导入 from bs4 import BeautifulSoup 使用 创建bs对象并传入待解析对象 传入待解析对象为本地文件 1234from bs4 import BeautifulSoupwith open(&#x27;./bs_test.html&#x27;, &#x27;r&#x27;, encoding=&#x27;utf-8&#x27;) as f: bs = BeautifulSoup(f, &#x27;lxml&#x27;) # 创建bs对象 传入待解析对象为网络请求 123456from bs4 import BeautifulSoupimport requestsurl = &quot;https://www.baidu.com&quot;page_text = requests.get(url=url).textbs = BeautifulSoup(page_text, &#x27;lxml&#x27;) # 创建bs对象 定位数据 方法 用 返值 tagName 返回首tagName标签 bs4.element.Tag find(‘tagName’) 返回首tagName标签 bs4.element.Tag find(‘tagName’, class_/id/attrName=’value’) 返回首属性为value的tagName标签 bs4.element.Tag find_all(‘tagName’) 返回所符合要求的标签 bs4.element.ResultSet select([‘selector’ + ]’tagName’) 通过CS选择器+标签名定位标签,返回多个 bs4.element.ResultSet select_one([‘selector’ + ]’tagName’) 通过CS选择器+标签名定位标签,返回一个 bs4.element.Tag bs.tagName bs.tagName：返回文档中第一次出现tagName对应的标签 1234567891011121314with open(&#x27;./bs_test.html&#x27;, &#x27;r&#x27;, encoding=&#x27;utf-8&#x27;) as f: bs = BeautifulSoup(f, &#x27;lxml&#x27;) # 创建bs对象 tag_a = bs.a # 定位数据 print(tag_a) print(type(tag_a)) # &lt;class &#x27;bs4.element.Tag&#x27;&gt;--------------------------------------------------# Output:&lt;a href=&quot;https://www.song.com&quot; target=&quot;_self&quot; title=&quot;赵匡胤&quot;&gt;&lt;span&gt;this is span&lt;/span&gt; 宋朝是最强大的王朝，不是军队的强大，而是经济很强大，国民都很有钱&lt;/a&gt;&lt;class &#x27;bs4.element.Tag&#x27;&gt; bs.find() bs.find()： find(&#39;tagName&#39;)：等同于 bs.tagName 12345678910111213with open(&#x27;./bs_test.html&#x27;, &#x27;r&#x27;, encoding=&#x27;utf-8&#x27;) as f: bs = BeautifulSoup(f, &#x27;lxml&#x27;) # 创建bs对象 tag_div = bs.find(&#x27;div&#x27;) # 定位数据 print(tag_div) print(type(tag_div)) # &lt;class &#x27;bs4.element.Tag&#x27;&gt;--------------------------------------------------# Output:&lt;div&gt;&lt;p&gt;百里守约&lt;/p&gt;&lt;/div&gt;&lt;class &#x27;bs4.element.Tag&#x27;&gt; find(&#39;tagName&#39;, class_/is/attrName=&#39;value&#39;)：通过限定属性来定位标签 1234567891011with open(&#x27;./bs_test.html&#x27;, &#x27;r&#x27;, encoding=&#x27;utf-8&#x27;) as f: bs = BeautifulSoup(f, &#x27;lxml&#x27;) # 创建bs对象 tag_a = bs.find(&#x27;a&#x27;, class_=&#x27;du&#x27;) # 定位数据 print(tag_a) print(type(tag_a)) # &lt;class &#x27;bs4.element.Tag&#x27;&gt;--------------------------------------------------# Output:&lt;a class=&quot;du&quot; href=&quot;&quot;&gt;总为浮云能避日，长安不见使人愁&lt;/a&gt;&lt;class &#x27;bs4.element.Tag&#x27;&gt; bs.find_all(&#39;tagName&#39;)：返回复合要求的所有标签（集合） 12345678910with open(&#x27;./bs_test.html&#x27;, &#x27;r&#x27;, encoding=&#x27;utf-8&#x27;) as f: bs = BeautifulSoup(f, &#x27;lxml&#x27;) # 创建bs对象 tag_p = bs.find_all(&#x27;p&#x27;) # 定位数据 print(tag_p) print(type(tag_p)) # &lt;class &#x27;bs4.element.ResultSet&#x27;&gt;--------------------------------------------------# Output:[&lt;p&gt;百里守约&lt;/p&gt;, &lt;p&gt;李清照&lt;/p&gt;, &lt;p&gt;王安石&lt;/p&gt;, &lt;p&gt;苏轼&lt;/p&gt;, &lt;p&gt;柳宗元&lt;/p&gt;] bs.select() bs.select(&#39;selector&#39; + &#39;tagName&#39;)：可以通过CSS择器+标签名定位，包括层级选择器、标签选择器等 1234567891011with open(&#x27;./bs_test.html&#x27;, &#x27;r&#x27;, encoding=&#x27;utf-8&#x27;) as f: bs = BeautifulSoup(f, &#x27;lxml&#x27;) # 创建bs对象 tag_div = bs.select(&#x27;#feng&#x27;) # 定位数据 print(tag_div) print(type(tag_div)) # &lt;class &#x27;bs4.element.ResultSet&#x27;&gt;--------------------------------------------------# Output:[&lt;a href=&quot;https://www.haha.com&quot; id=&quot;feng&quot;&gt;凤凰台上凤凰游，凤去台空江自流。吴宫花草埋幽径，晋代衣冠成古丘。&lt;/a&gt;]&lt;class &#x27;bs4.element.ResultSet&#x27;&gt; 123456789101112131415with open(&#x27;./bs_test.html&#x27;, &#x27;r&#x27;, encoding=&#x27;utf-8&#x27;) as f: bs = BeautifulSoup(f, &#x27;lxml&#x27;) # 创建bs对象 tag1_a = bs.select(&#x27;.tang &gt; ul &gt; li &gt; a&#x27;) # 定位数据 tag2_a = bs.select(&#x27;.tang &gt;ul a&#x27;) # 定位数据 print(tag1_a) print(tag2_a) print(type(tag1_a)) # &lt;class &#x27;bs4.element.ResultSet&#x27;&gt;--------------------------------------------------# Output:[&lt;a href=&quot;https://www.baidu.com&quot; title=&quot;qing&quot;&gt;清明时节雨纷纷，路上行人欲断魂。借问酒家何处有，牧童遥指杏花村。&lt;/a&gt;, &lt;a href=&quot;https://www.163.com&quot; title=&quot;qin&quot;&gt;秦时明月汉时光，万里长征人未还。但使龙城飞将在，不教胡马度阴山。&lt;/a&gt;, &lt;a alt=&quot;qi&quot; href=&quot;https://www.126.com&quot;&gt;岐王宅里寻常见，崔久堂前几度闻。正是江南好风景，落花时节又逢君。&lt;/a&gt;, &lt;a class=&quot;du&quot; href=&quot;https://www.sina.com&quot;&gt;杜甫&lt;/a&gt;, &lt;a class=&quot;du&quot; href=&quot;https://www.dudu.com&quot;&gt;杜牧&lt;/a&gt;, &lt;a href=&quot;https://www.haha.com&quot; id=&quot;feng&quot;&gt;凤凰台上凤凰游，凤去台空江自流。吴宫花草埋幽径，晋代衣冠成古丘。&lt;/a&gt;][&lt;a href=&quot;https://www.baidu.com&quot; title=&quot;qing&quot;&gt;清明时节雨纷纷，路上行人欲断魂。借问酒家何处有，牧童遥指杏花村。&lt;/a&gt;, &lt;a href=&quot;https://www.163.com&quot; title=&quot;qin&quot;&gt;秦时明月汉时光，万里长征人未还。但使龙城飞将在，不教胡马度阴山。&lt;/a&gt;, &lt;a alt=&quot;qi&quot; href=&quot;https://www.126.com&quot;&gt;岐王宅里寻常见，崔久堂前几度闻。正是江南好风景，落花时节又逢君。&lt;/a&gt;, &lt;a class=&quot;du&quot; href=&quot;https://www.sina.com&quot;&gt;杜甫&lt;/a&gt;, &lt;a class=&quot;du&quot; href=&quot;https://www.dudu.com&quot;&gt;杜牧&lt;/a&gt;, &lt;a href=&quot;https://www.haha.com&quot; id=&quot;feng&quot;&gt;凤凰台上凤凰游，凤去台空江自流。吴宫花草埋幽径，晋代衣冠成古丘。&lt;/a&gt;]&lt;class &#x27;bs4.element.ResultSet&#x27;&gt; 123456789101112 with open(&#x27;./bs_test.html&#x27;, &#x27;r&#x27;, encoding=&#x27;utf-8&#x27;) as f: bs = BeautifulSoup(f, &#x27;lxml&#x27;) # 创建bs对象 tag_div = bs.select_one(&#x27;.du&#x27;) # 定位数据 print(tag_div) print(type(tag_div)) # &lt;class &#x27;bs4.element.Tag&#x27;&gt; --------------------------------------------------# Output:&lt;a class=&quot;du&quot; href=&quot;&quot;&gt;总为浮云能避日，长安不见使人愁&lt;/a&gt;&lt;class &#x27;bs4.element.Tag&#x27;&gt; 解析数据 方法 用 返值 .text 返回标签下所有直系和非直系标签的所有本 str .get_text() 返回标签下所有直系和非直系标签的所有本 str .string 返回标签下所有直系标签的所有本 bs4.element.NavigableString 获取文本 bs.tagName.text/string/get_text()：获取标签之间的所有文本* text/get_text()：可以获取标签下直系和非直系的所有文本 123456789101112with open(&#x27;./bs_test.html&#x27;, &#x27;r&#x27;, encoding=&#x27;utf-8&#x27;) as f: bs = BeautifulSoup(f, &#x27;lxml&#x27;) # 创建bs对象 txt_li = bs.find(&#x27;li&#x27;).text print(txt_li) print(type(txt_li)) # &lt;class &#x27;str&#x27;&gt; --------------------------------------------------# Output:清明时节雨纷纷，路上行人欲断魂。借问酒家何处有，牧童遥指杏花村。&lt;class &#x27;str&#x27;&gt; 123456789101112with open(&#x27;./bs_test.html&#x27;, &#x27;r&#x27;, encoding=&#x27;utf-8&#x27;) as f: bs = BeautifulSoup(f, &#x27;lxml&#x27;) # 创建bs对象 txt_li = bs.find(&#x27;li&#x27;).get_text() print(txt_li) print(type(txt_li)) # &lt;class &#x27;str&#x27;&gt; --------------------------------------------------# Output:清明时节雨纷纷，路上行人欲断魂。借问酒家何处有，牧童遥指杏花村。&lt;class &#x27;str&#x27;&gt; string：只能获取标签下直系的文本，没有返回 None 123456789101112with open(&#x27;./bs_test.html&#x27;, &#x27;r&#x27;, encoding=&#x27;utf-8&#x27;) as f: bs = BeautifulSoup(f, &#x27;lxml&#x27;) # 创建bs对象 txt_li = bs.find(&#x27;li&#x27;).string print(txt_li) print(type(txt_li)) # &lt;class &#x27;bs4.element.NavigableString&#x27;&gt; --------------------------------------------------# Output:清明时节雨纷纷，路上行人欲断魂。借问酒家何处有，牧童遥指杏花村。&lt;class &#x27;bs4.element.NavigableString&#x27;&gt; 获取属性 bs.tagName[&#39;attrName&#39;]：获取标签中的属性内容123456789101112with open(&#x27;./bs_test.html&#x27;, &#x27;r&#x27;, encoding=&#x27;utf-8&#x27;) as f: bs = BeautifulSoup(f, &#x27;lxml&#x27;) # 创建bs对象 txt_href = bs.find(&#x27;a&#x27;)[&#x27;href&#x27;] print(txt_href) print(type(txt_href)) # &lt;class &#x27;str&#x27;&gt; --------------------------------------------------# Output:https://www.song.com&lt;class &#x27;str&#x27;&gt; 案例 从诗词名句网下载一整部《论语》 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576import timeimport requestsimport osfrom bs4 import BeautifulSoupUA = &#x27;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/84.0.4147.89 Safari/537.36 Edg/84.0.522.44&#x27;header = &#123;&#x27;User-Agent&#x27;: UA&#125;folder = &#x27;.\\\\爬虫\\\\论语&#x27;if not os.path.exists(folder): os.mkdir(folder)def req_catalog(url): &quot;&quot;&quot; 请求目录列表 &quot;&quot;&quot; return requests.get(url=url, headers=header).textdef catalog_parse(res_text): &quot;&quot;&quot; 解析目录列表 &quot;&quot;&quot; bs = BeautifulSoup(res_text, &#x27;lxml&#x27;) links = bs.select(&#x27;.book-mulu &gt; ul &gt; li &gt; a&#x27;) catalog_list = [[x.string, x[&#x27;href&#x27;]] for x in links] return catalog_listdef download_content(catalog_list): &quot;&quot;&quot; 请求内容页 &quot;&quot;&quot; url = &#x27;https://www.shicimingju.com&#x27; length = len(catalog_list) for index, elem in enumerate(catalog_list): # 请求数据 content_text = requests.get(url=url + elem[1], headers=header).text # 解析数据 content = contents_parse(content_text) # 持久化存储 filename = str(index + 1) + &#x27;-&#x27; + elem[0] + &#x27;.txt&#x27; filepath = os.path.join(folder, filename) with open(filepath, &#x27;w&#x27;, encoding=&#x27;utf-8&#x27;) as f: f.write(content) print(&quot;已下载：&quot; + str(index + 1) + &quot; / &quot; + str(length), end=&quot;\\r&quot;) return 1def contents_parse(page_text): &quot;&quot;&quot; 解析内容 &quot;&quot;&quot; bs = BeautifulSoup(page_text, &#x27;lxml&#x27;) contents = bs.select(&#x27;.chapter_content &gt; p&#x27;) # 取出所有p标签 texts = [x.string for x in contents] # 取出内容，过滤掉P标签 content = &#x27;&#x27; for i in texts: content += str(i) return contentdef main(): url = &quot;https://www.shicimingju.com/book/lunyu.html&quot; catalog_list = list() try: catalog_text = req_catalog(url) catalog_list = catalog_parse(catalog_text) print(&quot;下载成功！&quot;) if download_content(catalog_list) else print(&quot;下载失败&quot;) except TimeoutError: print(&quot;TimeoutError\\n&quot;) time.sleep(2) print(&quot;下载成功！&quot;) if download_content(catalog_list) else print(&quot;下载失败&quot;) except Exception: print(&quot;Exception\\n&quot;)if __name__ == &#x27;__main__&#x27;: main() xpath爬取最常用、通用性最强的，最便捷高效的一种解析方式。 解析步骤 实例化一个etree对象，并且需要将被解析的页面源码数据加载到该对象中。 通过调用etree对象中的xpath方法结合着xpath表达式实现标签的定位和内容的捕获 xpath定位到数据后返回的不是数据的内容，而已一个列表，里面放置了解析出来的Element对象 安装&gt;_: pip install lxml 导入 from lxml import etree 使用 创建etree对象并传入待解析对象 传入待解析对象为本地文件 tree = etree.parse(filePath) 传入待解析对象为网络请求 tree = etree.HTML(&#39;page_text&#39;) 定位数据：tree.xpath(xpath表达式) 在XPath中有7种节点：元素、属性、文本、文档、命名空间、处理指令、注释。 元素、属性、文本 为常用节点。 1234&lt;html&gt; 为文档节点&lt;li&gt;小米&lt;/li&gt; 为元素节点class=&#x27;blank&#x27; 为属性节点&lt;!-- 这里是注释 --&gt; 为注释节点 expression description nodeName 选择nodeName节点的所有子节点 / 从根节点或/前的节点开始，不跨层级匹配 // 从//前的节点开始，跨层级匹配 . 选择当前节点 .. 选择当前节点的父节点 @ 匹配元素属性 * 匹配所有节点 @* 匹配节点所有属性 [] 按索引定位 /：表示从根节点开始定位 / 放在最前面的时候表示根节点，不是放在最前面的时候表示 123456789101112131415161718from lxml import etreewith open(&#x27;./test.html&#x27;, &#x27;r&#x27;, encoding=&#x27;utf-8&#x27;) as f: f_content = f.read() tree = etree.HTML(f_content) r = tree.xpath(&#x27;/html/body/div/p&#x27;) print(r) print(type(r))--------------------------------------------------xpath 在匹配的时候是贪婪的，示例中有两个 div 下都有 p，所以匹配到了5个# Output:[&lt;Element p at 0x252e2de8780&gt;, &lt;Element p at 0x252e2de87c0&gt;, &lt;Element p at 0x252e2de8800&gt;, &lt;Element p at 0x252e2de8840&gt;, &lt;Element p at 0x252e2de8880&gt;]&lt;class &#x27;list&#x27;&gt; //：表示匹配多级 /a/b//c，就表示匹配 a 标签下的 b 标签下所有c标签 123456789101112131415161718192021from lxml import etreewith open(&#x27;./test.html&#x27;, &#x27;r&#x27;, encoding=&#x27;utf-8&#x27;) as f: f_content = f.read() tree = etree.HTML(f_content) r = tree.xpath(&#x27;/html//a&#x27;) # 等价于 r = tree.xpath(&#x27;//a&#x27;) print(r) print(type(r))--------------------------------------------------html节点下总共有8个a标签，所以匹配到8个element对象# Output:[&lt;Element a at 0x1e5f55e9680&gt;, &lt;Element a at 0x1e5f55e96c0&gt;, &lt;Element a at 0x1e5f55e9700&gt;, &lt;Element a at 0x1e5f55e9740&gt;, &lt;Element a at 0x1e5f55e9780&gt;, &lt;Element a at 0x1e5f55e9800&gt;, &lt;Element a at 0x1e5f55e9840&gt;, &lt;Element a at 0x1e5f55e9880&gt;]&lt;class &#x27;list&#x27;&gt; @：表示通过属性定位 tag[@attrName=&quot;attrValue&quot;]@后面加上属性名，比如class、id、href、src等等 1234567891011121314from lxml import etreewith open(&#x27;./test.html&#x27;, &#x27;r&#x27;, encoding=&#x27;utf-8&#x27;) as f: f_content = f.read() tree = etree.HTML(f_content) r = tree.xpath(&#x27;/html//div[@class=&quot;song&quot;]&#x27;) print(r) print(type(r))--------------------------------------------------html节点下总共有8个a标签，所以匹配到8个element对象# Output:[&lt;Element div at 0x24d64839640&gt;]&lt;class &#x27;list&#x27;&gt; []：表示通过索引定位 tag[index]这里是索引是从1开始的 12345678910111213141516171819from lxml import etreewith open(&#x27;./test.html&#x27;, &#x27;r&#x27;, encoding=&#x27;utf-8&#x27;) as f: f_content = f.read() tree = etree.HTML(f_content) print(tree.xpath(&#x27;/html//div[@class=&quot;song&quot;]/p[1]&#x27;)) print(tree.xpath(&#x27;/html//div[@class=&quot;song&quot;]/p[1]/text()&#x27;)) print(tree.xpath(&#x27;/html//div[@class=&quot;song&quot;]/p[2]&#x27;)) print(tree.xpath(&#x27;/html//div[@class=&quot;song&quot;]/p[3]&#x27;))--------------------------------------------------这里的下标是从1开始的# Output:[&lt;Element p at 0x1df3d4395c0&gt;][&#x27;李清照&#x27;][&lt;Element p at 0x1df3d439580&gt;][&lt;Element p at 0x1df3d439600&gt;]&lt;class &#x27;list&#x27;&gt; /text()：返回标签之间的文本，取文本 tag/text()：获取tag下直系的文本tag//text()：获取tag下直系和非直系的文本 12345678910111213141516171819from lxml import etreewith open(&#x27;./test.html&#x27;, &#x27;r&#x27;, encoding=&#x27;utf-8&#x27;) as f: f_content = f.read() tree = etree.HTML(f_content) r1 = tree.xpath(&#x27;/html//div[@class=&quot;song&quot;]/p[3]&#x27;) r2 = tree.xpath(&#x27;/html//div[@class=&quot;song&quot;]/p[3]/text()&#x27;) r3 = tree.xpath(&#x27;/html//div[@class=&quot;song&quot;]/p[3]/text()&#x27;)[0] print(r1) print(r2) print(r3)--------------------------------------------------# Output:[&lt;Element p at 0x1d4e4c29540&gt;][&#x27;苏轼&#x27;]苏轼&lt;class &#x27;list&#x27;&gt; /@attrName：返回标签的attrName属性的值 tag/@attrName：获取tag标签中的attrName属性的值 1234567891011121314151617from lxml import etreewith open(&#x27;./test.html&#x27;, &#x27;r&#x27;, encoding=&#x27;utf-8&#x27;) as f: f_content = f.read() tree = etree.HTML(f_content) r1 = tree.xpath(&#x27;//div[@class=&quot;song&quot;]/a/@href&#x27;) print(r1) r2 = tree.xpath(&#x27;//div[@class=&quot;song&quot;]/img/@src&#x27;) print(r2)--------------------------------------------------# Output:[&#x27;https://www.song.com&#x27;, &#x27;&#x27;][&#x27;https://www.baidu.com/meinv.jpg&#x27;]&lt;class &#x27;list&#x27;&gt; /@*：返回标签的所有属性的值 tag/@*：获取tag标签中的所有属性的值 12345678910111213from lxml import etreewith open(&#x27;./test.html&#x27;, &#x27;r&#x27;, encoding=&#x27;utf-8&#x27;) as f: f_content = f.read() tree = etree.HTML(f_content) r1 = tree.xpath(&#x27;//div[@class=&quot;song&quot;]/a[@target=&quot;_self&quot;]/@*&#x27;) print(r1)--------------------------------------------------# Output:[&#x27;https://www.song.com&#x27;, &#x27;赵匡胤&#x27;, &#x27;_self&#x27;]&lt;class &#x27;list&#x27;&gt; 案例 从彼岸图网下载4K图保存至本地 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849import osfrom lxml import etreeimport requestsUA = &#x27;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/84.0.4147.89 Safari/537.36 Edg/84.0.522.44&#x27;header = &#123;&#x27;User-Agent&#x27;: UA&#125;path = &#x27;./爬虫/4k&#x27;if not os.path.exists(path): os.mkdir(path)def get_url(): &quot;&quot;&quot; 获取所有图片地址 &quot;&quot;&quot; url = &#x27;http://pic.netbian.com/4kmeinv/&#x27; index_text = requests.get(url=url, headers=header).text tree = etree.HTML(index_text) a_list = tree.xpath(&#x27;//div[@id=&quot;main&quot;]/div[3]/ul/li/a&#x27;) # response.encoding = &#x27;utf-8&#x27; # 处理中文乱码方式1，不一定有效 img_list = list() for a in a_list: src: str = &#x27;http://pic.netbian.com&#x27; + a.xpath(&#x27;./@href&#x27;)[0] title: str = a.xpath(&#x27;./b/text()&#x27;)[0] + &#x27;.jpg&#x27; title = title.encode(&#x27;iso-8859-1&#x27;).decode(&#x27;gbk&#x27;) # 处理中文乱码方式2 img_list.append((title, src)) return img_listdef download_img(img_info): &quot;&quot;&quot; 下载图片 &quot;&quot;&quot; img_content = requests.get(url=img_info[1], headers=header).content filepath = os.path.join(path, img_info[0]) with open(filepath, &#x27;wb&#x27;) as f: f.write(img_content)def main(): img_list = get_url() for img_info in img_list: download_img(img_info)if __name__ == &#x27;__main__&#x27;: main()","categories":[{"name":"Python","slug":"Python","permalink":"https://www.boii.xyz/categories/Python/"},{"name":"爬虫","slug":"Python/爬虫","permalink":"https://www.boii.xyz/categories/Python/%E7%88%AC%E8%99%AB/"},{"name":"基础","slug":"Python/爬虫/基础","permalink":"https://www.boii.xyz/categories/Python/%E7%88%AC%E8%99%AB/%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"Python","slug":"Python","permalink":"https://www.boii.xyz/tags/Python/"},{"name":"爬虫","slug":"爬虫","permalink":"https://www.boii.xyz/tags/%E7%88%AC%E8%99%AB/"}]},{"title":"Python【Crawler】爬虫总叙","slug":"Python【Crawler】0-爬虫总叙","date":"2020-08-20T04:17:48.000Z","updated":"2021-05-22T13:37:47.740Z","comments":true,"path":"2020/08/20/Python【Crawler】0-爬虫总叙/","link":"","permalink":"https://www.boii.xyz/2020/08/20/Python%E3%80%90Crawler%E3%80%910-%E7%88%AC%E8%99%AB%E6%80%BB%E5%8F%99/","excerpt":"工具人，啊不，工具蜘蛛。","text":"工具人，啊不，工具蜘蛛。 使用场景 通用爬虫：抓取系统重要组成部分，抓取的是一整张页面数据。 聚焦爬虫：建立在通用爬虫之上，抓取的是页面中特定的局部内容。 增量爬虫：检测网站中数据更新的情况，只会抓取网站中最新的数据。 矛与盾 反爬机制：门户网站，可以通过指定相应的策略或技术手段，防止爬虫程序进行爬取 检查User-Agent IP屏蔽 抗反爬策略：通过制定相关策略或技术手段破解门户网站的反爬机制。 UA伪装 IP代理 robots.txt 协议 —— 君子协议：规定了网站中哪些数据可以被爬虫爬取，哪些数据不可以被爬取 http 概念：服务器与客户端数据交互的一种形式 常用请求头信息： User-Agent：请求载体的身份载体 Connection：请求完毕后，是否断开连接 常用响应头信息： Content-Type：服务器响应回客户端的数据类型 https 安全的http协议","categories":[{"name":"Python","slug":"Python","permalink":"https://www.boii.xyz/categories/Python/"},{"name":"爬虫","slug":"Python/爬虫","permalink":"https://www.boii.xyz/categories/Python/%E7%88%AC%E8%99%AB/"},{"name":"基础","slug":"Python/爬虫/基础","permalink":"https://www.boii.xyz/categories/Python/%E7%88%AC%E8%99%AB/%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"Python","slug":"Python","permalink":"https://www.boii.xyz/tags/Python/"},{"name":"爬虫","slug":"爬虫","permalink":"https://www.boii.xyz/tags/%E7%88%AC%E8%99%AB/"}]},{"title":"Python【Buildins】json","slug":"Python【No-Buildins】json","date":"2020-08-20T04:17:48.000Z","updated":"2021-05-22T13:37:47.723Z","comments":true,"path":"2020/08/20/Python【No-Buildins】json/","link":"","permalink":"https://www.boii.xyz/2020/08/20/Python%E3%80%90No-Buildins%E3%80%91json/","excerpt":"Python的内置库——json处理","text":"Python的内置库——json处理 &#123;&quot;firstName&quot;:&quot;John&quot;, &quot;lastName&quot;:&quot;Doe&quot;&#125; 对于dictionaries，keys需要是字符串类型(字典中任何非字符串类型的key在编码时会先转换为字符串)。而且，在web应用程序中，顶层对象被编码为一个字典是一个标准做法。 这句话大概意思是： 用&#123;&#125; 开头和结尾 用str表示 key 用str, int, list, dict 表示 value list用[index]访问 dict用.key访问 json 字符串生成 python 对象：json.load()python 对象格式化为 json 字符串：json.dump() 数据类型转换对应表（python -&gt; json） Python JSON dict object list, tuple array str string int, float number True true False false None null 转换对应表（json -&gt; python） JSON Python object dict array list string str number(int) int number(real) float true True false False null None 常用方法 方法 功能 总结 json.dump(obj,fp) 将python数据类型转换并保存到json格式文件内 p -&gt; j,写入文件 json.dumps(obj) 将python数据类型转换为json格式的字符串 p -&gt; j json.load(fp) 从json格式的文件中读取数据并转换为python的类型 从文件读, j -&gt; p json.loads(str) 将json格式的字符串转换为python的类型 j -&gt; p 带s的是处理字符串不带s的是从文件里处理 Python -&gt; JSON json.dump(obj, fp, *, skipkeys=False, ensure_ascii=True, check_circular=True, allow_nan=True, cls=None, indent=None, separators=None, default=None, sort_keys=False, **kw) json.dumps(obj, *, skipkeys=False, ensure_ascii=True, check_circular=True, allow_nan=True, cls=None, indent=None, separators=None, default=None, sort_keys=False, **kw) obj：需要被转换的Python对象 fp：文件对象，要写入的文件 skipkeys： Fasle时：不是基本对象(int、str、bool、float)的键不会被跳过 True时：不是基本对象(int、str、bool、float)的键会被跳过 ensure_ascii： True：将非ASCII字符转义，例如中文 False：将非ASCII字符原样输出 allow_nan： True：对json规格范围外的float类型(nan、inf、-inf)序列化时会引发ValueError False：对json规格范围外的float类型(nan、inf、-inf)序列化时使用等价形式(NaN、Infinity、-Infinity) indent：指定缩进等级（非负整数/字符串） 0、负数、””：只添加换行符 None：不缩进 正整数：每层缩进同样数量的空格 字符串：如\\t，该字符串将被用于缩进每一层 sort_keys：按字典的键排序 default：其应该是一个函数，每当某个对象无法被序列化时它会被调用。它应该返回该对象的一个可以被 JSON 编码的版本或者引发一个 TypeError。 使用dumps() 123456789101112131415161718192021222324252627282930import json# 这是一个 python 字典对象py_dic = &#123; &#x27;firstName&#x27;: &#x27;Boii&#x27;, &#x27;j&#x27;: &#123; &#x27;x&#x27;: 1, &#x27;y&#x27;: &quot;2&quot;, &#x27;z&#x27;: 3 &#125;, &quot;lastName&quot;: &quot;Pro&quot;, &#x27;li&#x27;: [&quot;A&quot;, &#x27;b&#x27;, 3]&#125;print(&#x27;Python对象：&#x27;, end=&quot;&quot;)print(py_dic, end=&quot;\\t&quot;)print(type(py_dic))# 将一个 Python 对象转换成 json 字符串json_str = json.dumps(py_dic, sort_keys=True)print(&#x27;JSON字符串：&#x27;, end=&quot;&quot;)print(json_str, end=&quot;\\t&quot;)print(type(json_str))--------------------------------------------------# Output:Python对象：&#123;&#x27;firstName&#x27;: &#x27;Boii&#x27;, &#x27;j&#x27;: &#123;&#x27;x&#x27;: 1, &#x27;y&#x27;: &#x27;2&#x27;, &#x27;z&#x27;: 3&#125;, &#x27;lastName&#x27;: &#x27;Pro&#x27;, &#x27;li&#x27;: [&#x27;A&#x27;, &#x27;b&#x27;, 3]&#125; &lt;class &#x27;dict&#x27;&gt;JSON字符串：&#123;&quot;firstName&quot;: &quot;Boii&quot;, &quot;j&quot;: &#123;&quot;x&quot;: 1, &quot;y&quot;: &quot;2&quot;, &quot;z&quot;: 3&#125;, &quot;lastName&quot;: &quot;Pro&quot;, &quot;li&quot;: [&quot;A&quot;, &quot;b&quot;, 3]&#125; &lt;class &#x27;str&#x27;&gt; 可以发现，Python中都是使用单引号&#39;，JSON中都是使用双引号&quot; 123456789101112131415161718192021import json# 这是一个python 列表对象py_list = [1, 2, 3]print(&#x27;Python对象：&#x27;, end=&quot;&quot;)print(py_list, end=&quot;\\t&quot;)print(type(py_list))# 将一个 Python 对象转换成 json 字符串json_str = json.dumps(py_list, sort_keys=True)print(&#x27;JSON字符串：&#x27;, end=&quot;&quot;)print(json_str, end=&quot;\\t&quot;)print(type(json_str))--------------------------------------------------# Output:Python对象：[1, 2, 3] &lt;class &#x27;list&#x27;&gt;JSON字符串：[1, 2, 3] &lt;class &#x27;str&#x27;&gt; 使用dump() 123456789101112131415161718192021222324import jsonpy_dic = &#123; &#x27;firstName&#x27;: &#x27;Boii&#x27;, &#x27;j&#x27;: &#123; &#x27;x&#x27;: 1, &#x27;y&#x27;: &quot;2&quot;, &#x27;z&#x27;: 3 &#125;, &quot;lastName&quot;: &quot;Pro&quot;, &#x27;li&#x27;: [&quot;A&quot;, &#x27;b&#x27;, 3]&#125;# 将一个 Python 对象转换成 json 字符串，然后写入文件with open(&#x27;./py_dic.json&#x27;, &#x27;w&#x27;, encoding=&#x27;utf-8&#x27;) as f: json.dump(py_dic, f, sort_keys=True)--------------------------------------------------# Output:没有输出，因为输出到文件中了# py_dic.json&#123;&quot;firstName&quot;: &quot;Boii&quot;, &quot;j&quot;: &#123;&quot;x&quot;: 1, &quot;y&quot;: &quot;2&quot;, &quot;z&quot;: 3&#125;, &quot;lastName&quot;: &quot;Pro&quot;, &quot;li&quot;: [&quot;A&quot;, &quot;b&quot;, 3]&#125; 有些教程中直接使用open()打开一个文件对象，然后将文件对象作为参数传入dump()，却没有使用close()关闭文件对象。这是错误的，会造成文件对象一直没有关闭而持续占用计算机资源。 解决方法：要么手动调用close()方法，要么用with语句 12345678f = open(&#x27;./py_dic.json&#x27;, &#x27;w&#x27;, encoding=&#x27;utf-8&#x27;)json.dump(py_dic, f, sort_keys=True)f.close()或with open(&#x27;./py_dic.json&#x27;, &#x27;w&#x27;, encoding=&#x27;utf-8&#x27;) as f: json.dump(py_dic, f, sort_keys=True) JSON -&gt; Python json.load(fp, *, cls=None, object_hook=None, parse_float=None, parse_int=None, parse_constant=None, object_pairs_hook=None, **kw) json.loads(s, *, cls=None, object_hook=None, parse_float=None, parse_int=None, parse_constant=None, object_pairs_hook=None, **kw) fp：文件对象，要写入的文件 object_hook：是一个可选的函数，它会被调用于每一个解码出的对象字面量（即一个 dict）。object_hook 的返回值会取代原本的 dict。这一特性能够被用于实现自定义解码器（如 JSON-RPC 的类型提示)。 parse_float、parse_int、parse_constant、 object_pairs_hook：都是编码解码器需要的参数 使用loads() 1234567891011121314151617181920import jsonStr = &#x27;&#123;&quot;name&quot;: &quot;Boii&quot;, &quot;age&quot;: 30, &quot;tel&quot;:[&quot;13800000000&quot;, &quot;13100880088&quot;], &quot;isonly&quot;:true&#125;&#x27;print(&#x27;JSON字符串：&#x27;, end=&quot;&quot;)print(Str, end=&#x27;\\t&#x27;)print(type(Str))# 将一个 json 字符串 转换成 Python 对象pythonObj = json.loads(Str)print(&#x27;Python对象：&#x27;, end=&quot;&quot;)print(pythonObj, end=&#x27;\\t&#x27;)print(type(pythonObj))--------------------------------------------------# Output:JSON字符串：&#123;&quot;name&quot;: &quot;Boii&quot;, &quot;age&quot;: 30, &quot;tel&quot;:[&quot;13800000000&quot;, &quot;13100880088&quot;], &quot;isonly&quot;:true&#125; &lt;class &#x27;str&#x27;&gt;Python对象：&#123;&#x27;name&#x27;: &#x27;Boii&#x27;, &#x27;age&#x27;: 30, &#x27;tel&#x27;: [&#x27;13800000000&#x27;, &#x27;13100880088&#x27;], &#x27;isonly&#x27;: True&#125; &lt;class &#x27;dict&#x27;&gt; 可以发现，Python中都是使用单引号&#39;，JSON中都是使用双引号&quot; 使用load()从json文件中读取转换成Python对象 1234567891011121314151617# py.json&#123;&quot;firstName&quot;: &quot;Boii&quot;, &quot;j&quot;: &#123;&quot;x&quot;: 2, &quot;y&quot;: &quot;2&quot;, &quot;z&quot;: 3&#125;, &quot;lastName&quot;: &quot;Pro&quot;, &quot;li&quot;: [&quot;A&quot;, &quot;b&quot;, 3]&#125;# j2p.pyimport jsonwith open(&#x27;./j2p.py&#x27;, &#x27;r&#x27;, encoding=&#x27;utf-8&#x27;) as f: pythonObj = json.load(f) print(&#x27;Python对象：&#x27;, end=&quot;&quot;) print(pythonObj) print(type(pythonObj))--------------------------------------------------# Output:Python对象：&#123;&#x27;firstName&#x27;: &#x27;Boii&#x27;, &#x27;j&#x27;: &#123;&#x27;x&#x27;: 1, &#x27;y&#x27;: &#x27;2&#x27;, &#x27;z&#x27;: 3&#125;, &#x27;lastName&#x27;: &#x27;Pro&#x27;, &#x27;li&#x27;: [&#x27;A&#x27;, &#x27;b&#x27;, 3]&#125;&lt;class &#x27;dict&#x27;&gt; 总结1234567# Writing JSON datawith open(&#x27;data.json&#x27;, &#x27;w&#x27;) as f: json.dump(data, f)# Reading data backwith open(&#x27;data.json&#x27;, &#x27;r&#x27;) as f: data = json.load(f)","categories":[{"name":"Python","slug":"Python","permalink":"https://www.boii.xyz/categories/Python/"},{"name":"内置库","slug":"Python/内置库","permalink":"https://www.boii.xyz/categories/Python/%E5%86%85%E7%BD%AE%E5%BA%93/"}],"tags":[{"name":"Python","slug":"Python","permalink":"https://www.boii.xyz/tags/Python/"},{"name":"json","slug":"json","permalink":"https://www.boii.xyz/tags/json/"}]},{"title":"Python【Buildins】re","slug":"Python【No-Buildins】re","date":"2020-08-20T03:17:48.000Z","updated":"2021-05-22T13:37:47.723Z","comments":true,"path":"2020/08/20/Python【No-Buildins】re/","link":"","permalink":"https://www.boii.xyz/2020/08/20/Python%E3%80%90No-Buildins%E3%80%91re/","excerpt":"Python的内置库——正则表达式","text":"Python的内置库——正则表达式 正则表达式是用来处理字符串的，重在处理规则 常用正则 年份匹配：^((19|20)\\d&#123;2&#125;)$ 手机号码：^1[3456789]\\d&#123;9&#125;$ E-mail地址：^[\\w-]+(\\.[\\w-]+)*@[\\w-]+(\\.[\\w-]+)+$ 网址URL：http://(/[\\w-]+\\.)+[\\w-]+(/[\\w-./?%&amp;=]) re.findall(goal, source)匹配成功 返回一个列表，列表中有goal的字符串，找到n次就有n个匹配失败 返回一个空列表 1234567891011&gt;&gt;&gt; # 普通字符正则的匹配&gt;&gt;&gt;&gt;&gt;&gt; import re&gt;&gt;&gt; print(re.findall(&#x27;p&#x27;, &#x27;python&#x27;))[&#x27;p&#x27;]&gt;&gt;&gt; print(re.findall(&#x27;python&#x27;, &#x27;I like python&#x27;))[&#x27;python&#x27;]&gt;&gt;&gt; print(re.findall(&#x27;o&#x27;, &#x27;I love python&#x27;))[&#x27;o&#x27;, &#x27;o&#x27;]&gt;&gt;&gt; print(re.findall(&#x27;2&#x27;, &#x27;1234567890abcdefg&#x27;))[&#x27;2&#x27;] 预定义字符 \\d、\\D、\\s、\\S、\\w、\\W \\d：匹配所有数字，0~9 \\w：匹配包含下划线字符 [a-z|A-Z|0-9|_] \\s：匹配空白符、制表符、换行符 [\\n \\t] \\D：匹配所有非数字，^[0-9] \\W：匹配非正常字符 ^[a-z|A-Z|0-9|_] \\S：匹配非空白符、制表符、换行符 ^[\\n \\t] .：除了换行符之外所有字符 1234567891011121314&gt;&gt;&gt; print(re.findall(r&quot;\\d&quot;, &quot;1234657890abcdefg&quot;))[&#x27;1&#x27;, &#x27;2&#x27;, &#x27;3&#x27;, &#x27;4&#x27;, &#x27;6&#x27;, &#x27;5&#x27;, &#x27;7&#x27;, &#x27;8&#x27;, &#x27;9&#x27;, &#x27;0&#x27;]&gt;&gt;&gt; print(re.findall(r&quot;\\D&quot;, &quot;1234657890abcdefg&quot;))[&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;, &#x27;d&#x27;, &#x27;e&#x27;, &#x27;f&#x27;, &#x27;g&#x27;]&gt;&gt;&gt; print(re.findall(r&quot;\\w&quot;, &quot;1234657890abcd_%$#efg&quot;))[&#x27;1&#x27;, &#x27;2&#x27;, &#x27;3&#x27;, &#x27;4&#x27;, &#x27;6&#x27;, &#x27;5&#x27;, &#x27;7&#x27;, &#x27;8&#x27;, &#x27;9&#x27;, &#x27;0&#x27;, &#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;, &#x27;d&#x27;, &#x27;_&#x27;, &#x27;e&#x27;, &#x27;f&#x27;, &#x27;g&#x27;]&gt;&gt;&gt; print(re.findall(r&quot;\\W&quot;, &quot;1234657890abcd_%$#efg&quot;))[&#x27;%&#x27;, &#x27;$&#x27;, &#x27;#&#x27;]&gt;&gt;&gt; print(re.findall(r&quot;\\s&quot;, &quot;1234 657\\n890ab\\tcd_%$#efg&quot;))[&#x27; &#x27;, &#x27;\\n&#x27;, &#x27;\\t&#x27;]&gt;&gt;&gt; print(re.findall(r&quot;\\S&quot;, &quot;1234 657\\n890ab\\tcd_%$#efg&quot;))[&#x27;1&#x27;, &#x27;2&#x27;, &#x27;3&#x27;, &#x27;4&#x27;, &#x27;6&#x27;, &#x27;5&#x27;, &#x27;7&#x27;, &#x27;8&#x27;, &#x27;9&#x27;, &#x27;0&#x27;, &#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;, &#x27;d&#x27;, &#x27;_&#x27;, &#x27;%&#x27;, &#x27;$&#x27;, &#x27;#&#x27;, &#x27;e&#x27;, &#x27;f&#x27;, &#x27;g&#x27;] 元字符 []、&#123;n&#125;、^、- []：匹配一个字符，括号内是或者的关系 ^：取反 (和这些元字符或\\d这些预定义字符一起用才是取反，否则和$一起做位置匹配) -：区间 ()：分组，匹配括号内的内容，不要括号两边的内容 123456789101112131415161718192021222324252627282930# 区间&gt;&gt;&gt; # 匹配123任意单个字符&gt;&gt;&gt; print(re.findall(r&quot;[123]&quot;, &quot;1234 657\\n890ab\\tcd_%$#efg&quot;))[&#x27;1&#x27;, &#x27;2&#x27;, &#x27;3&#x27;]&gt;&gt;&gt; # 匹配单个数字（\\d）或 空格换行制表符（\\s）&gt;&gt;&gt; print(re.findall(r&quot;[\\d\\s]&quot;, &quot;1234 657\\n890ab\\tcd_%$#efg&quot;))[&#x27;1&#x27;, &#x27;2&#x27;, &#x27;3&#x27;, &#x27;4&#x27;, &#x27; &#x27;, &#x27;6&#x27;, &#x27;5&#x27;, &#x27;7&#x27;, &#x27;\\n&#x27;, &#x27;8&#x27;, &#x27;9&#x27;, &#x27;0&#x27;, &#x27;\\t&#x27;]# 取反&gt;&gt;&gt; # 匹配单个非数字、非空格换行制表符&gt;&gt;&gt; print(re.findall(r&quot;[^\\d\\s]&quot;, &quot;1234 657\\n890ab\\tcd_%$#efg&quot;))[&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;, &#x27;d&#x27;, &#x27;_&#x27;, &#x27;%&#x27;, &#x27;$&#x27;, &#x27;#&#x27;, &#x27;e&#x27;, &#x27;f&#x27;, &#x27;g&#x27;]# 范围&gt;&gt;&gt; # 匹配单个1-7之间的数字&gt;&gt;&gt; print(re.findall(r&quot;[1-7]&quot;, &quot;1234 657\\n890ab\\tcd_%$#efg&quot;))&gt;&gt;&gt; # 匹配单个a-d之间的字母&gt;&gt;&gt; print(re.findall(r&quot;[a-d]&quot;, &quot;1234 657\\n890ab\\tcd_%$#efg&quot;))&gt;&gt;&gt; # 匹配单个 1-7 或 a-d 的字符&gt;&gt;&gt; print(re.findall(r&quot;[1-7a-d]&quot;, &quot;1234 657\\n890ab\\tcd_%$#efg&quot;))# 分组&gt;&gt;&gt; # 匹配 左边a右边是a或b或c的两个字符&gt;&gt;&gt; print(re.findall(r&quot;a[abc]&quot;, &quot;aaabacad&quot;))[&#x27;aa&#x27;, &#x27;ab&#x27;, &#x27;ac&#x27;]&gt;&gt;&gt; # 第一步，匹配到[&#x27;aa&#x27;, &#x27;ab&#x27;, &#x27;ac&#x27;]&gt;&gt;&gt; # 第二步，不要括号两边的字符，也就是不要a，得到[&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;]&gt;&gt;&gt; print(re.findall(r&quot;a([abc])&quot;, &quot;aaabacad&quot;))[&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;] 重复匹配重复匹配默认是贪婪匹配的，会尽量匹配多位 &#123;n&#125;：表示前面的字符重复n次才被匹配成功。a&#123;3&#125;就匹配出：aaa &#123;n,m&#125;：表示前面的字符至少出现n次，至多出现m次，逗号左右不能有空格，贪婪匹配 &#123;n,m&#125;?：表示前面的字符至少出现n次，至多出现m次，逗号左右不能有空格，非贪婪匹配 &#123;n,&#125;：表示前面的字符至少出现n次，至多出现无穷次 ?：相当于&#123;0,1&#125;，表示前面的字符出现0次或1次 +：相当于&#123;1,&#125;，表示前面的字符至少出现1次 *：相当于&#123;0,&#125;，表示前面的字符出现0次或无穷次，贪婪匹配 +?：相当于&#123;1,&#125;?、&#123;1&#125;，表示前面的字符至少出现1次，非贪婪匹配 *?：相当于&#123;0,&#125;?、&#123;0&#125;，表示前面的字符至少出现0次，非贪婪匹配 \\：转义符，在需要匹配上面?+*几个符号的时候需要加上斜杠\\ 12345678910111213141516171819# &#123;n&#125;&gt;&gt;&gt; # 贪婪匹配连续3位都是数字&gt;&gt;&gt; print(re.findall(r&quot;\\d&#123;3&#125;&quot;, &quot;1234567890abcdefg&quot;))[&#x27;123&#x27;, &#x27;456&#x27;, &#x27;789&#x27;]&gt;&gt;&gt; # 贪婪匹配连续2位都是正常字符&gt;&gt;&gt; print(re.findall(r&quot;\\w&#123;2&#125;&quot;, &quot;12a3456789b0abcdefg&quot;))[&#x27;12&#x27;, &#x27;a3&#x27;, &#x27;45&#x27;, &#x27;67&#x27;, &#x27;89&#x27;, &#x27;b0&#x27;, &#x27;ab&#x27;, &#x27;cd&#x27;, &#x27;ef&#x27;]&gt;&gt;&gt; # 贪婪匹配至少2位至多4位的数字&gt;&gt;&gt; print(re.findall(r&quot;\\d&#123;2,4&#125;&quot;, &quot;1234567890abcdefg&quot;))[&#x27;1234&#x27;, &#x27;5678&#x27;]&gt;&gt;&gt; print(re.findall(r&quot;\\d&#123;2,4&#125;&quot;, &quot;12a3456789b0abcdefg&quot;))[&#x27;12&#x27;, &#x27;3456&#x27;, &#x27;789&#x27;]&gt;&gt;&gt; # 非贪婪匹配至少2位至多4位的数字&gt;&gt;&gt; print(re.findall(r&quot;\\d&#123;2,4&#125;?&quot;, &quot;12a3456789b0abcdefg&quot;))[&#x27;12&#x27;, &#x27;34&#x27;, &#x27;56&#x27;, &#x27;78&#x27;]&gt;&gt;&gt; # 贪婪匹配出现至少2位的数字&gt;&gt;&gt; print(re.findall(r&quot;\\d&#123;2,&#125;&quot;, &quot;12a3456789b0abcdefg165465165&quot;))[&#x27;12&#x27;, &#x27;3456789&#x27;, &#x27;165465165&#x27;] 1234567891011121314151617# ? + *&gt;&gt;&gt; # 贪婪匹配0或1个数字，0个也在匹配范围内，所以匹配到非数字的时候是空字符串&gt;&gt;&gt; print(re.findall(r&quot;\\d?&quot;, &quot;12a3456789b0abcde_%&quot;))[&#x27;1&#x27;, &#x27;2&#x27;, &#x27;&#x27;, &#x27;3&#x27;, &#x27;4&#x27;, &#x27;5&#x27;, &#x27;6&#x27;, &#x27;7&#x27;, &#x27;8&#x27;, &#x27;9&#x27;, &#x27;&#x27;, &#x27;0&#x27;, &#x27;&#x27;, &#x27;&#x27;, &#x27;&#x27;, &#x27;&#x27;, &#x27;&#x27;, &#x27;&#x27;, &#x27;&#x27;, &#x27;&#x27;]&gt;&gt;&gt; # 贪婪匹配1或n个数字&gt;&gt;&gt; print(re.findall(r&quot;\\d+&quot;, &quot;12a3456789b0abcde_%&quot;))[&#x27;12&#x27;, &#x27;3456789&#x27;, &#x27;0&#x27;]&gt;&gt;&gt; # 非贪匹配1或n个数字&gt;&gt;&gt; print(re.findall(r&quot;\\d+?&quot;, &quot;12a3456789b0abcde_%&quot;))[&#x27;1&#x27;, &#x27;2&#x27;, &#x27;3&#x27;, &#x27;4&#x27;, &#x27;5&#x27;, &#x27;6&#x27;, &#x27;7&#x27;, &#x27;8&#x27;, &#x27;9&#x27;, &#x27;0&#x27;]&gt;&gt;&gt; # 贪婪匹配1或n个数字&gt;&gt;&gt; print(re.findall(r&quot;\\d*&quot;, &quot;1234567890abcdefg&quot;))[&#x27;1234567890&#x27;, &#x27;&#x27;, &#x27;&#x27;, &#x27;&#x27;, &#x27;&#x27;, &#x27;&#x27;, &#x27;&#x27;, &#x27;&#x27;]&gt;&gt;&gt; # 非贪匹配1或n个数字&gt;&gt;&gt; print(re.findall(r&quot;\\d*?&quot;, &quot;1234567890abcdefg&quot;))[&#x27;&#x27;, &#x27;1&#x27;, &#x27;&#x27;, &#x27;2&#x27;, &#x27;&#x27;, &#x27;3&#x27;, &#x27;&#x27;, &#x27;4&#x27;, &#x27;&#x27;, &#x27;5&#x27;, &#x27;&#x27;, &#x27;6&#x27;, &#x27;&#x27;, &#x27;7&#x27;, &#x27;&#x27;, &#x27;8&#x27;, &#x27;&#x27;, &#x27;9&#x27;, &#x27;&#x27;, &#x27;0&#x27;, &#x27;&#x27;, &#x27;&#x27;, &#x27;&#x27;, &#x27;&#x27;, &#x27;&#x27;, &#x27;&#x27;, &#x27;&#x27;, &#x27;&#x27;] 1234567891011121314151617181920# 转义符&gt;&gt;&gt; # 匹配a*b&gt;&gt;&gt; print(re.findall(r&quot;a\\*b&quot;, &quot;aab*ab*aaa*ba*b*a&quot;))[&#x27;a*b&#x27;, &#x27;a*b&#x27;]&gt;&gt;&gt; # 匹配b前面至少出现0次a&gt;&gt;&gt; print(re.findall(r&quot;a*b&quot;, &quot;aab*ab*aaa*ba*b*a&quot;))[&#x27;aab&#x27;, &#x27;ab&#x27;, &#x27;b&#x27;, &#x27;b&#x27;, &#x27;b&#x27;, &#x27;b&#x27;]&gt;&gt;&gt; # 匹配a+b&gt;&gt;&gt; print(re.findall(r&quot;a\\+b&quot;, &quot;&quot;))[&#x27;a+b&#x27;]&gt;&gt;&gt; # 匹配b前面至少出现1次aprint(re.findall(r&quot;a+b&quot;, &quot;aab*ab*aa?ba*ba*b*a+b&quot;))[&#x27;aab&#x27;, &#x27;ab&#x27;]&gt;&gt;&gt; # 匹配a?bprint(re.findall(r&quot;a\\?b&quot;, &quot;aab*ab*aa?ba*ba*b*a+b&quot;))[&#x27;a?b&#x27;]&gt;&gt;&gt; # 匹配b前面至少出现0次至多出现1次aprint(re.findall(r&quot;a?b&quot;, &quot;aab*ab*aa?ba*ba*b*a+b&quot;))[&#x27;ab&#x27;, &#x27;ab&#x27;, &#x27;b&#x27;, &#x27;b&#x27;, &#x27;b&#x27;, &#x27;b&#x27;] 贪婪和非贪123456&gt;&gt;&gt; # 贪婪匹配 d开头d结尾，中间至少出现1位正常字符&gt;&gt;&gt; print(re.findall(r&quot;d\\w+d&quot;, &quot;dxxxxxxdxxxxxxd&quot;))[&#x27;dxxxxxxdxxxxxxd&#x27;]&gt;&gt;&gt; # 非贪匹配 d开头d结尾，中间至少出现1位正常字符&gt;&gt;&gt; print(re.findall(r&quot;d\\w+?d&quot;, &quot;dxxxxxxdxxxxxxd&quot;))[&#x27;dxxxxd&#x27;] 123456789101112131415&gt;&gt;&gt; html = &quot;&lt;li&gt;Boii&lt;/li&gt;&lt;li&gt;$18&lt;/li&gt;&lt;li&gt;男&lt;/li&gt;&lt;li&gt;i@tcp404.com&lt;/li&gt;&quot;&gt;&gt;&gt; # .是除了换行符以外所有字符&gt;&gt;&gt; # 贪婪匹配 &lt;li&gt;开头，&lt;/li&gt;结尾，中间至少一个非换行符的字符，共1个&gt;&gt;&gt; print(re.findall(r&quot;&lt;li&gt;.+&lt;/li&gt;&quot;, html))[&#x27;&lt;li&gt;Boii&lt;/li&gt;&lt;li&gt;$18&lt;/li&gt;&lt;li&gt;男&lt;/li&gt;&lt;li&gt;i@tcp404.com&lt;/li&gt;&#x27;]&gt;&gt;&gt; # 非贪匹配 &lt;li&gt;开头，&lt;/li&gt;结尾，中间至少一个非换行符的字符，共3个&gt;&gt;&gt; print(re.findall(r&quot;&lt;li&gt;.+?&lt;/li&gt;&quot;, html))[&#x27;&lt;li&gt;Boii&lt;/li&gt;&#x27;, &#x27;&lt;li&gt;$18&lt;/li&gt;&#x27;, &#x27;&lt;li&gt;男&lt;/li&gt;&#x27;, &#x27;&lt;li&gt;i@tcp404.com&lt;/li&gt;&#x27;]&gt;&gt;&gt; # 非贪匹配 &lt;li&gt;开头，&lt;/li&gt;结尾，中间至少一个非换行符的字符，且舍去开头结尾，&gt;&gt;&gt; # 即只取&lt;li&gt;&lt;/li&gt;中的内容，共3个&gt;&gt;&gt; print(re.findall(r&quot;&lt;li&gt;(.+?)&lt;/li&gt;&quot;, html))[&#x27;Boii&#x27;, &#x27;$18&#x27;, &#x27;男&#x27;, &#x27;i@tcp404.com&#x27;] 反向引用12345678910111213141516171819202122232425&gt;&gt;&gt; wordstr = &quot;&quot;&quot; &#x27;hello&#x27;, &quot;python&quot;, &#x27;love&quot;, &quot;haha&#x27; &quot;&quot;&quot;# 匹配 开头和结尾都是单引号或双引号，中间至少一个正常字符&gt;&gt;&gt; print(re.findall(r&quot;[&#x27;|\\&quot;]\\w+[&#x27;|\\&quot;]&quot;, wordstr))[&quot;&#x27;hello&#x27;&quot;, &#x27;&quot;python&quot;&#x27;, &#x27;\\&#x27;love&quot;&#x27;, &#x27;&quot;haha\\&#x27;&#x27;]# 匹配 开头和结尾都是单引号或双引号，中间至少一个正常字符，舍弃中间# 即 开头和结尾都是单或双引号，中间至少一个正常字符，然后把开头分一组，结尾分一组，中间无分组被舍弃&gt;&gt;&gt; print(re.findall(r&quot;(&#x27;|\\&quot;)\\w+(&#x27;|\\&quot;)&quot;, wordstr))[(&quot;&#x27;&quot;, &quot;&#x27;&quot;), (&#x27;&quot;&#x27;, &#x27;&quot;&#x27;), (&quot;&#x27;&quot;, &#x27;&quot;&#x27;), (&#x27;&quot;&#x27;, &quot;&#x27;&quot;)]# 匹配 开头和结尾都是单引号或双引号，中间至少一个正常字符，开头一组，中间一组，结尾一组，找到一份则组合成一个元组&gt;&gt;&gt; print(re.findall(r&quot;(&#x27;|\\&quot;)(\\w+)(&#x27;|\\&quot;)&quot;, wordstr))[(&quot;&#x27;&quot;, &#x27;hello&#x27;, &quot;&#x27;&quot;), (&#x27;&quot;&#x27;, &#x27;python&#x27;, &#x27;&quot;&#x27;), (&quot;&#x27;&quot;, &#x27;love&#x27;, &#x27;&quot;&#x27;), (&#x27;&quot;&#x27;, &#x27;haha&#x27;, &quot;&#x27;&quot;)]# 匹配 开头是单双引号，中间至少一个正常字符，结尾要与开头对应开头一组那个组相同# 开头一组，中间一组，结尾一组，找到一份则组合成一个元组&gt;&gt;&gt; print(re.findall(r&quot;(&#x27;|\\&quot;)(\\w+)(\\1)&quot;, wordstr))[(&quot;&#x27;&quot;, &#x27;hello&#x27;, &quot;&#x27;&quot;), (&#x27;&quot;&#x27;, &#x27;python&#x27;, &#x27;&quot;&#x27;)]# 用列表生成式取出每份的1号元素，就得到了内容。&gt;&gt;&gt; res = re.findall(r&quot;(&#x27;|\\&quot;)(\\w+)(\\1)&quot;, wordstr)&gt;&gt;&gt; li = [x[1] for x in res]&gt;&gt;&gt; print(li)[&#x27;hello&#x27;, &#x27;python&#x27;] 123456789101112# 校验密码，同样的字符不能连续出现3次&gt;&gt;&gt; print(re.findall(r&quot;(\\w)(\\1&#123;2,&#125;)&quot;, &quot;44888813abgggs&quot;))[(&#x27;8&#x27;, &#x27;888&#x27;), (&#x27;g&#x27;, &#x27;gg&#x27;)]# 第一个分组(\\w)匹配到是4，进入下一个元组，看到\\1替换成4，开始匹配重复：4出现至少2次则匹配成功，后面紧跟着只有一个4，所以匹配失败# 接着匹配到(\\w)是8，进入下一个分组，看到\\1替换成8，从第2个8开始匹配重复：8至少出现2次则匹配成功，除去第一个8被第一个分组取走，还剩3个8，匹配成功，这是贪婪匹配，所以会一直吃下去吃到遇见不是8停止，打包成元组# 接着1匹配失败，3匹配失败，ab都匹配失败# 接着匹配到(\\w)是g，进入下一个分组，看到\\1替换成g，从第2个g开始匹配重复：g至少出现2次则匹配成功，除去第一个g被第一个分组取走，还剩2个g，匹配成功，这是贪婪匹配，所以会一直吃下去吃到遇见不是g停止，打包成元组...res = re.findall(r&quot;(\\w)(\\1&#123;2,&#125;)&quot;, &quot;44888813abgggs&quot;)li = [x[0]+x[1] for x in res]print(li) # [&#x27;8888&#x27;, &#x27;ggg&#x27;] 位置匹配 ^：开头 $：结尾 这两个经常一起使用，用来限定位置常用于检验手机号、用户名、email地址等 例如匹配手机号 1234567891011121314# 手机位数正常的时候可以匹配成功&gt;&gt;&gt; print(re.findall(r&quot;\\d&#123;11&#125;&quot;, &quot;13700001111&quot;))[&#x27;13700001111&#x27;]# 但是手机位数不正常的时候也匹配成功了，所以要加以位置限制&gt;&gt;&gt; print(re.findall(r&quot;\\d&#123;11&#125;&quot;, &quot;137000011112233445&quot;))[&#x27;13700001111&#x27;]&gt;&gt;&gt; print(re.findall(r&quot;^\\d&#123;11&#125;$&quot;, &quot;13700001111&quot;))[&#x27;13700001111&#x27;]&gt;&gt;&gt; print(re.findall(r&quot;^\\d&#123;11&#125;$&quot;, &quot;137000011112233445&quot;))[]","categories":[{"name":"Python","slug":"Python","permalink":"https://www.boii.xyz/categories/Python/"},{"name":"内置库","slug":"Python/内置库","permalink":"https://www.boii.xyz/categories/Python/%E5%86%85%E7%BD%AE%E5%BA%93/"}],"tags":[{"name":"Python","slug":"Python","permalink":"https://www.boii.xyz/tags/Python/"},{"name":"正则表达式","slug":"正则表达式","permalink":"https://www.boii.xyz/tags/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"}]},{"title":"Python【No-14】枚举类","slug":"Python【No-14】枚举类","date":"2020-07-20T02:41:48.000Z","updated":"2021-05-22T13:37:47.723Z","comments":true,"path":"2020/07/20/Python【No-14】枚举类/","link":"","permalink":"https://www.boii.xyz/2020/07/20/Python%E3%80%90No-14%E3%80%91%E6%9E%9A%E4%B8%BE%E7%B1%BB/","excerpt":"枚举类型在 Python3.4 新增到标准库","text":"枚举类型在 Python3.4 新增到标准库 创建枚举有两种方法创建枚举 基于 class 语法创建 基于 Function API 创建 第一步，导入Enum类 1from enum import Enum 基于 class 语法创建12345678910from enum import Enumclass Weekend(Enum)； Mon = 1 Tue = 2 Wed = 3 Thr = 4 Fri = 5 Sat = 6 Sun = 7 上面例子 定义了 Weekend 枚举类型 定义了 Weekend 的枚举成员 Weekend.Mon，Weekend.Tue… 为每一个枚举成员赋值。如Weekend.Mon 的值为1。值可以指定为其他类型，不是必须整型 枚举成员包含两个属性：name和value 1234&gt;&gt;&gt; Weekend.Mon.nameMon&gt;&gt;&gt; Weekend.Mon.value1 定义string类型的值 12345678910111213from enum import Enumclass Weekend(Enum)； Monday = &#x27;Mon&#x27; Tuesday = &#x27;Tue&#x27; Wednesday = &#x27;Wed&#x27; Thursday = &#x27;Thu&#x27; Friday = &#x27;Fri&#x27; Saturday = &#x27;Sat&#x27; Sunday = &#x27;Sun&#x27;&gt;&gt;&gt; Weekend.Monday.value&#x27;Mon&#x27; 基于 Function API 创建 Enum(enum name, enumerators)第一个参数 enum name 表示枚举名称，第二个参数enumerators 表示枚举成员列表枚举成员列表有三种方式： 使用字符串表示，各成员名使用空格隔开。成员的值从1开始自动递增Enum(&#39;enum_name&#39;, &#39;member1 member2 member3 ... memberN&#39;) 使用元组表示，成员的值从1开始自动递增Enum(&#39;enum_name&#39;, (&#39;member1&#39;, &#39;member2&#39;, &#39;member3&#39;, ... , &#39;memberN&#39;)) 使用字典表示，字典可以指定枚举成员的值，其中字典的键为枚举成员名，值为枚举成员的值Enum(&#39;enum_name&#39;, &#123;&#39;member1_key&#39;: memberl_value, &#39;member_key2&#39;: member2_value,...&#125;) 123456789from enum import Enum# 以下三句表达式互相等价weekend = Enum(&#x27;week&#x27;,&#x27;Mon Tue Wed Thu Fri Sat Sun&#x27;)weekend = Enum(&#x27;week&#x27;,(&#x27;Mon&#x27;, &#x27;Tue&#x27;, &#x27;Wed&#x27;, &#x27;Thu&#x27;, &#x27;Fri&#x27;, &#x27;Sat&#x27;, &#x27;Sun&#x27;)weekend = Enum(&#x27;week&#x27;,&#123;&#x27;Mon&#x27;:1, &#x27;Tue&#x27;:2, &#x27;Wed&#x27;:3, &#x27;Thu&#x27;:4, &#x27;Fri&#x27;:5, &#x27;Sat&#x27;:6, &#x27;Sun&#x27;:7&#125;)&gt;&gt;&gt; weekend.Mon.value1 访问枚举成员访问枚举成员有三种方式： 使用点号(“.”)引用 使用value获取，值对应的枚举成员 使用枚举成员名 12345678910111213141516171819202122from enum import Enumclass Weekend(Enum): Mon = 1 Tue = 2 Wed = 3 Thr = 4 Fri = 5 Sat = 6 Sun = 7# 按值访问print(Weekend(5)) # Weekend.Fri# 按枚举名访问print(Weekend[&#x27;Sun&#x27;]) # Weekend.Sun# 访问成员的名称print(Weekend.Tue.name) # Tue# 访问成员的值print(Weekend.Thr.value) # 4 枚举遍历如果把枚举当作 Dict 来看，枚举类.枚举成员名是key，赋给枚举成员的值是value 123456789101112131415161718192021222324252627282930313233print(&quot;name: member | value&quot;)print(&quot;-&quot; * 25)for name, member in Weekend.__members__.items(): print(name + &quot; : &quot; + str(member) + &quot; | &quot; + str(member.value))# Output:name: member | value-------------------------Mon : Weekend.Mon | 0Tue : Weekend.Tue | 1Wed : Weekend.Wed | 2Thr : Weekend.Thr | 3Fri : Weekend.Fri | 4Sat : Weekend.Sat | 5Sun : Weekend.Sun | 6&gt;&gt;&gt; print(Weekend.__members__)&#123;&#x27;Mon&#x27;: &lt;Weekend.Mon: 0&gt;, &#x27;Tue&#x27;: &lt;Weekend.Tue: 1&gt;, &#x27;Wed&#x27;: &lt;Weekend.Wed: 2&gt;, &#x27;Thr&#x27;: &lt;Weekend.Thr: 3&gt;, &#x27;Fri&#x27;: &lt;Weekend.Fri: 4&gt;, &#x27;Sat&#x27;: &lt;Weekend.Sat: 5&gt;, &#x27;Sun&#x27;: &lt;Weekend.Sun: 6&gt;&#125;&gt;&gt;&gt; type(Weekend.__members__)&lt;class &#x27;mappingproxy&#x27;&gt; 枚举比较枚举成员并非整型，而是一种映射类型，是不能做大小比较的当时可以做相等比较 12345678&gt;&gt;&gt; Weekend.Mon == Weekend.MonTrue&gt;&gt;&gt; Weekend.Mon == Weekend.TueFalse&gt;&gt;&gt; Weekend.Mon != Weekend.TueTrue&gt;&gt;&gt; Weekend.Mon == 0False 限定枚举唯一性限定枚举唯一性是指 限制枚举类中的枚举成员 的 名称和值都不重复 限定枚举唯一性非常简单导入 unique类，然后在自定义的枚举类前加上装饰器 @unique 1234567891011from enum import Enum, unique@uniqueclass Weekend: Mon = 0 Tue = 1 Wed = 2 Thr = 3 Fri = 4 Sat = 5 Sun = 6","categories":[{"name":"Python","slug":"Python","permalink":"https://www.boii.xyz/categories/Python/"},{"name":"OPP","slug":"Python/OPP","permalink":"https://www.boii.xyz/categories/Python/OPP/"}],"tags":[{"name":"Python","slug":"Python","permalink":"https://www.boii.xyz/tags/Python/"}]},{"title":"Python【No-13】魔术方法","slug":"Python【No-13】魔术方法","date":"2020-07-19T02:41:48.000Z","updated":"2021-05-22T13:37:47.740Z","comments":true,"path":"2020/07/19/Python【No-13】魔术方法/","link":"","permalink":"https://www.boii.xyz/2020/07/19/Python%E3%80%90No-13%E3%80%91%E9%AD%94%E6%9C%AF%E6%96%B9%E6%B3%95/","excerpt":"魔术方法即类的内置方法","text":"魔术方法即类的内置方法 __str__() 触发时机:使用print(对象)或者str(对象)的时候触发参数：一个self接收对象返回值：必须是字符串类型作用：print（对象时）进行操作，得到字符串，通常用于快捷操作调用方式：print(obj) 另外，还有一个与__str__()相同的子方法：__repr__()，效果一样，适用于调试时，区别在于&gt;&gt;&gt; print(obj) 时调用的是 __str__()&gt;&gt;&gt; obj 时调用的是 __repr__() 12345678910111213141516171819202122232425// Javapublic class Person&#123; String name = &quot;&quot;; int age = 0; public Person(String name, int age)&#123; this.name = name; this.age = age; &#125; ... public String toString() &#123; return &quot;name: &quot; + this.name + &quot;, age: &quot; + this.age; &#125;&#125;Person p = new Person(&quot;Boii&quot;, 18);system.out.println(p);// Output:// name: Boii, age: 18 123456789101112131415161718# Pythonclass Person: def __init__(self, name, age): self.name = name self.age = age def __str__(self): return &quot;name: &quot; + self.name + &quot;, age: &quot; + self.age __repr__ = __str__ # 偷懒写法p = Person(&quot;Boii&quot;, 18)print(p)# Output:# name: Boii, age: 18 __call__() 调用对象的魔术方法触发时机:将对象当作函数调用时触发 对象()参数:至少一个self接收对象，其余根据调用时参数决定返回值：根据情况而定作用：可以将复杂的步骤进行合并操作，减少调用的步骤，方便使用调用方式：obj() 123456789101112131415161718192021222324252627class Athlete: def prepare(self): print(&#x27;The athlete is preparing...&#x27;) def warm_up(self): print(&#x27;The athlete is warming up...&#x27;) def attend(self): print(&#x27;The athlete attended.&#x27;) def run(self): print(&#x27;The athlete ran.&#x27;) def __call__(self): self.prepare() self.warm_up() self.attend() self.run()athlete = Athlete()athlete()# Output:The athlete is preparing...The athlete is warming up...The athlete attended.The athlete ran. 示例中只是简单调用自身函数，实际过程中可能会有更多如开启线程，调用别的类等复杂操作 很多时候，需要判断一个对象能否被调用，能被调用的对象就是一个Callable函数，和带有 __call__()的类对象就是Callable可以通过 callable(obj)来判断一个对象是否可以被调用 __iter__() 调用对象的魔术方法触发时机：对象被用于 for...in参数：至少一个self接收对象返回值：根据情况而定作用：使类具有可迭代的能力调用方式：for...in obj 如果一个类想被用于for … in循环，类似list或tuple那样，就必须实现一个__iter__()方法，该方法返回一个迭代对象，然后，Python的for循环就会不断调用该迭代对象的__next__()方法拿到循环的下一个值，直到遇到StopIteration错误时退出循环。 以斐波那契数列为例，写一个Fib类，可以作用于for循环： 12345678910111213141516171819202122232425class Fib(object): def __init__(self): self.a, self.b = 0, 1 # 初始化两个计数器a，b def __iter__(self): return self # 实例本身就是迭代对象，故返回自己 def __next__(self): self.a, self.b = self.b, self.a + self.b # 计算下一个值 if self.a &gt; 100000: # 退出循环的条件 raise StopIteration() return self.a # 返回下一个值&gt;&gt;&gt; for n in Fib():... print(n)...11235...4636875025 __getitem__()__getattr__() 触发时机：获取不存在的对象成员时触发参数：1接收当前对象的self，一个是获取成员名称的字符串返回值：必须有值作用:为访问不存在的属性设置值注意：getattribute无论何时都会在getattr之前触发，触发了getattribute就不会在触发getattr了","categories":[{"name":"Python","slug":"Python","permalink":"https://www.boii.xyz/categories/Python/"},{"name":"OPP","slug":"Python/OPP","permalink":"https://www.boii.xyz/categories/Python/OPP/"}],"tags":[{"name":"Python","slug":"Python","permalink":"https://www.boii.xyz/tags/Python/"}]},{"title":"Python【No-12】私有化","slug":"Python【No-12】私有化","date":"2020-07-18T02:41:48.000Z","updated":"2021-05-22T13:37:47.740Z","comments":true,"path":"2020/07/18/Python【No-12】私有化/","link":"","permalink":"https://www.boii.xyz/2020/07/18/Python%E3%80%90No-12%E3%80%91%E7%A7%81%E6%9C%89%E5%8C%96/","excerpt":"类的私有化","text":"类的私有化 Python 是动态语言，可以在程序运行过程中动态地给class加上属性或方法。这种不加以节制的特性很容易造成烂代码一堆。对此 Python 提供了一些解决方案。 slots 变量绑定白名单 __slots__ = (attributes_of_tuple)写在类变量处attributes_of_tuple是个元组，元组中每一个元素要用string型。 123class ClsName: __slots__ = (&#x27;name&#x27;, &#x27;age&#x27;) ... 示例，在交互模式中： 1234567891011# 没有白名单，可以随意绑定属性&gt;&gt;&gt; class Person:... pass...&gt;&gt;&gt; p = Person()&gt;&gt;&gt; p.name = &#x27;Boii&#x27;&gt;&gt;&gt; p.age = 18&gt;&gt;&gt; p.score = 100&gt;&gt;&gt; print(p.name, p.age, p.score)Boii 18 100 123456789101112# 使用了白名单，只能绑定白名单上的属性&gt;&gt;&gt; class Person:... __slots__ = (&#x27;name&#x27;, &#x27;age&#x27;)...&gt;&gt;&gt; p = Person()&gt;&gt;&gt; p.name = &#x27;Boii&#x27; # 白名单中的属性，可以绑定&gt;&gt;&gt; p.age = 18 # 白名单中的属性，可以绑定&gt;&gt;&gt; p.score = 100 # 白名单中没有的属性，绑定失败# 白名单中没有 score，所以绑定失败Traceback (most recent call last): File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;AttributeError: &#x27;Person&#x27; object has no attribute &#x27;score&#x27; 示例，在模块文件中： 12345678910111213class Person: __slots__ = (&#x27;score&#x27;, &#x27;gender&#x27;) def __init__(self, name, age): self.name = name self.age = age# 白名单中没有 name 和 age，所以连创建对象都会失败person = Person(&#x27;Boii&#x27;, 20)# Output:AttributeError: &#x27;Person&#x27; object has no attribute &#x27;name&#x27; 1234567891011121314151617181920212223class Person: __slots__ = (&#x27;name&#x27;, &#x27;age&#x27;, &#x27;score&#x27;, &#x27;gender&#x27;) def __init__(self, name, age): self.name = name self.age = agep = Person(&#x27;Boii&#x27;, 20)print(p.name, p.age)p.name = &#x27;Kali&#x27; # 白名单中存在，可以修改p.age = 30 # 白名单中存在，可以修改p.score = 100 # 白名单中存在，可以绑定p.gender = &#x27;male&#x27; # 白名单中存在，可以绑定print(p.name, p.age, p.score, p.gender)# Output:Boii 20Kali 30 100 male 使用__slots__要注意，__slots__定义的属性仅对当前类实例起作用，对继承的子类是不起作用的除非在子类中也定义__slots__，这样，子类实例允许定义的属性就是自身的__slots__加上父类的__slots__。 @property当一个类中有不想给外界随便访问或修改的属性时，可以将该变量变成 private 型的例如 __age = 18 这样的属性只能在类中访问和修改，外界要进行访问和修改只能通过类中的getter、setter方法。例如： 12345678910111213141516class Person: def __init__(self, age): self.__age = age def get_age(self): return self.__age def set_age(self, value): if value &gt; 0 and value &lt; 200: self.__age = valuep = Person(20)print(p.get_age()) # 20p.set_age(18)print(p.get_age()) # 18 通过 getter、setter ，在访问和修改的时候比较麻烦，要通过调用方法。使用 装饰器@property 则可以比较方便，像变量一样去访问和修改 使用方法1234567891011121314151617181920class ClsName: def __init__(self, attributeName): self.__attributeName = attributeName # 要先写getter @property def attributeName(self): return self.__attributeName # 再写setter @attributeName.setter def attributeName(self, value): self.__attributeName = valuecls = ClsName()print(cls.attributeName) # 访问cls.attributeName = value # 修改 现在改写上面 Person 类的例子： 12345678910111213141516171819class Person: def __init__(self, age): self.__age = age @property def age(self): return self.__age @age.setter def age(self, value): if value &gt; 0 and value &lt; 200: self.__age = valuep = Person(18)print(p.age) # 18p.age = 20print(p.age) # 20","categories":[{"name":"Python","slug":"Python","permalink":"https://www.boii.xyz/categories/Python/"},{"name":"OPP","slug":"Python/OPP","permalink":"https://www.boii.xyz/categories/Python/OPP/"}],"tags":[{"name":"Python","slug":"Python","permalink":"https://www.boii.xyz/tags/Python/"}]},{"title":"Python【No-11】类和对象","slug":"Python【No-11】类和对象","date":"2020-07-17T02:41:48.000Z","updated":"2021-05-22T13:37:47.740Z","comments":true,"path":"2020/07/17/Python【No-11】类和对象/","link":"","permalink":"https://www.boii.xyz/2020/07/17/Python%E3%80%90No-11%E3%80%91%E7%B1%BB%E5%92%8C%E5%AF%B9%E8%B1%A1/","excerpt":"模具和产品：类和对象","text":"模具和产品：类和对象 封装、继承、多态 Class 类就像模具，用模具制作出来的产品叫做对象 123456789101112131415161718192021222324252627# 不带继承的类class ClsName: # 类名 # 静态字段，通过类访问 print(ClsName.name), 在内存中只保存一份 name = &#x27;&#x27; age = 0 # public类变量，任何区域都能访问 _weight = 0 # protected类变量，当前类和子类和同一模块中才能访问 __height = 0 # private类变量，只有当前类才能访问 # 构造方法 def __init__(self,[para1[, para2[, paraN]): &quot;&quot;&quot; 这里是类文档 &quot;&quot;&quot; # 普通字段，通过实例来访问 print(clsInstance.para1), 每个实例中都保存 self.para1 = para1 self.para2 = para2 # 类方法 def method(self): &quot;&quot;&quot; 这里是方法注释 &quot;&quot;&quot; &lt;statement&gt; # 类的私有方法 def __private_method(self): &lt;statement&gt;# 继承了别的类的类class ClsName(BaseClsName1[, Base2[, Base3[, BaseN]): # 括号内是这个类所继承的父类 &lt;statement&gt; self这是方法和函数的区别之处：不管是什么方法都要有self这个参数，再写其他参数这个self是唯一的不可缺少的，它等价于java 和 C++中的this但是调用方法的时候不需要给它赋值当这样调用对象的方法时：myobject.method(arg1,arg2)，解释器会解释为MyClass.method(myobject, arg1, arg2)，这就是方法的自动传值 类变量 VS 对象变量类变量或者说静态字段都是一个东西。（类变量 == 静态字段、类属性）对象变量或者说普通字段也都是一个东西。（对象变量 == 普通字段、实例属性） 顾名思义，类变量就是属于类的变量对象变量就是属于对象（实例）的变量 差别定义： 123456789class Person: # 类变量、静态字段、类属性 eyes = 2 nose = 1 def __init__(self, name, age): # 对象变量、普通字段、实例属性 self.name = name self.age = age 实例化： 12345678910111213# 创建两个对象（实例化）p1 = Person(&#x27;Boii&#x27;, 20)p2 = Person(&#x27;Cai&#x27;, 18)# 访问静态变量print(Person.eyes) # 2 通过类名访问print(p1.eyes) # 2 通过对象访问print(p2.nose) # 1 通过对象访问# 访问对象变量print(p1.name) # Boiiprint(p2.name) # Cai 修改类变量以后： 12345# 修改静态变量Person.eyes = 1print(p1.eyes) # 1print(p2.eyes) # 1 12345# 修改对象变量p1.age = 50print(p1.age) # 50print(p2.age) # 18, 改了对象A的，对象B是不受影响的 类变量，是属于类的，存在类那块内存中，类变量被该类创建出来的对象共享。例如上图中，最上面的表格中就是类本身占的内存，其中就有类变量 eyes 和 nose下面两个小表格就是对象 p1 和 p2 各自占的空间，其中就保存着对象变量 name，age 修改类变量 eyes 和 nose 后，对象 p1 和 p2 去访问 eyes 和 nose 就会访问到修改后的值修改对象变量 name 或 age 后，对象之间互不影响。 假设一个类创建了两个对象A 和 B这时内存中其实是有三块空间的，一块是类的，一块是对象A的，一块是对象B的。 当通过类名.类变量访问的时候，是访问类那块内存里的类变量的当通过类名.类变量修改的时候，是修改类那块内存里的类变量的 当通过对象.类变量访问的时候，是系统跑去类那块内存里访问类变量的当通过对象.类变量修改的时候，是系统跑去类那块内存里复制类变量到对象那块内存里的 此时通过类名.类变量修改，再通过对象.类变量访问，其实访问的是对象自己内存里的那个类变量 1234567891011121314151617181920212223242526272829303132333435363738class Person: # 类变量、静态字段 eyes = 2 def __init__(self, name, age): self.name = name self.age = age# 创建两个对象p1 = Person(&#x27;Boii&#x27;, 20)p2 = Person(&#x27;Cai&#x27;, 18)# 通过类 访问静态变量print(Person.eyes) # 2# 通过对象 访问静态变量print(p1.eyes) # 2print(p2.eyes) # 2### 通过类 修改静态变量Person.eyes = 1# 再通过类 访问静态变量print(Person.eyes) # 1# 再通过对象 访问静态变量print(p1.eyes) # 1print(p2.eyes) # 1### 通过对象 修改对象变量p1.eyes = 50# 再通过类 访问静态变量print(Person.eyes) # 1# 再通过对象 访问静态变量print(p1.eyes) # 50 此时personA的内存里已经有eyes这个变量了print(p2.eyes) # 1 注意 p1 中 已经多了一个 eyes 的变量了 另外但是注意，如果静态变量是字典 dict，则不管怎么访问怎么修改，得到的都是一致的 看下面的例子类变量中有一个字典类型 d 123456789class Person: # 类变量、静态字段 eyes = 2 d = &#123;1: &#x27;A&#x27;, 2: &#x27;B&#x27;&#125; def __init__(self, name, age): # 对象变量、普通字段 self.name = name self.age = age 创建两个对象，然后通过对象修改类变量，和通过对象修改字典类型类变量 123456789101112# 创建两个对象p1 = Person(&#x27;Boii&#x27;, 20)p2 = Person(&#x27;Cai&#x27;, 18)# 通过类 修改静态变量, 改动的是类空间里的eyesPerson.eyes = 1# 通过对象 修改静态变量, 是复制一份eyes到对象空间里并修改p1.eyes = 3# 通过对象 修改静态字典变量, 并不会复制一份d到对象空间里p1.d[1] = 50 可以看到通过类名修改后，类空间里的eyes被修改了通过对象修改类变量之后，对象空间里多了一个 eyes 变量并且已经修改了通过对象修改字典类型类变量之后，没有复制一份，而是修改了类空间里字典的值 小结 类变量，又称静态字段、类属性 对象变量，又称普通字段、实例属性 类变量是所有对象共有的，对象变量是对象自己独有的 类变量可以通过 类名.类变量、对象.类变量访问 类变量可以通过 类名.类变量、对象.类变量修改 通过 对象.类变量 修改时，除非该类变量是字典类型，否则都会把类变量复制一份到对象中去 实例方法、类方法、静态方法实例方法 最普通最常用的方法。类中定义的非私有的方法，每个对象在被创建以后都有自己的实例方法。 定义：第一个参数必须是实例对象，该参数名一般约定为“self”，通过它来传递实例的属性和方法（也可以传类的属性和方法）； 如`p1.instanceMethod()`，Python 解释器会把对象 p1 传给self参数 调用：只能由实例对象调用。 1234567891011121314class Person: ... ... # 定义实例方法 def walk(self, step): return f&quot;I walked &#123;step&#125; steps.&quot;p1 = Person()print(p1.walk(5)) # 调用实例方法-------------------------------Output:I walked 5 steps. 类方法 @classmethod 属于类的方法，和类变量一样，所有对象共享类方法 定义：使用装饰器@classmethod。第一个参数必须是当前类对象，该参数名一般约定为“cls”，通过它来传递类的属性和方法（不能传实例的属性和方法）； 如p1.clsMethod 或 Person.clsMethod，Python解释器会把类 Person 传给 cls 参数 调用：类对象或实例对象都可以调用。 12345678910class Person: __count = 0 def __init__(self): Person.__count += 1 ... ... @classmethod def get_count(cls): return cls.__count 静态方法 @staticmethod用来存放逻辑性的代码，逻辑上属于类，但是和类本身没有关系，即，在静态方法中，不会涉及到类中的属性和方法的操作。可以理解为静态方法是个独立的、单纯的函数，仅仅托关于某个类的名称空间中，便于使用和维护。 定义：使用装饰器@staticmethod。参数随意，没有“self”和“cls”参数，但是方法体中不能使用类或实例的任何属性和方法； 调用：类对象或实例对象都可以调用。 构造方法 def __init__(self)就是类的构造方法 构造方法的形参可以有1~N个。而参数self是必选的首个的，这个self相当于this。self可以换成其他，但是为避免争议和歧义，最好用self 对于一个对象，可以自由的增加属性或者说对象变量、普通字段，但是通过构造方法，可以强制要求在实例化对象时传入必须的参数。 1234567891011121314class Animal: def __init__(self): passanimalA = Animal() # self 不需要传入animalA.weigth = 180 # 可以自由的增加对象属性class Person: def __init__(self, name, age): passpersonA = Person(&#x27;Boii&#x27;, 20) # 创建对象时必须给 name 和 agepersonB = Person() # ！！错误 访问限制 不加下划线，仅变量名/方法名 = public，任何区域都可以访问一条下划线+变量名/方法名 = protected，当前类和子类和同一模块才可以访问两条下划线+变量名/方法名 = private， 当前类才可以访问 12345678910111213# public 示例class Person: def __init__(self, name): self.name = name # public 属性 def show(self): print(self.name) # 类内部可以访问person = Person(&#x27;Boii&#x27;)print(person.name) # Boii 类外部也可以访问 1234567891011121314151617181920212223242526272829303132333435# protected 示例## Person.py beginclass Person: def __init__(self, name): self._name = name # protected 属性 def show(self): print(self._name) # 当前类中可以访问person = Person(&#x27;Boii&#x27;)person.show() # Boii## Person.py end## Student.py beginfrom Person import Personclass Student(Person): def __init__(self, name, age): super().__init__(name) # 在子类中通过 super().__init__() 访问 self.age = age def show(self): print(f&#x27;姓名：&#123;self._name&#125;, 年龄：&#123;self.age&#125;&#x27;)student = Student(&#x27;Boii&#x27;, 20)student.show() # 姓名：Boii, 年龄：20## Student.py end 1234567891011121314151617181920212223242526# private 示例class Person: def __init__(self, name): self.__name = name def show(self): print(self.__name) def get_name(self): return self.__name def set_name(self, name): self.__name = nameperson = Person(&#x27;Boii&#x27;)print(person.__name) # 错误！！只能在类中访问私有变量print(person.get_name()) # Boii, 通过get方法访问person.set_name(&#x27;Alice&#x27;) # 通过set方法改变print(person.get_name()) # Alice private变量实际上是因为 python解释器对外把 __name 改成了 _Person__name，依然可以通过person._Person__name来访问，但是强烈建议不要这么做。 点击查看更多关于访问限制、私有化的问题 封装、继承和多态 面向对象三大特性：封装、继承、多态封装把一类东西共通的属性、行为定义在一个类中，就是封装。 继承一个类，继承了别的类以后，这个类叫做子类被继承的类，叫做基类、父类、超类继承以后，子类就拥有了父类的全部 非private 功能Python中，子类可以同时继承多个父类 多态在子类中编写与父类同名的方法，叫做方法重写，适用于父类功能不能满足子类要求时。这称之为多态当父类子类的方法相同时，总是会优先调用子类的方法 123456789101112131415161718class Animal: def run(self): print(&#x27;Running---&#x27;)class Dog(Animal): # 继承父类 Animal passclass Cat(Animal): # 继承父类 Animal def run(self): # 方法重写 print(&#x27;Cat is Running---&#x27;)dog = Dog()dog.run() # Running---cat = Cat()cat.run() # Cat is Running--- 继承 class ClsName(BaseClass)在继承中，父类和子类都有的方法（同名的方法），会优先调用子类的；子类没有的，才调用父类的子类中不定义构造方法__init__()，会调用父类的构造方法__init__() 单继承在单继承中：如果父类构造方法有参数，则子类必须有构造方法，并调用父类的构造方法且传参 1234567891011121314# 子类没有__init__，默认调用父类的__init__# 父类的__init__没有参数，所以子类可以不写__init__class Person: def __init__(self): self.name = &quot;Anonymity&quot; self.age = 18class Student(Person): passs = Student() 1234567891011121314# 父类的__init__有参数，子类必须有__init__，并调用父类的__init__且传参class Person: def __init__(self, name): self.name = nameclass Student(Person): def __init__(self, name, age): self.age = age super().__init__(name)s = Student(&quot;Boii&quot;, 18) 多继承在多继承中：如果子类没有__init__()，会调用第一个父类的__init__()如果第一个父类没有__init__()，会找第二个父类，以此类推… 其中，只要任何一个父类的__init__()有参数，子类就必须有__init__()来调用父类的__init__() 如果有超过一个父类的__init__()有参数，则应该写作 BaseClsName.__init__(self, paras) 或 BaseClsName(type, obj).__init__(paras) 123456789101112131415161718192021class BaseA: def __init__(self, name, age): self.name = name self.age = ageclass BaseB: def __init__(self, gender, nationality): self.gender = gender self.nationality = nationalityclass Student(BaseA, BaseB): def __init__(self, name, age, gender, nationality): BaseA(Student, self).__init__(name, age) BaseB.__init__(self, gender, nationality)s = Student(&quot;Boii&quot;, 18, &quot;male&quot;, &quot;China&quot;) 钻石继承 菱形继承是指：子类 sub 继承了 父类 A，B，而父类 A，B又共同继承了祖父类 Base 12345 [Base] ↗ ↖[A] [B] ↖ ↗ [sub] 由于Python的机制，解释器在创建 sub类对象时会找到 A 的 构造方法，接着找到 Base 的构造方法然后再找 B 的构造方法，接着找到 Base 的构造方法，这样等于重复调用了 Base 的构造方法 1234567891011121314151617181920212223242526272829303132class Base: def __init__(self): print(&quot;Base.__init__&quot;)class A(Base): def __init__(self): Base.__init__(self) print(&quot;A.__init__&quot;)class B(Base): def __init__(self): Base.__init__(self) print(&quot;B.__init__&quot;)class sub(A, B): def __init__(self): A.__init__(self) B.__init__(self) print(&quot;sub.__init__&quot;)sub()# Output:Base.__init__A.__init__Base.__init__B.__init__sub.__init__ Base 的 __init__()被调用了两次 这时候可以改写 sub，A，B 的 __init__()为super().__init__ 123456789101112131415161718192021222324252627282930class Base: def __init__(self): print(&quot;Base.__init__&quot;)class A(Base): def __init__(self): super().__init__() print(&quot;A.__init__&quot;)class B(Base): def __init__(self): super().__init__() print(&quot;B.__init__&quot;)class sub(A, B): def __init__(self): super().__init__() print(&quot;sub.__init__&quot;)sub()# Output:Base.__init__B.__init__A.__init__sub.__init__ 多态的好处如上示例，多态使得继承之后还可以进行扩展，但是多态还有另一个好处。 示例中，Animal 是父类，Dog 和 Cat 是子类。Animal 是 Animal 类型；Dog 是 Dog 类型，也是 Animal 类型；Cat 同理 12345678910111213141516&gt;&gt;&gt; animal = Animal()&gt;&gt;&gt; dog = Dog()&gt;&gt;&gt; cat = Cat()&gt;&gt;&gt; isinstance(animal, Animal)True&gt;&gt;&gt; isinstance(dog, Dog)True&gt;&gt;&gt; isinstance(dog, Animal)True&gt;&gt;&gt; isinstance(cat, Cat)True&gt;&gt;&gt; isinstance(cat, Animal)True&gt;&gt;&gt; isinstance(animal, Dog)False 一句话总结就是，对象的类型是自身类+父类，而所有类都自动继承自 object类 因为这个特性，使得python更加灵活 假设现在有个函数，这个函数接受一个animal类型对象 123def run_twice(animal): animal.run() animal.run() 在调用的时候： 123456789101112131415&gt;&gt;&gt; animal = Animal()&gt;&gt;&gt; dog = Dog()&gt;&gt;&gt; cat = Cat()&gt;&gt;&gt; run_twice(animal)Running---Running---&gt;&gt;&gt; run_twice(cat)Cat is Running---Cat is Running---&gt;&gt;&gt; run_twice(dog)Running---Running--- 可以发现，这个接受Animal类型的函数，不仅可以接受Animal类及其子类的对象，还可以根据传入对象的不同实现不同的效果即使再定义一个类继承Animal，然后创建对象传入 run_twice()，依然可以实现相同的效果，而且不需要改动run_twice() 同理，所有的类都继承自object，如果是run_twice(object)，则可以接受任何类型的对象所以，对于一个变量，只需要知道其父类Animal，就可以放心的使用，在调用时animal.run()是作用在animal还是dog还是cat，由运行时该对象的确切类型决定。 调用方只管调用，不管细节。每当新增一种Animal子类时，只要确保run()方法编写正确，不用管run_twice()怎么实现。这就是&lt;开闭原则&gt;: 对扩展开放：允许新增Animal子类； 对修改封闭：不需要修改依赖Animal类型的run_twice()等函数 多态在静态语言和动态语言中的区别多态的这种特性在动态语言和静态语言中还有些区别. 像java这种静态语言，run_twice(Animal)传入的对象必须是Animal类型或其子类，否则无法调用run()方法。而python这种动态语言，则不一定要传入Animal类型，只需要保证传入的对象有一个run()方法就可以。这就是动态语言的“鸭子类型”，它并不要求严格的继承体系，一个对象只要“看起来像鸭子，走起路来像鸭子”，那它就可以被看做是鸭子。 123class Timer: def run(self): print(&#x27;Start---&#x27;) 像这个类，没有继承Animal，但依然可以传给run_twice(Animal)。 示例： 12345678910111213141516171819202122232425262728class Animal(object): # 编写Animal类 def run(self): print(&quot;Animal is running...&quot;)class Dog(Animal): # Dog类继承Amimal类，没有run方法 passclass Cat(Animal): # Cat类继承Animal类，有自己的run方法 def run(self): print(&#x27;Cat is running...&#x27;) passclass Car(object): # Car类不继承，有自己的run方法 def run(self): print(&#x27;Car is running...&#x27;)class Stone(object): # Stone类不继承，也没有run方法 passdef run_twice(animal): animal.run() animal.run()run_twice(Animal())run_twice(Dog())run_twice(Cat())run_twice(Car())run_twice(Stone()) 输出： 12345678910Animal is running...Animal is running...Animal is running...Animal is running...Cat is running...Cat is running...Car is running...Car is running...AttributeError: &#x27;Stone&#x27; object has no attribute &#x27;run&#x27;","categories":[{"name":"Python","slug":"Python","permalink":"https://www.boii.xyz/categories/Python/"},{"name":"OPP","slug":"Python/OPP","permalink":"https://www.boii.xyz/categories/Python/OPP/"}],"tags":[{"name":"Python","slug":"Python","permalink":"https://www.boii.xyz/tags/Python/"}]},{"title":"Python【No-20】操作文件和目录","slug":"Python【No-20】操作文件和目录","date":"2020-07-16T08:41:48.000Z","updated":"2021-05-22T13:37:47.740Z","comments":true,"path":"2020/07/16/Python【No-20】操作文件和目录/","link":"","permalink":"https://www.boii.xyz/2020/07/16/Python%E3%80%90No-20%E3%80%91%E6%93%8D%E4%BD%9C%E6%96%87%E4%BB%B6%E5%92%8C%E7%9B%AE%E5%BD%95/","excerpt":"文件正常操作","text":"文件正常操作 Python的自带模块 os 可以进行许多与操作系统相关的操作。 例如查看当前系统类型 123&gt;&gt;&gt; import os&gt;&gt;&gt; os.name&#x27;nt&#x27; nt表示windows，posix表示Linux/Unix/Mac OS X 在Linux/Unix/Max OS X上想获得更详细的信息，可以使用uname()，不过在windows上不提供 123&gt;&gt;&gt; import os&gt;&gt;&gt; os.uname()posix.uname_result(sysname=&#x27;Darwin&#x27;, nodename=&#x27;MichaelMacPro.local&#x27;, release=&#x27;14.3.0&#x27;, version=&#x27;Darwin Kernel Version 14.3.0: Mon Mar 23 11:59:05 PDT 2015; root:xnu-2782.20.48~5/RELEASE_X86_64&#x27;, machine=&#x27;x86_64&#x27;) 再例如查看环境变量，os.environ 123&gt;&gt;&gt; import os&gt;&gt;&gt; os.environenviron(&#123;&#x27;ALLUSERSPROFILE&#x27;: &#x27;C:\\\\ProgramData&#x27;, &#x27;APPDATA&#x27;: &#x27;C:\\\\Users\\\\pr919\\\\AppData\\\\Roaming&#x27;, &#x27;ASL.LOG&#x27;: &#x27;Destination=file&#x27;, &#x27;CATALINA_HOME&#x27;: &#x27;D:\\\\---Programming---\\\\IntelliJ IDEA\\\\apache-tomcat-8.5.42&#x27;, ..., &#x27;WT_SESSION&#x27;: &#x27;245de0da-1ef4-4cda-93ca-c132289e2c9c&#x27;&#125;) 这样就列出了所有环境变量了 如果要获得某一条，可以用os.environ.get(&#39;key&#39;) 123&gt;&gt;&gt; import os&gt;&gt;&gt; os.environ.get(&#x27;JAVA_HOME&#x27;)&#x27;C:\\\\Program Files\\\\Java\\\\jdk1.8.0_201&#x27; 获得当前目录 getcwd os.getcwd() 123&gt;&gt;&gt; import os&gt;&gt;&gt; os.getcwd()&#x27;C:\\\\Users\\\\pr919&#x27; 列出目录 listdir、walk os.listdir(path)，单层列出；path可以是绝对路径或相对路径，不填默认当前目录os.walk(path)，遍历列出； listdir() 列出path下一层的目录和文件，不包括子目录 12345678910111213141516171819202122232425&gt;&gt;&gt; import os&gt;&gt;&gt; os.listdir()&gt;&gt;&gt; os.listdir(r&#x27;D:\\---Programming---\\Python\\Python&#x27;)[&#x27;DLLs&#x27;, &#x27;Doc&#x27;, &#x27;include&#x27;, &#x27;Lib&#x27;, &#x27;libs&#x27;, &#x27;LICENSE.txt&#x27;, &#x27;NEWS.txt&#x27;, &#x27;python-3.8.3-amd64.exe&#x27;, &#x27;python.exe&#x27;, &#x27;python3.dll&#x27;, &#x27;python38.dll&#x27;, &#x27;pythonw.exe&#x27;, &#x27;Scripts&#x27;, &#x27;tcl&#x27;, &#x27;Tools&#x27;, &#x27;vcruntime140.dll&#x27;, &#x27;vcruntime140_1.dll&#x27;]&gt;&gt;&gt; for i in os.listdir(r&#x27;D:\\---Programming---\\Python\\Python&#x27;):... print(i)...DLLsDocincludeLiblibsLICENSE.txtNEWS.txtpython-3.8.3-amd64.exepython.exepython3.dllpython38.dllpythonw.exeScriptstclToolsvcruntime140.dllvcruntime140_1.dll walk() 列出path下的目录和文件，包括子目录 1234567891011121314151617181920212223242526272829303132import oscwd = os.getcwd()for i in os.walk(cwd): print(i, end=&#x27;\\n\\n&#x27;)--------------------------------------------------# Output:(&#x27;D:\\\\Project&#x27;, [&#x27;weather&#x27;, &#x27;__pycache__&#x27;], [&#x27;app.config&#x27;, &#x27;io.txt&#x27;, &#x27;mo.py&#x27;, &#x27;mo2.py&#x27;, &#x27;my.log&#x27;, &#x27;test.py&#x27;])(&#x27;D:\\\\Project\\\\weather&#x27;, [&#x27;.idea&#x27;, &#x27;__pycache__&#x27;], [&#x27;city_code.csv&#x27;, &#x27;city_code.txt&#x27;, &#x27;query.py&#x27;, &#x27;Ui_weather.py&#x27;, &#x27;weather.py&#x27;, &#x27;weather.ui&#x27;])(&#x27;D:\\\\Project\\\\weather\\\\.idea&#x27;, [&#x27;inspectionProfiles&#x27;], [&#x27;misc.xml&#x27;, &#x27;modules.xml&#x27;, &#x27;weather.iml&#x27;, &#x27;workspace.xml&#x27;])(&#x27;D:\\\\Project\\\\weather\\\\.idea\\\\inspectionProfiles&#x27;, [], [&#x27;Project_Default.xml&#x27;])(&#x27;D:\\\\Project\\\\weather\\\\__pycache__&#x27;, [], [&#x27;query.cpython-37.pyc&#x27;, &#x27;Ui_weather.cpython-37.pyc&#x27;])(&#x27;D:\\\\Project\\\\__pycache__&#x27;, [], [&#x27;mo.cpython-38.pyc&#x27;, &#x27;Person.cpython-38.pyc&#x27;]) os.walk(path)返回的是一个生成器 generator每次返回一个元组，元组中共有三个元素：(root, dirs, files) 第一个root是一个string，表示当前层的路径 第二个dirs是一个list，表示当前层拥有的目录 第三个files是一个list，表示当前层拥有的文件 创建目录 mkdir、makedirs os.mkdir(path)，创建单层目录；path可以是相对路径或绝对路径如果目录已存在，会抛出FileExistsError错误。 1234# 标准创建目录流程dirpath = &#x27;iodir&#x27;if not os.path.exists(dirpath): os.mkdir(dirpath) os.makedirs(dir/subdir)，创建多层目录；如果目录已存在，会抛出FileExistsError错误。 1234# 创建多层目录dirpath = &#x27;iodir/subiodir&#x27;if not os.path.exists(dirpath): os.makedirs(dirpath) 删除目录 rmdir、shutil.rmtree os.rmdir(path)，删除空目录；path可以说相对路径或绝对路径如果目录不存在，会抛出FileNotFoundError错误。如果目录不为空，会抛出OSError错误。 12345678910111213141516# 标准删除目录流程import osdirpath = &#x27;iodir&#x27;if os.path.exists(dirpath): os.rmdir(dirpath)--------------------------------------------------# Output:没任何输出，删除目录成功目录下不为空，输出：Traceback (most recent call last): ...OSError: [WinError 145] 目录不是空的。: &#x27;iodir&#x27; shutil,rmtree(path)，删除非空目录；如果目录不存在，会抛出FileNotFoundError错误。 iodir下有一个io.txt文件，执行shuitl.rmtree()如下 123456789101112131415import os, shuitldirpath = &#x27;iodir&#x27;if os.path.exists(dirpath): shuitl.rmtree(dirpath)--------------------------------------------------# Output:没任何输出，删除目录成功目录不存在，输出：Traceback (most recent call last): ...FileNotFoundError: [WinError 3] 系统找不到指定的路径。: &#x27;iodir&#x27; 删除文件 os.remove(filename)；删除单个文件 12345import osfilename = &#x27;io.txt&#x27;if os.path.exists(filename): os.remove(filename) 路径拼接 join os.path.join()不用的操作系统路径分隔符是不同的例如在windows下是\\，在Linux/Unix/Mac OS X下是/所以保险起见，在拼接路径的时候用os提供的os.path.join()函数。这样在不同操作系统中运行代码的时候都可以得到正确的路径拼接。 123456789101112import osdir = os.path.join(&#x27;gpdir&#x27;, &#x27;padir&#x27;, &#x27;subdir&#x27;)print(dir)--------------------------------------------------# Output in windows:gpdir\\padir\\subdir# Output in Linux/Unixgpdir/padir/subdir 路径拆分 split os.path.split()返回值是一个双元素元组，第一个元素是路径的前部分，第二个元素是最后级别的目录或文件名 12345&gt;&gt;&gt; os.path.split(&#x27;gpdir\\padir\\subdir&#x27;)(&#x27;gpdir\\\\padir&#x27;, &#x27;subdir&#x27;)&gt;&gt;&gt; os.path.split(&#x27;gpdir/padir/subdir&#x27;)(&#x27;gpdir/padir&#x27;, &#x27;subdir&#x27;) 获取文件扩展名 splitext os.path.splitext()返回值是一个双元素元组，第一个元素是路径前部分，第二个元素是最后级别文件的扩展名 1234567891011&gt;&gt;&gt; os.path.splitext(&#x27;gpdir/padir/subdir/io.txt&#x27;)(&#x27;gpdir/padir/subdir/io&#x27;, &#x27;.txt&#x27;)&gt;&gt;&gt; os.path.splitext(&#x27;gpdir/padir/subdir&#x27;)(&#x27;gpdir/padir/subdir&#x27;, &#x27;&#x27;)&gt;&gt;&gt; os.path.splitext(&#x27;gpdir\\padir\\subdir\\io.txt&#x27;)(&#x27;gpdir\\\\padir\\\\subdir\\\\io&#x27;, &#x27;.txt&#x27;)&gt;&gt;&gt; os.path.splitext(&#x27;gpdir\\padir\\subdir&#x27;)(&#x27;gpdir\\\\padir\\\\subdir&#x27;, &#x27;&#x27;) 文件、目录重命名 os.rename(oldName, newName)可以对文件或目录进行重命名 123&gt;&gt;&gt; .rename(&#x27;testdir&#x27;, &#x27;newtestdir&#x27;)&gt;&gt;&gt; os.rename(&#x27;test.txt&#x27;, &#x27;iotest.py&#x27;) 判断是目录还是文件 os.path.isdir(path)os.path.isfile(path) 示例列出当前目录下所有目录 12&gt;&gt;&gt; [x for x in os.listdir() if os.path.isdir(x)][&#x27;.lein&#x27;, &#x27;.local&#x27;, &#x27;.m2&#x27;, &#x27;.npm&#x27;, &#x27;.ssh&#x27;, &#x27;.vim&#x27;, &#x27;Applications&#x27;, &#x27;Desktop&#x27;, ...] 列出当前目录下所有.py文件 12&gt;&gt;&gt; [x for x in os.listdir() if os.path.isfile(x) and os.path.splitext(x)[1] == &#x27;.py&#x27;][&#x27;apis.py&#x27;, &#x27;config.py&#x27;, &#x27;models.py&#x27;, &#x27;test_db.py&#x27;, &#x27;urls.py&#x27;, &#x27;wsgiapp.py&#x27;]","categories":[{"name":"Python","slug":"Python","permalink":"https://www.boii.xyz/categories/Python/"},{"name":"进阶","slug":"Python/进阶","permalink":"https://www.boii.xyz/categories/Python/%E8%BF%9B%E9%98%B6/"},{"name":"IO","slug":"Python/进阶/IO","permalink":"https://www.boii.xyz/categories/Python/%E8%BF%9B%E9%98%B6/IO/"}],"tags":[{"name":"Python","slug":"Python","permalink":"https://www.boii.xyz/tags/Python/"}]},{"title":"Python【No-19】文件读写","slug":"Python【No-19】文件读写","date":"2020-07-16T07:41:48.000Z","updated":"2021-05-22T13:37:47.723Z","comments":true,"path":"2020/07/16/Python【No-19】文件读写/","link":"","permalink":"https://www.boii.xyz/2020/07/16/Python%E3%80%90No-19%E3%80%91%E6%96%87%E4%BB%B6%E8%AF%BB%E5%86%99/","excerpt":"文件基本操作","text":"文件基本操作 同步和异步的区别就在于是否等待IO执行的结果。好比你去麦当劳点餐，你说“来个汉堡”，服务员告诉你，对不起，汉堡要现做，需要等5分钟，于是你站在收银台前面等了5分钟，拿到汉堡再去逛商场，这是同步IO。 你说“来个汉堡”，服务员告诉你，汉堡需要等5分钟，你可以先去逛商场，等做好了，我们再通知你，这样你可以立刻去干别的事情（逛商场），这是异步IO。 很明显，使用异步IO来编写程序性能会远远高于同步IO，但是异步IO的缺点是编程模型复杂。想想看，你得知道什么时候通知你“汉堡做好了”，而通知你的方法也各不相同。如果是服务员跑过来找到你，这是回调模式，如果服务员发短信通知你，你就得不停地检查手机，这是轮询模式。总之，异步IO的复杂度远远高于同步IO。 文件读写其实都是由操作系统完成的，现代操作系统是不允许普通程序直接操作磁盘的，所以读写文件就是请求操作系统打开一个文件对象（又称：文件描述符），通过操作系统提供的接口从这个文件对象中读取数据或写入数据 同步IO12&gt;&gt;&gt; with open(file_path, &#x27;r/w/a&#x27;) as alias:··· do sth r ：读w ：覆盖写a+：追加写 读 read读取的过程：1. 打开文件；2. 读取文件；3. 关闭文件 第一步：f = open(&#39;/user/boii/io_note.txt&#39;, &#39;r&#39;) 用python内置的open()函数打开一个文件对象， 第一个参数传入读的文件的路径，第二个参数传入r为读取的意思 如果打开成功，open()会返回一个文件对象； 如果打开失败，open()会抛出一个IOError错误。 第二步：f.read() 通过read()方法，可以将全部内容读取出来。 第三步：f.close() 文件打开成功后，必须使用close()方法关闭文件。 因为文件对象会占用操作系统资源，且操作系统同一时间能打开的文件数量也有限。 文件打开失败后，会产生IOError，则不会调用f.close() 综合起来可以这么写： 12345678910111213try: f = open(&#x27;/user/boii/io_note.txt&#x27;, &#x27;r&#x27;) # 打开文件 print(f.read()) # 读取文件except IOError as e: print(e)else: f.close() # 关闭文件--------------------------------------------------# Output:# 如果文件打开成功，会输出（文件全部内容）：io# 如果文件打开失败，会输出：[Errno 2] No such file or directory: &#x27;/user/boii/io_note.txt&#x27; 但是这样太繁琐，一点也不符合Python优雅的气质。所以 Python 引入了with语句来自动帮我们调用close()方法 12with open(&#x27;/user/boii/io_note.txt&#x27;, &#x27;r&#x27;) as f: print(f.read()) 指定字节 read(size) file_obj.read(size) read()方法不填写参数，直接读取文件全部内容。如果一个文件太大，全部读取会爆内存的。所以可以通过指定 size 的方式指定读取 size 个字节的内容。 12345678910111213141516# io.txtHello Python!I am Boii.I am learning.--------------------------------------------------# io_read.pywith open(&#x27;io.txt&#x27;, &#x27;r&#x27;) as f: data = f.read(8) # 读取前8个字节 print(data)--------------------------------------------------# Output:Hello Py 跳过字节 seek(size) file_obj.seek(size) 通过 seek()可以在读取之前跳过 size 个字节，再开始读取 1234567891011121314151617# io.txtHello Python!I am Boii.I am learning.--------------------------------------------------# io_read.pywith open(&#x27;io.txt&#x27;, &#x27;r&#x27;) as f: f.seek(3) data = f.read(8) # 读取前8个字节 print(data)--------------------------------------------------# Output:lo Pytho 读取一行 readline() file_obj.readline() readline()方法会读取文件的一行，遇到\\n就认为是一行 1234567891011121314151617# io.txtHello Python!I am Boii.I am learning.--------------------------------------------------# io_read.pywith open(&#x27;io.txt&#x27;, &#x27;r&#x27;) as f: data = f.readline() # 读取第一行 print(data)--------------------------------------------------# Output:Hello Python! 这样只能读取一行，可以使用 while 循环一行一行的读取 1234567891011121314151617181920# io.txtHello Python!I am Boii.I am learning.--------------------------------------------------# io_read.pywith open(&#x27;io.txt&#x27;, &#x27;r&#x27;) as f: data = f.readline() # 读取第一行 while data: print(data, end=&#x27;&#x27;) data = f.readline() # 接着读下一行--------------------------------------------------# Output:Hello Python!I am Boii.I am learning. 读取多行 readlines() file_obj.readlines() readlines()方法会一次性读取文件中多行内容，最后返回一个 list，一个元素一行内容。 12345678910111213141516171819# io.txtHello Python!I am Boii.I am learning.--------------------------------------------------# io_read.pywith open(&#x27;io.txt&#x27;, &#x27;r&#x27;) as f: datas = f.readlines() # 读取多行 for line in datas: print(line, end=&#x27;&#x27;)--------------------------------------------------# Output:Hello Python!I am Boii.I am learning. 效果是一样的。 写 write写入的过程：1. 打开文件；2. 写入文件；3. 关闭文件 写入同样可以使用with语句，with语句自动会关闭文件读文件的时候如果文件不存在，会抛出 IOError 错误写文件的时候如果文件不存在，会创建文件 写入有两种，一种是覆盖原有内容写入新内容；一种是在原有内容基础上追加新内容。覆盖写在open()函数中要传入 w，追加写在open()函数中要传入a 写入单行 wirte()12345678910111213# io_write.pycontend = &#x27;&#x27;&#x27;I am the contend which be writed down into file.Hello Python!&#x27;&#x27;&#x27;with open(&#x27;io.txt&#x27;, &#x27;w&#x27;) as f: f.write(contend) # 写入文件--------------------------------------------------# io.txtI am the contend which be writed down into file.Hello Python! 写入多行 writelines() file_obj.writelines(str) 当有多行要写入的时候，除了上面用 &#39;&#39;&#39;的多行字符串，可以用 writelines(list)来将内容一次写入。第一个参数接受的是一个 list 列表 或 string 字符串 12345678910# io_write.pydatas = [&#x27;Hello Python!&#x27;, &#x27;I am Boii&#x27;, &#x27;I like coding&#x27;]with open(&#x27;io.txt&#x27;, &#x27;w&#x27;) as f: f.writelines(datas) # 写入文件--------------------------------------------------# io.txtHello Python!I am BoiiI like coding 跟预设结果不一样，并没有换行符。可以直接给datas的每个元素加上\\n但是这种办法很费力，且很多时候内容不是你决定的，这时候 列表生成式 就排上用场了。 12345678910111213# io_write.pydatas = [&#x27;Hello Python!&#x27;, &#x27;I am Boii&#x27;, &#x27;I like coding&#x27;]with open(&#x27;io.txt&#x27;, &#x27;w&#x27;) as f: new_datas = [line + &#x27;\\n&#x27; for line in datas] f.writelines(new_datas) # 写入文件--------------------------------------------------# io.txtHello Python!I am BoiiI like coding 追加写1234567891011121314151617# io_write.pycontend = &#x27;&#x27;&#x27;I am the contend which be writed down into file.Hello Python!&#x27;&#x27;&#x27;with open(&#x27;io.txt&#x27;, &#x27;a&#x27;) as f: f.write(contend) # 写入文件--------------------------------------------------# io.txt 第一次执行I am the contend which be writed down into file.Hello Python!# io.txt 第二次执行I am the contend which be writed down into file.Hello Python!I am the contend which be writed down into file.Hello Python! 打开模式打开模式有很多，大致分为： 字符 意义 r 读取（默认） w 覆盖写 a 追加写 x 排他性创建，如果文件已存在则失败 b 二进制模式 t 文本模式（默认） + 可读可写 表中的字符组合起来就有丰富的打开方式r只读，r+可读可写，rb只读一个二进制文件（图片音视频等）w只覆盖写，w+可读可覆盖写，wb只覆盖写一个二进制文件a只追加写，a+可读可追加写，以此类推 字符编码要读取非UTF-8编码的文件，需要给open()函数传入encoding参数 例如打开一个GBK编码的文件 123&gt;&gt;&gt; with open(&#x27;io.txt&#x27;, &#x27;r&#x27;, encoding=&#x27;gbk&#x27;) as f:··· print(f.read())Hello Python! 但有时候打开的文件编码不规范，混杂了多种编码的字符，而打开时只能按一种编码打开，所以势必会造成乱码。这种乱码的处理可以用 errors参数。 open(filepath, mode, encoding=&#39;value&#39;, errors=&#39;value&#39;)errors参数的值有 ignore：直接忽略 strict：引发ValueError异常。与默认值None效果相同 replace_sign：会将错误的地方替换为指定的replace_sign符号 其他","categories":[{"name":"Python","slug":"Python","permalink":"https://www.boii.xyz/categories/Python/"},{"name":"进阶","slug":"Python/进阶","permalink":"https://www.boii.xyz/categories/Python/%E8%BF%9B%E9%98%B6/"},{"name":"IO","slug":"Python/进阶/IO","permalink":"https://www.boii.xyz/categories/Python/%E8%BF%9B%E9%98%B6/IO/"}],"tags":[{"name":"Python","slug":"Python","permalink":"https://www.boii.xyz/tags/Python/"}]},{"title":"Python【No-18】协程","slug":"Python【No-18】协程","date":"2020-07-16T06:41:48.000Z","updated":"2021-05-22T13:37:47.723Z","comments":true,"path":"2020/07/16/Python【No-18】协程/","link":"","permalink":"https://www.boii.xyz/2020/07/16/Python%E3%80%90No-18%E3%80%91%E5%8D%8F%E7%A8%8B/","excerpt":"协程，时间管理大师","text":"协程，时间管理大师 线程是系统级别的，由操作系统调度协程是程序级别的，由程序根据需要自己调度 协程可以想象成线程里的线程，也就是将一个线程里多个任务分拆给多个协程。 使用线程的时候是：线程执行遇到耗时（阻塞）的地方，再开一个线程，去执行这个耗时的任务，原本的线程继续执行。就好比我在算题，算着算着计算量比较大比较耗时，我就叫了小明帮我算，我继续算下面的。 使用协程的时候是：利用别的协程执行耗时操作时的那点时间切换去别的协程继续执行，也就是在协程之间反复横跳。就好比我在算题，算着算着计算量有点大，就先做别的题，回头自己再继续把题算完 协程的优点： 无需线程上下文切换的开销，因为都在同一个线程里，避免了无意义的调度，由此可以提高性能。 无需原子操作锁定及同步的开销 方便切换控制流，简化编程模型 高并发+高扩展性+低成本：一个CPU支持上万个协程都不是问题。所以很适合高并发处理。 缺点： 因为协程都是程序调度的，所以需要程序员承担调度的责任，同时也失去了标准线程使用多CPU的能力 无法利用多核资源：协程的本质是个单线程，不能同时用上单个CPU的多个核。协程需要和进程配合才能运行在多CPU上，不过绝大部分应用都没有这个必要，除非是CPU密集型应用 进行阻塞操作（如IO）会阻塞掉整个程序。 使用 yield 实现并发123456789101112131415161718192021222324252627282930313233343536373839404142import time def task_1(): while True: print(&quot;&#123;:-^16s&#125;&quot;.format(&quot;task_1&quot;)) time.sleep(0.1) yielddef task_2(): while True: print(&quot;&#123;:-^16s&#125;&quot;.format(&quot;task_2&quot;)) time.sleep(0.1) yielddef main(): t1 = task_1() t2 = task_2() # 先让t1运行一会儿，当t1中遇到yield的时候，再返回到main()的while循环 # 然后执行t2，当它遇到yield的时候，再次切换到t1中 # 就这样t1/t2/t1/t2...交替运行，最终实现了多任务...协程 while True: next(t1) next(t2)if __name__ == &#x27;__main__&#x27;: main()--------------------------------------------------# Output:-----task_1----------task_2----------task_1----------task_2----------task_1----------task_2----------task_1----------task_2----------task_1----------task_2-----... 使用 greenlet 实现并发&gt;_: pip install greenlet 123456789101112131415161718192021222324252627282930313233343536from greenlet import greenletimport timedef task_1(): while True: print(&quot;&#123;:-^16s&#125;&quot;.format(&quot;task_1&quot;)) gr2.switch() # 切换到 gr2中，也就是 task_2() 中运行 time.sleep(0.5)def task_2(): while True: print(&quot;&#123;:-^16s&#125;&quot;.format(&quot;task_2&quot;)) gr1.switch() # 切换到 gr1中，也就是 task_1() 中运行 time.sleep(0.5)gr1 = greenlet(task_1)gr2 = greenlet(task_2)# 切换到 gr1中，也就是 task_1() 中运行gr1.switch--------------------------------------------------# Output:-----task_1----------task_2----------task_1----------task_2----------task_1----------task_2----------task_1----------task_2----------task_1----------task_2-----... 使用 gevent 实现并发 import geventgevent.spawn(funcName, args) 先看看没有阻塞操作的时候： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950# 没有阻塞import geventdef task_1(n): for i in range(n): print(gevent.getcurrent(), i)def task_2(n): for i in range(n): print(gevent.getcurrent(), i)def task_3(n): for i in range(n): print(gevent.getcurrent(), i)def main(): g1 = gevent.spawn(task_1, 5) g2 = gevent.spawn(task_2, 5) g3 = gevent.spawn(task_3, 5) g1.join() g2.join() g3.join()if __name__ == &#x27;__main__&#x27;: main()--------------------------------------------------# Output:&lt;Greenlet at 0x1f6eaf0cd00: task_1(5)&gt; 0&lt;Greenlet at 0x1f6eaf0cd00: task_1(5)&gt; 1&lt;Greenlet at 0x1f6eaf0cd00: task_1(5)&gt; 2&lt;Greenlet at 0x1f6eaf0cd00: task_1(5)&gt; 3&lt;Greenlet at 0x1f6eaf0cd00: task_1(5)&gt; 4&lt;Greenlet at 0x1f6eaf0ce10: task_2(5)&gt; 0&lt;Greenlet at 0x1f6eaf0ce10: task_2(5)&gt; 1&lt;Greenlet at 0x1f6eaf0ce10: task_2(5)&gt; 2&lt;Greenlet at 0x1f6eaf0ce10: task_2(5)&gt; 3&lt;Greenlet at 0x1f6eaf0ce10: task_2(5)&gt; 4&lt;Greenlet at 0x1f6eaf0cbf0: task_3(5)&gt; 0&lt;Greenlet at 0x1f6eaf0cbf0: task_3(5)&gt; 1&lt;Greenlet at 0x1f6eaf0cbf0: task_3(5)&gt; 2&lt;Greenlet at 0x1f6eaf0cbf0: task_3(5)&gt; 3&lt;Greenlet at 0x1f6eaf0cbf0: task_3(5)&gt; 4 gevent 是利用协程阻塞的时候去执行别的协程这里没有阻塞操作，所以并不会发生什么变化，跟普通函数调用一样，更提不上并发 现在来加点阻塞操作看看 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455# 有阻塞import geventdef task_1(n): for i in range(n): print(gevent.getcurrent(), i) # time.sleep(0.1) # 在gevent中，time.sleep()这种阻塞操作是不起作用的 gevent.sleep(0.1)def task_2(n): for i in range(n): print(gevent.getcurrent(), i) gevent.sleep(0.1)def task_3(n): for i in range(n): print(gevent.getcurrent(), i) gevent.sleep(0.1)def main(): g1 = gevent.spawn(task_1, 5) g2 = gevent.spawn(task_2, 5) g3 = gevent.spawn(task_3, 5) g1.join() g2.join() g3.join()if __name__ == &#x27;__main__&#x27;: main()--------------------------------------------------# Output:&lt;Greenlet at 0x1433a62b370: task_1(5)&gt; 0&lt;Greenlet at 0x1433a62b590: task_2(5)&gt; 0&lt;Greenlet at 0x1433a62b480: task_3(5)&gt; 0&lt;Greenlet at 0x1433a62b370: task_1(5)&gt; 1&lt;Greenlet at 0x1433a62b590: task_2(5)&gt; 1&lt;Greenlet at 0x1433a62b480: task_3(5)&gt; 1&lt;Greenlet at 0x1433a62b370: task_1(5)&gt; 2&lt;Greenlet at 0x1433a62b590: task_2(5)&gt; 2&lt;Greenlet at 0x1433a62b480: task_3(5)&gt; 2&lt;Greenlet at 0x1433a62b370: task_1(5)&gt; 3&lt;Greenlet at 0x1433a62b590: task_2(5)&gt; 3&lt;Greenlet at 0x1433a62b480: task_3(5)&gt; 3&lt;Greenlet at 0x1433a62b370: task_1(5)&gt; 4&lt;Greenlet at 0x1433a62b590: task_2(5)&gt; 4&lt;Greenlet at 0x1433a62b480: task_3(5)&gt; 4 上述代码 建立了三个 gevent 对象，里面分别转载了 task_1、task_2、task_3 三个执行函数。接着三个 gevent 对象都使用 join 方法运行了执行函数在三个执行函数中又用了 gevent.sleep() 模拟阻塞操作（在实际开发中并不会专门用sleep去阻塞，而是在执行到 IO 等耗时操作时，gevent自动切换。） 在执行 task_1 的时候，打印了第一句，然后遇到了 gevent.sleep() 的阻塞操作，切换到 task_2 ，打印了第二局，又遇到阻塞，又切换…一直到全部执行完毕 另外，task_1 中的 time.sleep() 在 gevent 管理的协程中是不起作用的，需要使用 gevent.sleep() 才行。 这就带来一个问题：如果我的代码是开发完了才加入了 gevent ，那岂不是要把很多地方手动改到 gevent 能接受。还好 gevent 提供了一个补丁 gevent 补丁 from gevent import monkeymonkey.patch_all()一定要写在最上方 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556import timeimport geventfrom gevent import monkeymonkey.patch_all() # 打补丁def task_1(n): for i in range(n): print(gevent.getcurrent(), i) time.sleep(0.1)def task_2(n): for i in range(n): print(gevent.getcurrent(), i) time.sleep(0.1)def task_3(n): for i in range(n): print(gevent.getcurrent(), i) time.sleep(0.1)def main(): g1 = gevent.spawn(task_1, 5) g2 = gevent.spawn(task_2, 5) g3 = gevent.spawn(task_3, 5) g1.join() g2.join() g3.join()if __name__ == &#x27;__main__&#x27;: main()--------------------------------------------------# Output:&lt;Greenlet at 0x1433a62b370: task_1(5)&gt; 0&lt;Greenlet at 0x1433a62b590: task_2(5)&gt; 0&lt;Greenlet at 0x1433a62b480: task_3(5)&gt; 0&lt;Greenlet at 0x1433a62b370: task_1(5)&gt; 1&lt;Greenlet at 0x1433a62b590: task_2(5)&gt; 1&lt;Greenlet at 0x1433a62b480: task_3(5)&gt; 1&lt;Greenlet at 0x1433a62b370: task_1(5)&gt; 2&lt;Greenlet at 0x1433a62b590: task_2(5)&gt; 2&lt;Greenlet at 0x1433a62b480: task_3(5)&gt; 2&lt;Greenlet at 0x1433a62b370: task_1(5)&gt; 3&lt;Greenlet at 0x1433a62b590: task_2(5)&gt; 3&lt;Greenlet at 0x1433a62b480: task_3(5)&gt; 3&lt;Greenlet at 0x1433a62b370: task_1(5)&gt; 4&lt;Greenlet at 0x1433a62b590: task_2(5)&gt; 4&lt;Greenlet at 0x1433a62b480: task_3(5)&gt; 4 joinall有没有发现 g1.join()g2.join()g3.join() 写了三个join不如给他来个一次性 gevent.joinall(spawn_list, timeout=None, raise_error=False, count=None) 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455import timeimport geventfrom gevent import monkeymonkey.patch_all()def task_1(n): for i in range(n): print(gevent.getcurrent(), i) time.sleep(0.1)def task_2(n): for i in range(n): print(gevent.getcurrent(), i) time.sleep(0.1)def task_3(n): for i in range(n): print(gevent.getcurrent(), i) time.sleep(0.1)def main(): # joinall 接受一个 spawn 列表 gevent.joinall([ gevent.spawn(task_1, 5), gevent.spawn(task_2, 5), gevent.spawn(task_3, 5) ]， timeout=5)if __name__ == &#x27;__main__&#x27;: main()--------------------------------------------------# Output:&lt;Greenlet at 0x12e8cba9d00: task_1(5)&gt; 0&lt;Greenlet at 0x12e8cba9e10: task_2(5)&gt; 0&lt;Greenlet at 0x12e8cba9bf0: task_3(5)&gt; 0&lt;Greenlet at 0x12e8cba9d00: task_1(5)&gt; 1&lt;Greenlet at 0x12e8cba9e10: task_2(5)&gt; 1&lt;Greenlet at 0x12e8cba9bf0: task_3(5)&gt; 1&lt;Greenlet at 0x12e8cba9d00: task_1(5)&gt; 2&lt;Greenlet at 0x12e8cba9e10: task_2(5)&gt; 2&lt;Greenlet at 0x12e8cba9bf0: task_3(5)&gt; 2&lt;Greenlet at 0x12e8cba9d00: task_1(5)&gt; 3&lt;Greenlet at 0x12e8cba9e10: task_2(5)&gt; 3&lt;Greenlet at 0x12e8cba9bf0: task_3(5)&gt; 3&lt;Greenlet at 0x12e8cba9d00: task_1(5)&gt; 4&lt;Greenlet at 0x12e8cba9e10: task_2(5)&gt; 4&lt;Greenlet at 0x12e8cba9bf0: task_3(5)&gt; 4 只管在 joinall 里创建 spawn 对象就行，其他不用管，gevent 自己会处理好的这也是最常用的方法","categories":[{"name":"Python","slug":"Python","permalink":"https://www.boii.xyz/categories/Python/"},{"name":"进阶","slug":"Python/进阶","permalink":"https://www.boii.xyz/categories/Python/%E8%BF%9B%E9%98%B6/"},{"name":"进程、线程","slug":"Python/进阶/进程、线程","permalink":"https://www.boii.xyz/categories/Python/%E8%BF%9B%E9%98%B6/%E8%BF%9B%E7%A8%8B%E3%80%81%E7%BA%BF%E7%A8%8B/"}],"tags":[{"name":"Python","slug":"Python","permalink":"https://www.boii.xyz/tags/Python/"}]},{"title":"Python【No-17】线程","slug":"Python【No-17】线程","date":"2020-07-16T05:41:48.000Z","updated":"2021-05-22T13:37:47.723Z","comments":true,"path":"2020/07/16/Python【No-17】线程/","link":"","permalink":"https://www.boii.xyz/2020/07/16/Python%E3%80%90No-17%E3%80%91%E7%BA%BF%E7%A8%8B/","excerpt":"线程，是操作系统调度的单位","text":"线程，是操作系统调度的单位 一个程序写完了，放在硬盘里不运行，叫做程序一个程序写完了，放到内存里跑起来，叫做进程一个进程中至少有一个线程，称为主线程一个线程要干很多事情，有些事情很耗时，就创建个子线程，让子线程去做，主线程继续下一步 当有多个线程的时候，CPU会轮流切换执行，每个线程执行多长时间叫做时间片比如 t1 分到了0.001秒的时间片，t2 分到了0.002秒的时间片显然这么短时间是不够执行的，所以CPU会快速的切来切去，这样就看起来好像能执行多任务多任务就是你可以同时听歌、写文档、挂QQ等等，但其实同一时刻CPU只执行一个线程只不过切换的快，时间片也很小，所以人感觉不出来。 线程的执行顺序是由操作系统决定的，开发者左右不了。 子线程由主线程创建，子线程关闭后留下的辣鸡由主线程清理一旦主线程挂了，子线程全部挂掉。主线程会等待所有子线程结束后才结束 单线程操作 123456789101112131415161718192021222324252627282930313233343536import timedef say_hi(): for i in range(5): print(&#x27;Hi!&#x27;) time.sleep(1) # 耗时操作def say_yes(): for i in range(5): print(&#x27;Yes!&#x27;) time.sleep(1) # 耗时操作def main(): say_hi() say_yes()if __name__ == &#x27;__main__&#x27;: main()--------------------------------------------------# Output:Hi!Hi!Hi!Hi!Hi!Yes!Yes!Yes!Yes!Yes! 多线程操作 123456789101112131415161718192021222324252627282930313233343536373839import timeimport threading # 导入 threading 模块def say_hi(): for i in range(5): print(&#x27;Hi!&#x27;) time.sleep(1) # 耗时操作def say_yes(): for i in range(5): print(&#x27;Yes!&#x27;) time.sleep(1) # 耗时操作def main(): t1 = threading.Thread(target=say_hi) # 创建一个线程对象 t2 = threading.Thread(target=say_yes) # 创建一个线程对象 t1.start() # 启动线程 t2.start() # 启动线程if __name__ == &#x27;__main__&#x27;: main()--------------------------------------------------# Output:Hi!Yes!Hi!Yes!Hi!Yes!Yes!Hi!Hi!Yes! 单线程和多线程的区别就像这个栗子 你要来一段热舞rap， 单线程的操作是：rap完再热舞，或者热舞完再rap 多线程的操作是：边热舞边rap 创建子线程并启动创建线程操作可以分为三步： 导入 threading 模块 创建一个Thread对象 通过Thread对象启动线程 创建一个Thread对象的时候可以传入参数threading.Thread(group=None, target=None, name=None, args=(), kwargs=&#123;&#125;, *, daemon=None) group 应该为 None；为了日后扩展 ThreadGroup 类实现而保留。 target：线程中需要执行的函数。默认是 None，表示不需要调用任何方法。 name：线程名称。默认情况下，由 “Thread-N” 格式构成一个唯一的名称，其中 N 是小的十进制数。 args：用于调用目标函数的参数元组。默认是 ()。（必须是可迭代对象） kwargs：用于调用目标函数的关键字参数字典。默认是 {}。（必须是可迭代对象） daemon不是None，线程将被显式的设置为守护模式，不管该线程是否是守护模式。 daemon=None，线程将继承当前线程的守护模式属性。 如果子类重载了构造函数，必须先调用父类构造器Thread.__init__()，再做其他事情。 函数方式函数方式适合于 —— 一个线程中要做的事情比较少，一个函数就能搞定。 导入 threading 模块 创建一个Thread对象并把函数传进去 通过Thread对象启动线程 123456789import threading # 1. 导入 thrading 模块def funcName(): # 需要子线程执行的函数 passt1 = threading.Thread(target=funcName) # 2. 创建一个Thread对象并把函数传进去t1.start() # 3. 启动线程 继承方式继承方式适合于 —— 一个线程里面做的事情比较复杂，需要分成多个函数来做。 导入 threading 模块 创建一个类继承 Thread 类 重写 run 方法 创建一个继承了 Thread 类的对象 用start方法启动线程 12345678910import threading # 1. 导入 threading 模块class clsName(threading.Thread): # 2. 继承Thread类 def run(self): # 3. 重写run方法 print(self.name) # self.name 保存的是当前线程的名称t1 = clsName() # 4. 创建一个继承了 Thread 类的对象t1.start() # 5. 启动线程 t1.start()只会去调用run方法。如果类中还有其他方法，只能在类中调用，不能用 t1去调用。也就是说，继承了 Thread 的类的之类，除了run方法，其他方法都可以定义成私有的（公有的外面也不能调用啊） 12345678910111213141516171819202122232425import threadingclass MyThread(threading.Thread): def run(self): print(self.name) self.__say_hi() self.__say_yes() def __say_hi(self): print(&#x27;Hi!&#x27;) def __say_yes(self): print(&#x27;Yes!&#x27;)t1 = MyThread()t1.start()--------------------------------------------------# Output:Thread-1Hi!Yes! 插队 join() join([timeout])当某个线程对象成功调用了 join() 方法之后，会优先获得CPU的资源，让其他线程等待知道这个线程对象执行结束后，才把资源让给别的线程 1234567891011121314151617181920212223242526272829303132333435363738394041424344import threadingdef f1(n): for i in range(n): print(threading.current_thread().getName())def f2(n): for i in range(n): print(threading.current_thread().getName() + &quot;------&quot; + str(i))def main(): t1 = threading.Thread(target=f1, args=(5,)) t2 = threading.Thread(target=f2, args=(5,)) t1.start() t2.start() for i in range(5): print(threading.current_thread().getName())if __name__ == &#x27;__main__&#x27;: main()--------------------------------------------------# Output:Thread-1Thread-1MainThreadThread-2------0MainThreadThread-2------1MainThreadThread-2------2MainThreadMainThreadThread-2------3Thread-2------4Thread-1Thread-1Thread-1 可以看到，没有加 join 方法，所以主线程 和 t1 和 t2 相互争抢资源。如果现在需要 t1 这个线程执行完再给其他线程执行，也就是说要求 t1 独占一段时间那就让 t1 调用 join() 方法 123456789101112131415161718192021222324252627282930313233343536373839404142434445import threadingdef f1(n): for i in range(n): print(threading.current_thread().getName())def f2(n): for i in range(n): print(threading.current_thread().getName() + &quot;------&quot; + str(i))def main(): t1 = threading.Thread(target=f1, args=(5,)) t2 = threading.Thread(target=f2, args=(5,)) t1.start() t1.join() t2.start() for i in range(5): print(threading.current_thread().getName())if __name__ == &#x27;__main__&#x27;: main()--------------------------------------------------# Output:Thread-1Thread-1Thread-1Thread-1Thread-1Thread-2------0Thread-2------1MainThreadThread-2------2MainThreadThread-2------3MainThreadThread-2------4MainThreadMainThread 这样就实现了 t1 独占资源，完成后才给其他线程 查看所有线程 threading.enumerate()以列表形式返回当前所有存活的 Thread 对象。该列表包含守护线程，current_thread() 创建的虚拟线程对象和主线程。它不包含已终结的线程和尚未开始的线程。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546import timeimport threadingdef say_hi(): for i in range(3): print(&#x27;Hi!&#x27;) time.sleep(1)def say_yes(): for i in range(3): print(&#x27;Yes!&#x27;) time.sleep(1)def main(): t1 = threading.Thread(target=say_hi) t2 = threading.Thread(target=say_yes) t1.start() t2.start() while True: print(threading.enumerate()) if len(threading.enumerate()) &lt;= 1: break time.sleep(1)if __name__ == &#x27;__main__&#x27;: main()--------------------------------------------------# Output:Hi!Yes![&lt;_MainThread(MainThread, started 1292)&gt;, &lt;Thread(Thread-1, started 7968)&gt;, &lt;Thread(Thread-2, started 3796)&gt;][&lt;_MainThread(MainThread, started 1292)&gt;, &lt;Thread(Thread-1, started 7968)&gt;, &lt;Thread(Thread-2, started 3796)&gt;]Hi!Yes!Hi!Yes![&lt;_MainThread(MainThread, started 1292)&gt;, &lt;Thread(Thread-1, started 7968)&gt;, &lt;Thread(Thread-2, started 3796)&gt;][&lt;_MainThread(MainThread, started 1292)&gt;, &lt;Thread(Thread-1, started 7968)&gt;] 多线程共享全局变量假设现在有个任务，去抓取某个网站上所有的照片，然后发送到某个邮箱。这里就可以分成两个子任务，一个抓取照片，一个发送照片于是我们可以创建一个线程负责抓取照片，一个线程负责发送照片 那么可以发现，照片是两个线程都要用到的数据。所以我们应该把照片设置为全局变量，这样两个线程才可以进行合作。 在多线程任务中，全局变量是可以给每一个线程共享的。 123456789101112131415161718192021222324252627282930313233import threadingg_num = 10 # 全局变量def add1(): global g_num g_num += 5 print(&quot;add1----------- %d&quot; % g_num)def add2(): print(&quot;add2----------- %d&quot; % g_num)def main(): t1 = threading.Thread(target=add1, name=&#x27;add1&#x27;) t2 = threading.Thread(target=add2, name=&#x27;add2&#x27;) t1.start() t2.start() print(&quot;main----------- %d&quot; % g_num)if __name__ == &quot;__main__&quot;: main()--------------------------------------------------# Output:add1----------- 15add2----------- 15main----------- 15 从栗子中可以看出，线程t1中的add1对全局变量g_num进行了修改在线程t2的add2对g_num进行访问的时候访问到的是修改后的值在主线程的main方法中访问也是修改后的值。 所以：全局变量对于任何一个线程，包括主线程，来说都是共享的。 锁全局变量对于任何一个线程来说都是共享的，那就一定会引发争抢资源的情况，这是由CPU的运行机制导致的。如果对同一个全局变量，两个线程一个写一个读倒还好，但是如果两个同时写就会引发各种问题。特别是在银行、金融领域，会引发更大的问题。比如一边转了帐还没收到突然出现问题，转账的扣钱了，收账的没收到，那就凉凉了~ 所以为了解决这种缺陷，引入了锁的概念。举个栗子，很多人上一个厕所，前面的进去了得锁门吧？办完事了开锁出来后面的才能进去，上锁，办事儿。锁就是这样的概念。哪个线程先抢到锁哪个就先执行，执行完了释放锁，下一个线程抢到了就锁上…..这叫做同步控制 互斥锁 创建锁：mutex = threading.Lock()，默认没有上锁的锁定：mutex.acquire(blocking=True, timeout=1)解锁：mutex.release() acquire(blocking=True, timeout=1) 成功获得锁返回True，否则返回Flase blocking：设置为True时，会一直等到前面的锁释放然后锁定，设置为Flase则不会。 timeout：浮点型，单位——秒； 值为正数时，等待时长为设定的秒数 值为-1时，将无限等待 blocking=Flase时，timeout不起作用。 release() 锁被锁定时，重置为未锁定。锁没被锁定时，引发RuntimeError错误。 1234567891011121314151617181920212223242526272829303132333435363738394041424344import threadingimport timeg_num = 0mutex = threading.Lock()def add1(num): global g_num mutex.acquire() for i in range(num): g_num += 1 mutex.release() print(&quot;add1----------- %d&quot; % g_num)def add2(num): global g_num mutex.acquire() for i in range(num): g_num += 1 mutex.release() print(&quot;add2----------- %d&quot; % g_num)def main(): t1 = threading.Thread(target=add1, args=(1_000_000, )) t2 = threading.Thread(target=add2, args=(1_000_000, )) t1.start() t2.start() time.sleep(2) print(&quot;main----------- %d&quot; % g_num)if __name__ == &quot;__main__&quot;: main()--------------------------------------------------# Output:add1----------- 1000000add2----------- 2000000main----------- 2000000 死锁锁并非只有一个，可以有多个。有多个锁，就可能发生死锁。 举个栗子，电影里经常能看见的镜头——俩人打架不分上下，A锁住了B的脚踝，B锁住了A的脖子。A：你放开我B：你先放开我A：你放开我我就放开你B：你先放开我，我再放开你A：凭什么我先放B：那我也不放…2000 year later…两人死了。The end. 这就是死锁，互不相让，互相锁了对方需要的资源，都等着对方先释放 线程A上了A锁干活，线程B上了B锁，这是两把锁，所以相安无事。运行着运行着线程A需要一份资源，这份资源被线程B上了锁用着呢；线程B也需要一份资源，这份资源被线程A上了锁用着呢。这时候线程A和线程B都在等对方释放锁，就这么一直等一直等 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152import timeimport threadingclass ThreadLockA(theading.Thread): def run(self): mutexA.acquire() # 使用A锁上锁 print(self.name + &#x27;-----------doA--up--&#x27;) time.sleep(1) # 这里会上锁失败，因为上面 time.sleep(1)的时候B锁已经被上锁了 # 或者此线程后执行，A锁已经被上锁了，会上锁失败。 # 所以死锁会发生在这 mutexB.acquire() # 请求B锁上锁 print(self.name + &#x27;-----------doA--down--&#x27;) mutexB.release() mutexA.release() # 对A锁进行解锁class ThreadLockB(threading.Thread)； def run(self): mutexB.acquire() # 使用B锁上锁 print(self.name + &#x27;-----------doB--up--&#x27;) time.sleep(1) # 这里会上锁失败，因为上面 time.sleep(1)的时候A锁已经被上锁了 # 或者此线程后执行，A锁已经被上锁了，会上锁失败。 # 所以死锁会发生在这 mutexA.acquire() print(self.name + &#x27;-----------doB--down--&#x27;) mutexA.release() mutexB.release() # 对B锁进行解锁mutexA = threading.Lock()mutexB = threading.Lock()if __name__ == &#x27;__main__&#x27;: t1 = ThreadLockA() t2 = ThreadLockB() t1.start() t2.start()--------------------------------------------------# Output:-----------doA--up-------------doB--up--···这里已经卡死了 为了避免这种情况，又两种方法 程序设计时要尽量避免（使用银行家算法） 添加超时时间等","categories":[{"name":"Python","slug":"Python","permalink":"https://www.boii.xyz/categories/Python/"},{"name":"进阶","slug":"Python/进阶","permalink":"https://www.boii.xyz/categories/Python/%E8%BF%9B%E9%98%B6/"},{"name":"进程、线程","slug":"Python/进阶/进程、线程","permalink":"https://www.boii.xyz/categories/Python/%E8%BF%9B%E9%98%B6/%E8%BF%9B%E7%A8%8B%E3%80%81%E7%BA%BF%E7%A8%8B/"}],"tags":[{"name":"Python","slug":"Python","permalink":"https://www.boii.xyz/tags/Python/"}]},{"title":"Python【No-16】进程","slug":"Python【No-16】进程","date":"2020-07-16T04:41:48.000Z","updated":"2021-05-22T13:37:47.723Z","comments":true,"path":"2020/07/16/Python【No-16】进程/","link":"","permalink":"https://www.boii.xyz/2020/07/16/Python%E3%80%90No-16%E3%80%91%E8%BF%9B%E7%A8%8B/","excerpt":"进程，是资源分配的单位","text":"进程，是资源分配的单位 程序：例如xxx.py这是程序，是静态的进程：一个程序运行起来后，代码+用到的资源 称之为进程，它是操作系统分配资源的基本单元。 进程，是资源分配的单位线程，是操作系统调度的单位 进程的状态工作中，任务数往往大于CPU核心数，即一定有一些任何正在执行，而另外一些任务在等待CPU进行执行因此进程有不同的状态 进程的状态分为：新建、就绪、运行、等待（堵塞）、死亡 就绪态：运行的条件都已经具备，正在等在CPU执行 执行态：CPU正在执行其功能 等待态：等待某些条件满足；例如一个程序sleep了，就处于等待态 进程就好像流水线。一个进程就是一条流水线，每条流水线之间是相互独立的；流水线履带上的产品就是全局变量；流水线上的工人就是线程； 产品（全局变量）对于同一条流水线的工人（线程）来说是共享的，每个人都可以访问流水线（进程）之间是相互独立的，不能流水线A的产品可以被流水线B访问，那不就乱套了。 创建进程创建进程分为三步： 导入 multiprocessing 模块 创建一个 Process 对象 通过 Process 对象启动线程 创建一个 Process对象的时候可以传入参数multiprocessing.Process(group=None, target=None, name=None, args=(), kwargs=&#123;&#125;, *, daemon=None) 应始终使用关键字参数调用构造函数。 group：应该始终是 None ；它仅用于兼容 threading.Thread 。 target：是由 run() 方法调用的可调用对象。它默认为 None ，意味着什么都没有被调用。 name：是进程名称 args：是目标调用的参数元组。 kwargs：是目标调用的关键字参数字典。 daemon： 如果提供，则键参数 daemon 将进程 daemon 标志设置为 True 或 False 。 如果是 None （默认值），则该标志将从创建的进程继承。 如果子类重载了构造函数，必须先调用父类构造器Process.__init__()，再做其他事情。 1234567891011121314151617181920212223242526272829303132333435import multiprocessingimport timedef say_hi(): while True: print(&quot;Hi-------&quot;) time.sleep(1)def say_yes(): while True: print(&quot;Yes------&quot;) time.sleep(1)def main(): p1 = multiprocessing.Process(target=say_hi) p2 = multiprocessing.Process(target=say_yes) p1.start() p2.start()if __name__ == &#x27;__main__&#x27;: main()--------------------------------------------------# Output:Hi-------Yes------Hi-------Yes------Hi-------Yes------Hi-------... 进程间通信进程间的通信有很多中方式，比如通过带网络功能的socket，或者队列Queue 假设两个进程之间要通信，进程A向内存中的Queue放要通信的内容，进程B去Queue中取即可。进程是运行在内存中的，Queue也是运行在内存中的，所以速度很快。Queue对于进程来说是共享的。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687import multiprocessing as pdef download_from_web(q): &quot;&quot;&quot;下载数据&quot;&quot;&quot; # 模拟从网上下载的数据 data = [11, 22, 33, 44] # 向队列中写入数据 for temp in data: if not q.full(): # 如果队列未满 q.put(temp) # 通过 put 将内容放进队列 print(&quot;download: 下载完成并存入队列&quot;)def analysis_data(q): &quot;&quot;&quot;数据处理&quot;&quot;&quot; # 从队列中获取数据 data = list() # 模拟数据处理 while True: data.append(q.get()) # 通过 get 取队列中的内容 if q.empty(): # 如果队列为空则退出 break print(&quot;analysis:&quot;, data)def main(): # 1.创建一个队列 q = p.Queue(3) # 2.创建多个进程，将队列的应用当作实参传递到里面 p1 = p.Process(target=download_from_web, args=(q, )) p2 = p.Process(target=analysis_data, args=(q, )) p1.start() p2.start()if __name__ == &quot;__main__&quot;: main()def download_from_web(q): &quot;&quot;&quot;下载数据&quot;&quot;&quot; # 模拟从网上下载的数据 data = [11, 22, 33, 44] # 向队列中写入数据 for temp in data: q.put(temp) print(&quot;download: 下载完成并存入队列&quot;)def analysis_data(q): &quot;&quot;&quot;数据处理&quot;&quot;&quot; # 从队列中获取数据 data = list() # 模拟数据处理 while True: data.append(q.get()) if q.empty(): break print(&quot;analysis:&quot;, data)def main(): # 1.创建一个队列 q = p.Queue(3) # 2.创建多个进程，将队列的应用当作实参传递到里面 p1 = p.Process(target=download_from_web, args=(q, )) p2 = p.Process(target=analysis_data, args=(q, )) p1.start() p2.start()if __name__ == &quot;__main__&quot;: main()--------------------------------------------------# Output:download: 下载完成并存入队列analysis: [11, 22, 33, 44] q.put(obj[, block[, timeout]) obj：要传递的内容 block：阻塞，默认True True，队列满了以后会一直等待 Flase，队列满了之后会抛出queue.Full错误 timeout：浮点型，单位——秒，默认None； 值为正数时，等待时长为设定的秒数 值为-1时，将无限等待 blocking=Flase时，timeout不起作用。 如果队列关闭已经关闭会抛出ValueError（3.8+）q.put_nowait(obj)相当于q.put(block=Flase) q.get([block[, timeout]) block：阻塞，默认True True，队列空了以后会一直等待 Flase，队列空了之后会抛出queue.Empty错误 timeout：浮点型，单位——秒，默认None； 值为正数时，等待时长为设定的秒数 值为-1时，将无限等待 blocking=Flase时，timeout不起作用。 如果队列关闭已经关闭会抛出ValueError（3.8+）q.get_nowait()相当于q.get(block=Flase) 进程池进程的创建和消费是很耗费资源的，而实际情况中可能出现成千上百万个进程需要执行，这时候不可能每个进程都单独创建和销毁这些进程大同小异，但是进程的创建和销毁是相同的。于是我们可以把创建和销毁的工作抽取出来，通过更换进程的内容，以此达到较小开销的目的。这种技术叫做 进程池 进程池就好比公园里的湖，进程就好比船。你作为老板，今天来了一个人要划船，你去买一艘船，客人划完了你把船卖了。明天再来两个客人，你又去买两艘船，客人划完了你又把船卖了。万一来了一万个客人，你…没钱买船了哈哈哈。这是普通的进程使用方法。 你作为老板，先买好N艘船（开启进程池），来了一个客人，上船，用完了换你，下一个客人上去…等到哪天生意不做了关门，就把船一起卖掉关门（关闭进程池）。这是进程池的使用方法。省下了买船卖船（创建和销毁进程）的功夫。 进程池中最大容量能同时容纳多少个进程是由开发者指定的，具体多少个要经过测试人员压力测试以后得出一个合适的数量。当进程池创建以后，不会立即工作，而是等到有进程被创建了才开始工作。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455from multiprocessing import Poolimport osimport timeimport randomdef work(msg): print(&quot;Process-&#123;&#125; running, pid：&#123;&#125;&quot;.format(msg, os.getpid())) start = time.time() time.sleep(random.random() * 2) end = time.time() print(&quot;Process-&#123;&#125; finish, time consuming：&#123;:.2f&#125;&quot;.format(msg, end - start))def main(): po = Pool(3) # 定义一个进程池，最大进程数为3 for i in range(1, 11): # Pool.apply_async(要调用的目标, (传递给目标的参数元组,)) # 每次循环将会用空闲出来的子进程去调用目标 po.apply_async(work, (i, )) print(&quot;------start------&quot;) po.close() # 关闭进程池，关闭后po不在接收新的请求 po.join() # 等待po中所有子进程执行完后再关闭，必须放在close语句后 print(&quot;-------end-------&quot;)if __name__ == &#x27;__main__&#x27;: main()--------------------------------------------------# Output:------start------Process-1 running, pid：20364Process-2 running, pid：15912Process-3 running, pid：16504Process-2 finish, time consuming：1.01Process-4 running, pid：15912Process-3 finish, time consuming：1.03Process-5 running, pid：16504Process-4 finish, time consuming：0.17Process-6 running, pid：15912Process-5 finish, time consuming：0.23Process-7 running, pid：16504Process-1 finish, time consuming：1.50Process-8 running, pid：20364Process-6 finish, time consuming：1.43Process-9 running, pid：15912Process-8 finish, time consuming：1.65Process-10 running, pid：20364Process-9 finish, time consuming：0.55Process-7 finish, time consuming：1.99Process-10 finish, time consuming：0.20-------end------- 创建进程池创建进程池总共分步： 导入 multiprocessing 模块 创建一个 Pool 对象并指定最大进程数 使用apply()或apply_async()方法 使用close()方法停止接收进程 使用join()方法声明等待子进程完毕再关闭进程池","categories":[{"name":"Python","slug":"Python","permalink":"https://www.boii.xyz/categories/Python/"},{"name":"进阶","slug":"Python/进阶","permalink":"https://www.boii.xyz/categories/Python/%E8%BF%9B%E9%98%B6/"},{"name":"进程、线程","slug":"Python/进阶/进程、线程","permalink":"https://www.boii.xyz/categories/Python/%E8%BF%9B%E9%98%B6/%E8%BF%9B%E7%A8%8B%E3%80%81%E7%BA%BF%E7%A8%8B/"}],"tags":[{"name":"Python","slug":"Python","permalink":"https://www.boii.xyz/tags/Python/"}]},{"title":"Python【No-10】模块","slug":"Python【No-10】模块","date":"2020-07-16T02:41:48.000Z","updated":"2021-05-22T13:37:47.740Z","comments":true,"path":"2020/07/16/Python【No-10】模块/","link":"","permalink":"https://www.boii.xyz/2020/07/16/Python%E3%80%90No-10%E3%80%91%E6%A8%A1%E5%9D%97/","excerpt":"一个py文件就是一个模块","text":"一个py文件就是一个模块 模块 Module 一个 .py文件就称之为一个模块 module 好处： 提高了代码的可维护性； 可以被其他地方应用； 可以避免命名冲突。 importimport加载的模块分为四个通用类别： 使用python编写的代码（py文件）； 已被编译为共享库或DLL的C或C++扩展； 包好一组模块的包 使用C编写并链接到python解释器的内置模块. 包 Package 模块的上一级称为包 package 包是一个文件夹，可以通过包来组织模块，避免冲突。 一个包里必须含有一个__init__.py __init__.py可以是空文件，也可以有Python代码 __init__.py本身就算一个模块，它的模块名就是包名 包里面还可以有包 123456789101112MyPackage ├─ web │ ├─ __init__.py │ ├─ utils.py │ └─ test.py ├─ dirc │ ├─ utils.py │ └─ test.py │ ├─ __init__.py ├─ main.py └─ utils.py 顶层包为 MyPackage子包为 web普通目录 dirc （因为它没有__init__.py文件）test.py的模块名为MyPackage.web.testutils.py有两个，模块名分别为MyPackage.web.utils和MyPackage.utils 自己创建模块时注意命名不要与系统模块冲突要检查系统中是否存在该模块，可以在交互环境下执行 import abc，若成功说明系统存在此模块。 1234&gt;&gt;&gt; import aabbcccTraceback (most recent call last): File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;ModuleNotFoundError: No module named &#x27;aabbccc&#x27; 使用模块1234567891011121314151617181920212223#!/usr/bin/env python3# -*- coding: utf-8 -*-&quot;Here is the module documentation&quot;__author__ = &#x27;Boii&#x27;import sysdef test(): args = sys.argv if len(args) == 1: print(&#x27;Hello, world!&#x27;) elif len(args) == 2: print(&#x27;Hello, %s!&#x27; % args[1]) else: print(&#x27;Too many arguments!&#x27;)if __name__ == &#x27;__main__&#x27;: test() 标准模块文件模板 #!/usr/bin/env python3 是向Unix / Linux / Mac 系统声明本文件是Python3文件 # -*- coding: utf-8 -*- 表示本文件使用标准utf-8编码，虽然Python3之后默认支持中文，但为保稳妥还是写上 &quot;Here is the module documentation&quot;是模块文档注释，任何模块的第一个字符串都被视为模块的文档注释。可以通过模块名.__doc__获得。 __author__ = &#39;Boii&#39;是作者。可以通过模块名.__author__获得。 标准模块文件模板也可以不写，并不影响。 导入、参数列表、name import sys引入了内置模块sys args = sys.argv，这里sys.argv是参数列表，是一个 list，保存的是通过命令执行本文件的时候所带的参数。但该 list的第一个元素永远是文件名。 例如上面的文件名为Hello.py，则运行命令python Hello.py后sys,argv为[&#39;Hello.py&#39;]. 如果执行的命令为python Hello.py Boii，则sys.argv为[&#39;Hello.py&#39;, &#39;Boii&#39;] if __name__ == &#39;__main__&#39;: test()如果这个文件是独立运行的，则 if 为 True，如果这个文件是被导入的，则 if 为 False。 1234$ python Hello.pyHello, world!$ python Hello.py BoiiHello, Boii! ↑ 通过命令独立运行这个文件，所以 if 为 True，执行了 test() 函数 1234567$ pythonPython 3.8.3&gt;&gt;&gt;&gt;&gt;&gt; import Hello&gt;&gt;&gt;&gt;&gt;&gt; Hello.test()Hello, world! ↑ 通过导入的方式运行这个文件，所以 if 为 False，没有执行 test() 函数，等到 Hello.test() 主动调用时才执行了 test() 函数 总结一个 .py 文件就是一个模块 module一个带有 __init__.py 的文件夹就是一个包 package","categories":[{"name":"Python","slug":"Python","permalink":"https://www.boii.xyz/categories/Python/"},{"name":"OPP","slug":"Python/OPP","permalink":"https://www.boii.xyz/categories/Python/OPP/"}],"tags":[{"name":"Python","slug":"Python","permalink":"https://www.boii.xyz/tags/Python/"}]},{"title":"Python【No-15】进程线程总叙","slug":"Python【No-15】进程线程总叙","date":"2020-07-16T02:41:48.000Z","updated":"2021-05-22T13:37:47.723Z","comments":true,"path":"2020/07/16/Python【No-15】进程线程总叙/","link":"","permalink":"https://www.boii.xyz/2020/07/16/Python%E3%80%90No-15%E3%80%91%E8%BF%9B%E7%A8%8B%E7%BA%BF%E7%A8%8B%E6%80%BB%E5%8F%99/","excerpt":"进程是内存资源分配的单位线程是操作系统调度的单位，真正执行任务的是线程协程是线程中任务细分下来的单位","text":"进程是内存资源分配的单位线程是操作系统调度的单位，真正执行任务的是线程协程是线程中任务细分下来的单位 代码是由线程执行的线程必须在进程中运行线程可以拆分成多个协程 从图中可以看出一个进程中有1或多个线程，进程就像一个容器一样，是内存资源分配的单位线程是由操作系统调度的，把CPU计算资源给哪个线程使用是操作系统管的每个线程里或多或少有几个协程，这些是程序管理的 程序 &gt; 进程 &gt; 线程 &gt; 协程 代码写好了，躺在硬盘了，那叫程序 代码拿到内存里跑，那叫进程 程序觉得一个主进程不够，可以再开N个子进程 进程只是一个容器，需要干活的，所以得有线程 进程觉得一个主线程不够，可以再开N个子线程 线程觉得有很多耗时操作（如读写文件、网络请求），想把等待的时间利用起来做其他还没完成的任务，可以搞出很多个协程 这么多个概念，其被发明的目的都是为了更高效的利用计算机 在上古时代，单CPU-单核，在同一时间内只能做一件事情，不可能像现在这样又听歌又上网又写文档人们发现CPU的计算速度奇高，所以利用了时间片(就是短到人类无法发现的时长)多次切换运行程序，雨露均沾这样 单CPU-单核 也能实现多个任务同时进行。不过这只是看起来像是在同时运行，如果你能暂停时间，你会发现CPU只是在执行某一个程序而已。这种让CPU资源在程序之间反复横跳，从而实现多任务的技术，叫做并发 那如果我就是想要按下时间暂停按钮的时候，真的有多个程序在一起执行怎么办？再加个CPU咯。这叫并行 举个栗子现在有一个玩具厂，厂里面有2个车间：一个生产玩具，一个生产家电每个车间有N条流水线，每条流水线上有N个工人，每个工人都有各自的任务车间需要地方搭建，还需要电力供应 我们捋一捋关系： 发电机 -&gt; CPU厂 -&gt; 内存车间 -&gt; 进程流水线 -&gt; 线程工人 -&gt; 任务 车间没建起来，就像代码放在硬盘里，代码扔硬盘里不就叫程序么 把 车间 建到 厂房 里用起来，那些 车间 就成了 有用的车间把 代码 放到 内存 里跑起来，那些 代码 就成了 进程 车间 搭好了得有 流水线 来 组装产品啊进程 建好了还得有 线程 来 执行任务啊 所以每个车间至少有一条主流水线所以每个进程至少有一个主线程 车间 一开始只有一条主流水线做全部步骤，有天发现有个步骤特别麻烦进程 一开始只有一个主线程做所有事情，有天发现有个操作特别耗时 于是主流水线就再拉了一条副流水线来负责这个麻烦的步骤，自己继续下一步，再有麻烦步骤就继续加副流水线于是主线程开启一个子线程来负责这个耗时操作，主线程继续执行，再有耗时操作就继续加子线程 有一天单子太多，一条车间不够，那就加条副车间咯，再不够再加有一天计算量太大，一个进程不够，那就加个子进程咯，再不够再加 而且副车间得更主车间一模一样而且子进程得完全复制主进程，包括代码、状态等等 并且，一个车间挂了没事，不会影响其他车间并且，一个进程挂了没事，不会影响其他进程 那现在车间之间 要传递零件怎么办，搭个管子，直接溜过去，先放的别人就先拿到那现在进程之间要进行通信怎么办，用队列或者管道呗，先放的就先拿到 那流水线之间要传递东西怎么办？放车间的工具车上不就完了那线程之间要通信怎么办？用全局变量不就完了 流水线跟车间可不一样，要是哪条副流水线挂了是会影响整个车间的线程跟进程可不一样，要是哪个子线程挂了是会影响整个进程的 主流水线要是挂了，整个车间完犊子主线程要是挂了，整个进程完犊子 有的流水线就一个工人，有的流水线有多个工人，这个工人动作慢了，就把螺丝刀给别的工人先用有的线程就一个协程，有的线程有多个协程，这个协程阻塞了，就把运行权给别的协程 这种积极利用等待时间安排其他工人的模式，叫做高效利用时间这种积极利用等待时间做其他任务的形式，叫做协程 那现在发电机只有一个，生产玩具的车间要用，生产家电的车间要用，老板又想两个车间同时生产那现在CPU只有一个，进程A要用，进程B要用，用户又想两个进程使用运行 那就让发电机快速在两个车间之间快速切换，哪个车间有电了立马干活，没电了立马暂停那就让CPU资源在两个进程之间反复横跳，哪个进程被选中了立马运行，时间片到了立马暂停 因为速度非常快，所以老板看着以为两个车间都启动了因为速度非常快，所以用户真的以为两个任务同时运行，这叫并发 有一天老板发财，加了一台发电机，这下两个车间都有电了，真正的两个车间同时生产有一天用户发财，加了一个CPU，这下两个进程都有资源了，真正实现两个进程同时运行，这叫并行 进程占的资源比较大，但是安全，一个进程挂掉不会导致另外一个进程挂掉线程切换开销更小协程利用等待的时间做别的事，但是需要程序承担调度责任 在不考虑 GIL（全局锁）的情况下，优先用协程、再用线程、最后用进程","categories":[{"name":"Python","slug":"Python","permalink":"https://www.boii.xyz/categories/Python/"},{"name":"进阶","slug":"Python/进阶","permalink":"https://www.boii.xyz/categories/Python/%E8%BF%9B%E9%98%B6/"},{"name":"进程、线程","slug":"Python/进阶/进程、线程","permalink":"https://www.boii.xyz/categories/Python/%E8%BF%9B%E9%98%B6/%E8%BF%9B%E7%A8%8B%E3%80%81%E7%BA%BF%E7%A8%8B/"}],"tags":[{"name":"Python","slug":"Python","permalink":"https://www.boii.xyz/tags/Python/"}]},{"title":"Python【No-8】调试","slug":"Python【No-8】调试","date":"2020-07-15T02:41:48.000Z","updated":"2021-05-22T13:37:47.723Z","comments":true,"path":"2020/07/15/Python【No-8】调试/","link":"","permalink":"https://www.boii.xyz/2020/07/15/Python%E3%80%90No-8%E3%80%91%E8%B0%83%E8%AF%95/","excerpt":"开发的必经之路：调试","text":"开发的必经之路：调试 大型项目中，一般都是使用日志来调试程序。不过有时候有一小块代码想做调试的时候，可以用print和assert。 print &amp; assertprint() 就是常见的打印函数。 凡是用print()的地方都可以用 断言assert语句代替 1234567891011121314151617# 用printdef foo(s): n = int(s) if n == 0: print(&quot;n is zero!&quot;) else: return 10 / nfoo(&#x27;0&#x27;)--------------------------------------------------# Output:Traceback (most recent call last): ...ZeroDivisionError: division by zero 123456789101112131415# 用assertdef foo(s): n = int(s) assert n == 0 , &quot;n is zero!&quot; return 10 / nfoo(&#x27;0&#x27;)--------------------------------------------------# Output:Traceback (most recent call last): ...AssertionError: n is zero! 当assert后面的表达式为 False 时，则抛出 AssertionError错误 assert expression等价于 12if not expression: raise AssertionError assert expression [,arguments]等价于 12if not expression: rasise AssertionError(arguments) 例如：断言当前系统为 linux 12import sysassert (linux in sys.platform), &quot;该代码只能在 linux 系统下执行&quot; 日志模块 loggingPython 标准库中有一个日志模块 logging，相当于 java 中的 log4j 在软件开发阶段或部署开发环境时，为了尽可能详细的查看应用程序的运行状态来保证上线后的稳定性，我们可能需要把该应用程序所有的运行日志全部记录下来进行分析，这是非常耗费机器性能的。 当应用程序正式发布或在生产环境部署应用程序时，我们通常只需要记录应用程序的异常信息、错误信息等，这样既可以减小服务器的I/O压力，也可以避免我们在排查故障时被淹没在日志的海洋里。 logging 日志等级把日志分为6个等级 Level value Description NOTEST 0 DEBUG 10 最详细的日志信息，典型应用场景是 问题诊断 INFO 20 通常只记录关键节点信息，用于确认一切都是按照我们预期的那样进行工作 WARNING 30 当某些不期望的事情发生时记录的信息，但是此时应用程序还是正常运行的 ERROR 40 由于一个更严重的问题导致某些功能不能正常运行时记录的信息 CRITICAL 50 当发生严重错误，导致应用程序不能继续运行时记录的信息 日志等级是从下到上依次升高的（值越大等级越高）即：NOTEST &lt; DEBUG &lt; INFO &lt; WARNING &lt; ERROR &lt; CRITICAL，而日志的信息量是依次减少的； 开发应用程序或部署开发环境时，可以使用DEBUG或INFO级别的日志获取尽可能详细的日志信息来进行开发或部署调试；应用上线或部署生产环境时，应该使用WARNING或ERROR或CRITICAL级别的日志来降低机器的I/O压力和提高获取错误日志信息的效率。 日志级别的指定通常都是在应用程序的配置文件中进行指定的。 logging 配置 loggong.basicConfig(**kwargs) **kwargs 可以接收关键字参数如下： 参数名称 描述 取值范围 filename 指定日志输出目标文件的文件名，指定该设置项后日志信息就不会被输出到控制台了 string filemode 指定日志文件的打开模式，默认为’a’。该选项要在filename指定时才有效 a、w format 指定日志格式字符串，即指定日志输出时所包含的字段信息以及它们的顺序 详见下表 datefmt 指定日期/时间格式，该选项要在format中包含时间字段%(asctime)s时才有效 datefmt level 指定日志器的日志级别 logging.DEBUG、logging.INFO… stream 指定日志输出目标stream。 sys.stdout、sys.stderr以及网络stream style 指定format格式字符串的风格，可取值为，默认为’%’ %、{、$ handlers 该选项如果被指定，它应该是一个创建了多个Handler的可迭代对象，这些handler将会被添加到root logger。 一个创建了多个Handler的可迭代对象 filename、stream和handlers这三个配置项只能有一个存在，不能同时出现2个或3个，否则会引发ValueError异常。 format 参数的取值表 名称 使用格式 描述 asctime %(asctime)s 日志事件发生的时间–人类可读时间，如：2003-07-08 16:49:45,896 created %(created)f 日志事件发生的时间–时间戳，就是当时调用time.time()函数返回的值 relativeCreated %(relativeCreated)d 日志事件发生的时间相对于logging模块加载时间的相对毫秒数（目前还不知道干嘛用的） msecs %(msecs)d 日志事件发生的时间的毫秒部分 ————— ——————- —————————————————————————- levelname %(levelname)s 该日志记录的文字形式的日志级别（’DEBUG’, ‘INFO’, ‘WARNING’, ‘ERROR’, ‘CRITICAL’） levelno %(levelno)s 该日志记录的数字形式的日志级别（10,20,30,40,50） lineno %(lineno)d 调用日志记录函数的源代码所在的行号 funcName %(funcName)s 调用日志记录函数的函数名 name %(name)s 所使用的日志器名称，默认是’root’， message %(message)s 日志记录的文本内容，通过 msg % args计算得到的 ————— ——————- —————————————————————————- pathname %(pathname)s 调用日志记录函数的源码文件的全路径 filename %(filename)s pathname的文件名部分，包含文件后缀 module %(module)s filename的名称部分，不包含后缀 ————— ——————- —————————————————————————- process %(process)d 进程ID processName %(processName)s 进程名称，Python 3.1新增 thread %(thread)d 线程ID threadname %(thread)s 线程名称 12345678910111213import loggingLOG_FORMAT = &quot;%(asctime)s - %(levelname)s - %(message)s&quot; # 日志打印格式DATE_FORMAT = &quot;%Y-%m-%d %H:%M:%S&quot; # 时间打印格式# 配置日志logging.basicConfig(filename=&#x27;my.log&#x27;, level=logging.DEBUG, format=LOG_FORMAT, datefmt=DATE_FORMAT)logging.debug(&quot;This is a debug log.&quot;)logging.info(&quot;This is a info log.&quot;)logging.warning(&quot;This is a warning log.&quot;)logging.error(&quot;This is a error log.&quot;)logging.critical(&quot;This is a critical log.&quot;) 以上代码 配置了日志文件，级别设置为 DEBUG，输出格式为 日志发生时间 - 日志等级 - 日志信息 执行后结果如下： 执行第二次后结果如下： 如果要让日志格式好看点，还可以指定宽度。比如执行 日志等级 的打印宽度为 8，在 s 前面加上宽度即可：%(levelname)8s如果要左对齐，则写上减号 -：%(levelname)-8s 123456789101112131415# 导入模块import loggingLOG_FORMAT = &quot;%(asctime)s - %(levelname)-8s - %(message)s&quot; # 日志打印格式DATE_FORMAT = &quot;%Y-%m-%d %H:%M:%S&quot; # 时间打印格式# 配置日志logging.basicConfig(filename=&#x27;my.log&#x27;, level=logging.DEBUG, format=LOG_FORMAT, datefmt=DATE_FORMAT)# 打日志logging.debug(&quot;This is a debug log.&quot;)logging.info(&quot;This is a info log.&quot;)logging.warning(&quot;This is a warning log.&quot;)logging.error(&quot;This is a error log.&quot;)logging.critical(&quot;This is a critical log.&quot;) 左对齐：%(levelname)-8s 右对齐：%(levelname)8s logging 模块使用 用法： 导入 logging 配置(可选) 打日志 logging 模块提供了两种记录日志的方式： 使用 logging 提供的模块级别的函数 使用 logging 日志系统的四大组件 logging所提供的模块级别的日志记录函数也是对logging日志系统相关类的封装而已。 函数用法常用模块级别函数 Function Description logging.debug(msg, *args, **kwargs) 创建一条严重级别为 DEBUG 的日志记录 logging.info(msg, *args, **kwargs) 创建一条严重级别为 INFO 的日志记录 logging.warning(msg, *args, **kwargs) 创建一条严重级别为 WARNNING 的日志记录 logging.error(msg, *args, **kwargs) 创建一条严重级别为 ERROR 的日志记录 logging.critical(msg, *args, **kwargs) 创建一条严重级别为 CRITICAL 的日志记录 logging.log(msg, *args, **kwargs) 创建一条严重级别为 LOG 的日志记录 logging.basicConfig(**kwargs) 对root logger进行一次性配置 1234567891011121314151617181920212223242526import logging # 导入模块# 打日志logging.debug(&quot;This is a debug log.&quot;)logging.info(&quot;This is a info log.&quot;)logging.warning(&quot;This is a warning log.&quot;)logging.error(&quot;This is a error log.&quot;)logging.critical(&quot;This is a critical log.&quot;)或import logging #导入模块# 打日志logging.log(logging.DEBUG, &quot;This is a debug log.&quot;)logging.log(logging.INFO, &quot;This is a info log.&quot;)logging.log(logging.WARNING, &quot;This is a warning log.&quot;)logging.log(logging.ERROR, &quot;This is a error log.&quot;)logging.log(logging.CRITICAL, &quot;This is a critical log.&quot;)--------------------------------------------------# Output:WARNING:root:This is a warning log.ERROR:root:This is a error log.CRITICAL:root:This is a critical log. 这里只输出 warning 级别以上的信息。这是因为默认的日志等级是 warning ，所以 debug 和 info 级别的信息就被忽略了。logging 只输出 大于等于 所设置级别以上的日志信息。这点可以在 logging.basicConfig()中设置","categories":[{"name":"Python","slug":"Python","permalink":"https://www.boii.xyz/categories/Python/"},{"name":"进阶","slug":"Python/进阶","permalink":"https://www.boii.xyz/categories/Python/%E8%BF%9B%E9%98%B6/"},{"name":"错误与调试","slug":"Python/进阶/错误与调试","permalink":"https://www.boii.xyz/categories/Python/%E8%BF%9B%E9%98%B6/%E9%94%99%E8%AF%AF%E4%B8%8E%E8%B0%83%E8%AF%95/"}],"tags":[{"name":"Python","slug":"Python","permalink":"https://www.boii.xyz/tags/Python/"}]},{"title":"Python【No-9】测试","slug":"Python【No-9】测试","date":"2020-07-15T02:41:48.000Z","updated":"2021-05-22T13:37:47.740Z","comments":true,"path":"2020/07/15/Python【No-9】测试/","link":"","permalink":"https://www.boii.xyz/2020/07/15/Python%E3%80%90No-9%E3%80%91%E6%B5%8B%E8%AF%95/","excerpt":"程序的必经之路：测试","text":"程序的必经之路：测试 测试分为 单元测试、组件测试、系统测试、性能测试，逐级上升。所谓的测试驱动开发(TDD：Test-Driven Development)，就是说每写完一个小功能，就要做一个完整的单元测试，每次进行改动以后都要进行一次单元测试，以确保功能正常。 每个单元测试都通过以后就可以进行组件测试，所有组件测试都通过就可以进行系统测试，系统测试通过就可以进行性能测试，性能测试类似于“烤机”，测试系统的最大承受能力，承受峰值等等。 单元测试单元测试就是对一个模块、一个函数或者一个类进行正确性检验的检测工作举个栗子： 对一个求绝对值函数 abs(num)，可以编写一下几个测试用例： 输入正数 如 1、4.1、5.9，期待返回正整数 1、4.1、5.9 输入负数 如 -1.5、-3.7、20，期待返回正整数 1.5、3.7、20 输入 0，期待返回 0 输入非数值类型 如 None、[]、&#123;&#125;，期待抛出TypeError。 将上面4个测试用例放到一个测试模块里，就是一个完整单元测试。单元测试能通过了，说明这个函数功能正常，如果不通过，要么函数有问题，要么测试用例有问题。所以要修复直到单元测试能够通过。 这样做的好处是，如果我们对abs()做了修改，只要再进行一次单元测试，可以通过，就说明修改没有影响函数的功能。如果不通过则要找出问题，修改到通过单元测试为止。极大程度上确保该模块行为仍然是正确的。 文档测试一个函数、模块、类的第一个匿名字符串，就是文档。如 123456789101112def func(): &#x27;&#x27;&#x27; 这里是文档 &#x27;&#x27;&#x27; passclass cls: &#x27;&#x27;&#x27; 这里是文档 &#x27;&#x27;&#x27; pass 文档的内容可以作为测试集来进行测试。第一步：编写文档。文档中 &gt;&gt;&gt;的行会被执行，这与在交互模式下执行语句的相同的。第二步：if __name__ == &#39;__main__&#39;: import doctest; doctest.testmod()第三步：运行文件 例如上面的绝对值函数abs()可以这样写 123456789101112131415161718192021def abs(num): &#x27;&#x27;&#x27; The function will return the absolute value of num. &gt;&gt;&gt; abs(11) 11 &gt;&gt;&gt; abs(-41) 41 &gt;&gt;&gt; abs(0) 0 &gt;&gt;&gt; abs(&#x27;a&#x27;) Traceback (most recent call last): ... TypeError: &#x27;&gt;=&#x27; not supported between instances of &#x27;str&#x27; and &#x27;int&#x27; &#x27;&#x27;&#x27; return n if n &gt;= 0 else (-n)if __name__ == &#x27;__main__&#x27;: import doctest doctest.testmod() 文档中以 &gt;&gt;&gt; 表示测试用例，并在下行写出结果。如果测试结果正确，则什么也不会输出。 小结doctest非常有用，不但可以用来测试，还可以直接作为示例代码。通过某些文档生成工具，就可以自动把包含doctest的注释提取出来。用户看文档的时候，同时也看到了doctest。 Unittest 环境搭建：Python已内置Unittest框架，直接import unittest 四大组件： test fixture：setUp（前置条件）、tearDown（后置条件），用于初始化测试用例及清理和释放资源 test case：测试用例，通过继承unittest.TestCase实现用例的继承。在Unittest中，测试用例都是通过test前缀或后缀来识别的。 def test_xxx(self)、def xxx_test(self) test suite：测试套件，即测试用例的集合。 test runner：运行器，一般通过runner来调用suite去执行测试。 运行机制：通过在main函数中，调用unittest.main()运行所有内容 1234567891011121314151617181920212223242526272829303132import unittestclass forTest(unittest.TestCase): # 初始化 def setUp(self) -&gt; None: print(&#x27;setUp&#x27;) # 释放 def tearDown(self) -&gt; None: print(&#x27;tearDown&#x27;) # 测试用例1 def test_a(self): print(&#x27;a&#x27;) # 测试用例2 def test_b(self): print(&#x27;b&#x27;)if __name__ == &#x27;__main__&#x27;； unittest.main()--------------------------------------------------# Output:setUpatearDownsetUpbtearDown","categories":[{"name":"Python","slug":"Python","permalink":"https://www.boii.xyz/categories/Python/"},{"name":"进阶","slug":"Python/进阶","permalink":"https://www.boii.xyz/categories/Python/%E8%BF%9B%E9%98%B6/"},{"name":"错误与调试","slug":"Python/进阶/错误与调试","permalink":"https://www.boii.xyz/categories/Python/%E8%BF%9B%E9%98%B6/%E9%94%99%E8%AF%AF%E4%B8%8E%E8%B0%83%E8%AF%95/"}],"tags":[{"name":"Python","slug":"Python","permalink":"https://www.boii.xyz/tags/Python/"}]},{"title":"Python【No-7】错误处理","slug":"Python【No-7】错误处理","date":"2020-07-14T02:41:48.000Z","updated":"2021-05-22T13:37:47.723Z","comments":true,"path":"2020/07/14/Python【No-7】错误处理/","link":"","permalink":"https://www.boii.xyz/2020/07/14/Python%E3%80%90No-7%E3%80%91%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86/","excerpt":"语言必修课：错误处理","text":"语言必修课：错误处理 错误处理 try...except1...[exceptN...[finally...] 123456try: 可能会出现异常的代码except 异常类型 [as 别名]： 出现异常后的处理finally: 不管是否出现异常最后都会执行的代码 示例： 1234567891011121314151617181920# 出现 除零的异常 示例try: print(&quot;Try---------&quot;) r = 10/0 print(&quot;result: &quot;, r)except ZeroDivisionError as e: print(&quot;Except------&quot;, e)finally: print(&quot;Finally-----&quot;)print(&quot;END&quot;)--------------------------------------------------# Output:Try---------Except------ division by zeroFinally-----END try 语句块中的代码遇到异常后会跳转到 except 语句块执行而 finally 语句块不管有没有异常最后都会执行。当然，也可以没有 finally 语句 1234567891011121314151617181920# 没有异常的示例try: print(&quot;Try---------&quot;) r = 10/2 print(&quot;result: &quot;, r)except ZeroDivisionError as e: print(&quot;Except------&quot;, e)finally: print(&quot;Finally-----&quot;)print(&quot;END&quot;)--------------------------------------------------# Output:Try---------result: 5Finally-----END 捕获多个异常捕获异常不止可以捕获一个，还可以捕获多个 123456789101112131415161718192021try: print(&quot;Try---------&quot;) r = 10 / int(&#x27;a&#x27;) print(&quot;result: &quot;, r)except ValueError as e: print(&#x27;ValueError: &#x27;, e)except ZeroDivisionError as e: print(&quot;ZeroDivisionError: &quot;, e)finally: print(&quot;Finally-----&quot;)print(&quot;END&quot;)--------------------------------------------------# Output:Try---------ValueError: invalid literal for int() with base 10: &#x27;a&#x27;Finally-----END else 语句在 except 后面还可以加一个 else 语句块 1234567891011121314151617181920212223242526# else 语句在没有异常的情况下 示例try: print(&quot;Try---------&quot;) r = 10 / int(&#x27;2&#x27;) print(&quot;result: &quot;, r)except ValueError as e: print(&#x27;ValueError: &#x27;, e)except ZeroDivisionError as e: print(&quot;ZeroDivisionError: &quot;, e)else: print(&quot;Else--------No Error!&quot;)finally: print(&quot;Finally-----&quot;)print(&quot;END&quot;)--------------------------------------------------# Output:Try---------result: 5.0Else--------No Error!Finally-----END else 语句不同于finally 语句。finally 语句是有无异常都会执行，else 语句会在没有异常的情况下执行 123456789101112131415161718192021222324# else 语句在有异常的情况下 示例try: print(&quot;Try---------&quot;) r = 10 / int(&#x27;a&#x27;) print(&quot;result: &quot;, r)except ValueError as e: print(&#x27;ValueError: &#x27;, e)except ZeroDivisionError as e: print(&quot;ZeroDivisionError: &quot;, e)else: print(&quot;Else--------No Error!&quot;)finally: print(&quot;Finally-----&quot;)print(&quot;END&quot;)--------------------------------------------------# Output:Try---------ValueError: invalid literal for int() with base 10: &#x27;a&#x27;Finally-----END 优点：跨越多层调用例如现在 A() 调用 B()，B() 调用 C()，在 C() 出错了，只要 A() 捕获到了，就可以处理。 12345678910111213141516171819202122def C(s): return 10 / int(s)def B(s): return C(s) * 2def A(): try: B(&#x27;0&#x27;) except Exception as e: print(&quot;Error:&quot;, e) finally: print(&quot;Finally------&quot;)A()--------------------------------------------------# Output:Error: division by zeroFinally------ 虽然错误是在 C() 出现，但是在 A() 也能捕获。如果错误没有被捕获，它就会一直往上抛，最后被Python解释器捕获，打印一个错误信息，然后程序退出。 错误是个class所有的错误类型都继承自 BaseException，如果捕获到了一个父类错误，其子类错误不会被捕获。例如： 123456try: foo()except ValueError as e: print(&#x27;ValueError&#x27;)except UnicodeError as e: print(&#x27;UnicodeError&#x27;) 第二个except永远捕获不到 UnicodeError，因为UnicodeError是ValueError的子类。即使有UnicodeError，也被第一个except捕获了。 错误类继承关系12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364BaseException +-- SystemExit +-- KeyboardInterrupt +-- GeneratorExit +-- Exception +-- StopIteration +-- StopAsyncIteration +-- AttributeError 属性错误 +-- AssertionError 断言错误 +-- BufferError 缓冲错误 +-- EOFError 文件结束符错误 +-- MemoryError 内存错误 +-- ReferenceError +-- SystemError 系统错误 +-- TypeError 类型错误 +-- ArithmeticError 算术错误 | +-- FloatingPointError | +-- OverflowError | +-- ZeroDivisionError +-- ImportError 导入错误 | +-- ModuleNotFoundError +-- LookupError | +-- IndexError | +-- KeyError +-- NameError 命名错误 | +-- UnboundLocalError +-- OSError 操作系统错误 | +-- BlockingIOError IO阻塞错误 | +-- ChildProcessError 子进程错误 | +-- ConnectionError | | +-- BrokenPipeError | | +-- ConnectionAbortedError | | +-- ConnectionRefusedError | | +-- ConnectionResetError | +-- FileExistsError | +-- FileNotFoundError | +-- InterruptedError | +-- IsADirectoryError | +-- NotADirectoryError | +-- PermissionError | +-- ProcessLookupError | +-- TimeoutError +-- RuntimeError 运行时错误 | +-- NotImplementedError | +-- RecursionError +-- SyntaxError 同步错误 | +-- IndentationError | +-- TabError +-- ValueError 值错误 | +-- UnicodeError | +-- UnicodeDecodeError | +-- UnicodeEncodeError | +-- UnicodeTranslateError +-- Warning 警告 +-- DeprecationWarning +-- PendingDeprecationWarning +-- RuntimeWarning +-- SyntaxWarning +-- UserWarning +-- FutureWarning +-- ImportWarning +-- UnicodeWarning +-- BytesWarning +-- ResourceWarning 抛出错误错误是 class， 捕获错误实质上就是捕获到该 class 的一个实例。因此，错误是可以有意创建并抛出的。 try...except...是承接错误，而raise是抛出错误 123456789101112131415161718192021222324def register(): username = input(&quot;请输入用户名：&quot;) if len(username) &lt; 6: raise Exception(&quot;用户名长度必须6位以上&quot;) else: print(&quot;输入的用户名是:&quot;, username)register()--------------------------------------------------# Output1:请输入用户名：adminTraceback (most recent call last): File &quot;d:/---Programming---/Python/Project/mo2.py&quot;, line 9, in &lt;module&gt; register() File &quot;d:/---Programming---/Python/Project/mo2.py&quot;, line 4, in register raise Exception(&quot;用户名长度必须6位以上&quot;)Exception: 用户名长度必须6位以上# Output2:请输入用户名：administor输入的用户名是: administor 在 if 中主动raise抛出错误，但是调用register()的地方没有try...except来捕获错误，所以最后由解释器处理，打印出了错误信息 1234567891011121314151617181920212223242526def register(): username = input(&quot;请输入用户名：&quot;) if len(username) &lt; 6: raise Exception(&quot;用户名长度必须6位以上&quot;) else: print(&quot;输入的用户名是：&quot;, username)try: register()except Exception as e: print(e) print(&quot;注册失败&quot;)else: print(&quot;注册成功&quot;)--------------------------------------------------# Output1:请输入用户名：admin用户名长度必须6位以上注册失败# Output2:请输入用户名：administor输入的用户名是: administor注册成功 在 if 处 raise抛出错误，在register()使用了try...except捕获错误，然后进行了处理。 自定义错误主动抛出错误，这个错误可以是自己定义的 class，因为错误也是 class。 1234567891011121314151617181920212223242526272829class NameUndercutting(Exception): passdef register(): username = input(&quot;请输入用户名：&quot;) if len(username) &lt; 6: raise Exception(&quot;用户名长度必须6位以上&quot;) else: print(&quot;输入的用户名是：&quot;, username)try: register()except NameUndercutting as e: print(e) print(&quot;注册失败&quot;)else: print(&quot;注册成功&quot;)--------------------------------------------------# Output1:请输入用户名：admin用户名长度必须6位以上注册失败# Output2:请输入用户名：administor输入的用户名是: administor注册成功","categories":[{"name":"Python","slug":"Python","permalink":"https://www.boii.xyz/categories/Python/"},{"name":"进阶","slug":"Python/进阶","permalink":"https://www.boii.xyz/categories/Python/%E8%BF%9B%E9%98%B6/"},{"name":"错误与调试","slug":"Python/进阶/错误与调试","permalink":"https://www.boii.xyz/categories/Python/%E8%BF%9B%E9%98%B6/%E9%94%99%E8%AF%AF%E4%B8%8E%E8%B0%83%E8%AF%95/"}],"tags":[{"name":"Python","slug":"Python","permalink":"https://www.boii.xyz/tags/Python/"}]},{"title":"Python【Feature】工具类","slug":"Python【No-Feature】工具类","date":"2020-07-12T05:17:48.000Z","updated":"2021-05-22T13:37:47.740Z","comments":true,"path":"2020/07/12/Python【No-Feature】工具类/","link":"","permalink":"https://www.boii.xyz/2020/07/12/Python%E3%80%90No-Feature%E3%80%91%E5%B7%A5%E5%85%B7%E7%B1%BB/","excerpt":"Python的高级特性3","text":"Python的高级特性3 map将传入的函数作用于可迭代对象的每一个元素上 map(function, iterable)参数：map 可以接受两个参数，第一个是函数，第二个是可迭代对象作用：将可迭代对象的每一个元素放在 function 中进行处理返回：map 返回的是一个 map 对象，这是一个可迭代对象 举个栗子： 1234567891011# 使用map示例alpha = [&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;, &#x27;x&#x27;, &#x27;y&#x27;, &#x27;z&#x27;]m = map(lambda x: x + &#x27;i&#x27;, alpha)print(m)print(list(m)) # 返回的map对象用m接收，然后转换成列表，打印出来--------------------------------------------------# Output:&lt;map object at 0x000001D50CEBAD00&gt;[&#x27;ai&#x27;, &#x27;bi&#x27;, &#x27;ci&#x27;, &#x27;xi&#x27;, &#x27;yi&#x27;, &#x27;zi&#x27;] 如果不使用 map 函数，应该这样写 12345678910111213141516171819# 不适用map的示例alpha = [&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;, &#x27;x&#x27;, &#x27;y&#x27;, &#x27;z&#x27;]def add_alpha(list1): &quot;&quot;&quot; 遍历list1，每个元素都加上 i 然后放进 list2 中 &quot;&quot;&quot; list2 = list() for alpha in list1: list2.append(alpha + &#x27;i&#x27;) return list2m = add_alpha(alpha)print(m)print(type(m))--------------------------------------------------# Output:[&#x27;ai&#x27;, &#x27;bi&#x27;, &#x27;ci&#x27;, &#x27;xi&#x27;, &#x27;yi&#x27;, &#x27;zi&#x27;]&lt;class &#x27;list&#x27;&gt; 效果是一样的，但是并没有像 map 那么简洁 同样，上面的示例还可以使用更简洁的办法，用列表生成式前提是其逻辑比较简单，如果复杂还是要另外编写 操作函数，然后传给 map() 1234567alpha = [&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;, &#x27;x&#x27;, &#x27;y&#x27;, &#x27;z&#x27;]print([x + &#x27;i&#x27; for x in alpha])--------------------------------------------------# Output:[&#x27;ai&#x27;, &#x27;bi&#x27;, &#x27;ci&#x27;, &#x27;xi&#x27;, &#x27;yi&#x27;, &#x27;zi&#x27;] 此外，因为返回出来的已经不是原本放进去的可迭代对象了，所以即使元组不能修改，map 也能进行操作 123456789101112131415# 对元组进行操作m = (12, 23, 28, 19, 16, 30)print(&#x27;m source: &#x27;, id(m)) # 打印原元组的地址m = map(lambda x: x * x, m) # 对元组进行操作print(&#x27;m operated:&#x27;, id(m)) # 打印修改后元组的地址print(&#x27;m is a&#x27;, m) # 打印结果显示 m 是个 map对象print(list(m)) # 把 m 转成列表打印出来--------------------------------------------------# Output:m source: 2599500087840m operated: 2599500555024m is a &lt;map object at 0x0000025D3E4EA310&gt;[144, 529, 784, 361, 256, 900] filter对可迭代对象进行过滤Python2 中 filter 是个内置函数, Python3 中 filter 是个内置类 filter(condition_function, iterable)参数：filter 可以接收两个参数，第一个是函数，第二个是可迭代对象作用：将 可迭代对象 的每一个元素放在 function 中进行过滤，满足 function 中的过滤规则便返回返回：filter 返回的是一个 filter对象，这是一个可迭代对象。 123456789101112131415# filter 示例f = [12, 23, 28, 19, 16, 30]print(&#x27;f source: &#x27;, id(f)) # 打印原元组的地址f = filter(lambda x: x &gt;= 18, f) # 对 列表进行过滤，过滤出大于等于18的元素print(&#x27;f operated:&#x27;, id(f)) # 打印修改后元组的地址print(&#x27;f is a&#x27;, f) # 打印结果显示 f 是个 filter对象print(list(f)) # 把 f 转成列表打印出来--------------------------------------------------# Output:f source: 2379695132608f operated: 2379696090368f is a &lt;filter object at 0x0000022A10F0AD00&gt;[23, 28, 19, 30] 同样，filter 也可以对元组操作，简单的过滤规则也可以用列表生成式代替 12345678# 用列表生成式实现简单过滤f = [12, 23, 28, 19, 16, 30]print([x for x in f if x &gt;= 18])--------------------------------------------------# Output:[23, 28, 19, 30] reducereduce 不是内置函数，必须导入 from functools import reducereduce(function, sequence, initial=_initial_missing) 参数：reduce 第一个参数接收一个带两个形参的函数，第二个参数接收一个序列作用：把函数作用在一个序列上，函数必须接收两个参数，reduce 把结果继续和序列的下一个元素做累计运算返回：一个计算结果 听起来有点绕，用示例解释 12345678910111213from functools import reducedef foo(x, y): return x + yscores = [100, 89, 76, 87]r = reduce(foo, scores)print(r)--------------------------------------------------# Output:352 在 reduce 中会一次次调用scores中的元素放到foo函数中进行计算第一轮：x = 100, y = 89, result = 189第二轮：x = result, y = 76, result = 265 (即 189 + 76)第三轮：x = result, y = 87, result = 352 (即 265 + 87)最后把 result 也就是 352 返回出去 上面的例子中的序列还是比较简单的，如果遇到复杂的数据对象，则不能这么简单处理 1234567891011121314151617181920212223242526from functools import reducedic = [ &#123;&#x27;name&#x27;: &#x27;Alice&#x27;, &#x27;age&#x27;: 18, &#x27;score&#x27;: 78&#125;, &#123;&#x27;name&#x27;: &#x27;Boii&#x27;, &#x27;age&#x27;: 17, &#x27;score&#x27;: 89&#125;, &#123;&#x27;name&#x27;: &#x27;Candy&#x27;, &#x27;age&#x27;: 19, &#x27;score&#x27;: 65&#125;, &#123;&#x27;name&#x27;: &#x27;Dannis&#x27;, &#x27;age&#x27;: 22, &#x27;score&#x27;: 99&#125;]def foo(x, y): return x[&#x27;score&#x27;] + y[&#x27;score&#x27;] # 第二轮就会出错r = reduce(foo, dic)print(r)--------------------------------------------------# Output:Traceback (most recent call last): File &quot;d:/---Programming---/Python/Project/练习/mo2.py&quot;, line 58, in &lt;module&gt; r = reduce(foo, dic) File &quot;d:/---Programming---/Python/Project/练习/mo2.py&quot;, line 55, in foo return x + y[&#x27;score&#x27;]TypeError: unsupported operand type(s) for +: &#x27;dict&#x27; and &#x27;int&#x27; 哦嚯，报错。报错信息为：unsupported operand type(s) for +: ‘dict’ and ‘int’不支持 字典对象和整型做 相加操作 既然说相加，看来问题出在foo函数身上以上面的方式再进行一次推导第一轮：x = {‘name’: ‘Alice’, ‘age’: 18, ‘score’: 78}, y = {‘name’: ‘Boii’, ‘age’: 17, ‘score’: 89},则 x[‘score’] = 78, y[‘score’] = 89, result = 167第二轮：x = result, y = {‘name’: ‘Candy’, ‘age’: 19, ‘score’: 65},则 x[‘score’] =… 问题就出在这 第一次计算之后result 给了x，x就成了整型，当然取不出 score 解决方法，改为 return x + y[&#39;score&#39;] 1234567891011121314151617181920212223242526from functools import reducedic = [ &#123;&#x27;name&#x27;: &#x27;Alice&#x27;, &#x27;age&#x27;: 18, &#x27;score&#x27;: 78&#125;, &#123;&#x27;name&#x27;: &#x27;Boii&#x27;, &#x27;age&#x27;: 17, &#x27;score&#x27;: 89&#125;, &#123;&#x27;name&#x27;: &#x27;Candy&#x27;, &#x27;age&#x27;: 19, &#x27;score&#x27;: 65&#125;, &#123;&#x27;name&#x27;: &#x27;Dannis&#x27;, &#x27;age&#x27;: 22, &#x27;score&#x27;: 99&#125;]def foo(x, y): return x + y[&#x27;score&#x27;] # 一个字典 + 一个整型，依然报错r = reduce(foo, dic)print(r)--------------------------------------------------# Output:Traceback (most recent call last): File &quot;d:/---Programming---/Python/Project/练习/mo2.py&quot;, line 58, in &lt;module&gt; r = reduce(foo, dic) File &quot;d:/---Programming---/Python/Project/练习/mo2.py&quot;, line 55, in foo return x + y[&#x27;score&#x27;]TypeError: unsupported operand type(s) for +: &#x27;dict&#x27; and &#x27;int&#x27; 依然报错，这回问题出在第一轮x = {‘name’: ‘Alice’, ‘age’: 18, ‘score’: 78}，y[‘score’] = 89一个是字典一个是整型 解决方法，设置初始值 123456789101112131415161718192021from functools import reducedic = [ &#123;&#x27;name&#x27;: &#x27;Alice&#x27;, &#x27;age&#x27;: 18, &#x27;score&#x27;: 78&#125;, &#123;&#x27;name&#x27;: &#x27;Boii&#x27;, &#x27;age&#x27;: 17, &#x27;score&#x27;: 89&#125;, &#123;&#x27;name&#x27;: &#x27;Candy&#x27;, &#x27;age&#x27;: 19, &#x27;score&#x27;: 65&#125;, &#123;&#x27;name&#x27;: &#x27;Dannis&#x27;, &#x27;age&#x27;: 22, &#x27;score&#x27;: 99&#125;]def foo(x, y): return x + y[&#x27;score&#x27;]r = reduce(foo, dic, 0)print(r)--------------------------------------------------# Output:331 第一轮：x = 0, y = {‘name’: ‘Alice’, ‘age’: 18, ‘score’: 78}, 则 y[‘score’] = 78, result = 78第二轮：x = result, y ={‘name’: ‘Boii’, ‘age’: 17, ‘score’: 89}, 则 y[‘score’] = 89, result = 167第三轮：x = result, y ={‘name’: ‘Candy’, ‘age’: 19, ‘score’: 65}, 则 y[‘score’] = 65, result = 232第四轮：x = result, y ={‘name’: ‘Dannis’, ‘age’: 22, ‘score’: 99}, 则 y[‘score’] = 99, result = 331最后把 331 返回出去","categories":[{"name":"Python","slug":"Python","permalink":"https://www.boii.xyz/categories/Python/"},{"name":"高级特性","slug":"Python/高级特性","permalink":"https://www.boii.xyz/categories/Python/%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7/"}],"tags":[{"name":"Python","slug":"Python","permalink":"https://www.boii.xyz/tags/Python/"},{"name":"函数式编程","slug":"函数式编程","permalink":"https://www.boii.xyz/tags/%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B/"}]},{"title":"Python【Feature】函数式编程","slug":"Python【No-Feature】函数式编程","date":"2020-07-12T04:17:48.000Z","updated":"2021-05-22T13:37:47.723Z","comments":true,"path":"2020/07/12/Python【No-Feature】函数式编程/","link":"","permalink":"https://www.boii.xyz/2020/07/12/Python%E3%80%90No-Feature%E3%80%91%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B/","excerpt":"Python的高级特性2","text":"Python的高级特性2 函数式编程的一个特点就是，允许把函数本身作为参数传入另一个函数，还允许返回一个函数！ 函数的本质在学C语言指针的时候，会接触到一个概念：函数名是函数所在内存的地址，类似-数组名是数组的首元素的地址。 即使Python中没有指针一说，但是本质还是一样的。变量名是一个变量的地址函数名是一个函数的地址调用函数的时候其实是把参数传到函数本身所在的那块内存中去，函数名不过是一个媒介而已。在C中可以说，函数名就是个指针，指向一个函数在Python中可以说，函数名就是个变量，指向一个函数 既然函数名只是指向函数本身所在地址，那我换个名来指不也可以。 12345678910def sum(a, b): return a + bf = sumf(1, 2)---------------------------------# Output:3 如果放到交互模式中，可以更明显的看出来 123456789101112# 定义一个函数&gt;&gt;&gt; def sum(a, b):... return a + b...&gt;&gt;&gt; sum&lt;function sum at 0x000001F25AF6B280&gt;&gt;&gt;&gt; f=sum&gt;&gt;&gt; f&lt;function sum at 0x000001F25AF6B280&gt;&gt;&gt;&gt; f(3, 4)7 大概就这么回事儿 高阶函数 高阶函数：接受函数作为参数的函数def heigh_fn(a, b, fn) 既然变量可以指向函数，函数的参数能接收变量，那么一个函数就可以接收另一个函数作为参数，这种函数就称之为高阶函数。 一个最简单的高阶函数： 123456789101112def abs(num): return (num) if num &gt;= 0 else (-num)def abs_add(a, b, fn): return fn(a) + fn(b)print(abs_add(8, -4, abs))---------------------------------# Output:12 这个高阶函数的过程大概是这样的a = 8b = -4fn = absfn(a) + fn(b) ==&gt; abs(8) + abs(-4) ==&gt; 12 返回函数 返回函数：返回值为函数的函数 通常函数都是返回int、str、list 这些变量，但是变量可以指向函数，那函数可以返回一个变量，不就也可以返回一个函数。 举个栗子实现一个求和函数。参数可变，可以是1个也可以是多个。 1234567891011121314def cal_sum(*args): sum = 0 for n in args: sum += n return sumresult = cal_sum(1, 2, 3, 4, 5)print(result)---------------------------------# Output:15 好，现在再写一个函数lazy_sum()，把这个函数cal_sum()作为返回值返回 1234567def lazy_sum(*args): def cal_sum(): sum = 0 for n in args: sum += n return sum return cal_sum 可以看到最后一句return cal_sum就把函数返回出来了。那么函数lazy_sum()就是一个返回函数 现在调用一下这个返回函数 123456789101112131415161718def lazy_sum(*args): print(&#x27;I am the return function.&#x27;) def cal_sum(): sum = 0 for n in args: sum += n return sum return cal_sumresult = lazy_sum(1, 2, 3, 4, 5)print(result)---------------------------------# Output:I am the return function.&lt;function lazy_sum.&lt;locals&gt;.cal_sum at 0x000001C8765CB310&gt; 哦嚯，lazy_sum()没有进行计算，但也看出来，lazy_sum()返回的是一个函数result此时是一个函数，这时候我们要去调用一次返回值result，才会进行计算 12345678910111213141516171819202122def lazy_sum(*args): print(&#x27;I am the return function.&#x27;) def cal_sum(): sum = 0 for n in args: sum += n return sum return cal_sumresult = lazy_sum(1, 2, 3, 4, 5)print(result)res = result()print(res)---------------------------------# Output:I am the return function.&lt;function lazy_sum.&lt;locals&gt;.cal_sum at 0x000001E02D07B310&gt;15 这就是为什么说 返回函数是惰性的。就是这么来的 为什么要返回一个函数在lazy_sum()中，有一句print语句。从输出中可以看出，返回函数本身是立即执行的，但是它返回出来的函数要再进行一次调用才会执行。 单独一个返回函数并没有太大作用，但是返回函数和高阶函数结合起来，是不是就有意思了。接收一个函数，然后把这个函数返回出去。在返回之前是不是可以进行一些操作？ 假如现在有一个需求：求和；实现完了之后，产品经理又加需求：除了求和还要打印一下求和用了多长时间，也就是计时功能。那么现在你有两个办法 一是在求和函数里实现这个计时功能，但是这样就在一个函数里做了两件事情。即不优雅，也不好维护。这里举例是简单的求和，实际开发中可能是跟复杂的功能。 二是把计时函数写出来，然后把求和函数传给计时函数，在计时函数中给求和函数加上计时功能，之后再把这个有计时功能的求和函数返回出去。 计时函数这种接收函数 -&gt; 增强函数 -&gt; 返回函数的函数就叫闭包 不仅可以用在计时功能，还能用在日志功能，我只要把求和函数写好，传给日志函数就可以获得日志功能。函数只做一件事情，其他事情由别的函数做，需要什么功能把函数往里面一丢，还你一个增强版的。Amazing！这就叫面向切面编程 闭包、装饰器、面向切面编程闭包 闭包 = 高阶函数 + 返回函数即，一个接收函数作为参数，又返回一个函数的函数，就叫做闭包作用：增强函数功能、面向切面编程（AOP） 无参闭包123456789101112131415161718192021222324import timedef print_hello(): print(&#x27;hello!&#x27;)def cal_time(fn): def improve_fn(): start_time = time.time() fn() end_time = time.time() print(&#x27;耗时：&#123;&#125;&#x27;.format(end_time - start_time)) return improve_fnimprove_print_hello = cal_time(print_hello)improve_print_hello()# 也可以写做 cal_time(print_hello)()---------------------------------# Output:hello!耗时：0.0009620189666748047 栗子中，print_hello()只负责打印hello，cal_time()负责把传进来的函数增强然后返回出去所以cal_time就是一个闭包 带参闭包上面的栗子，print_hello()不需要参数，所以在无参闭包中可以顺利通过但是如果一个函数有参，那无参闭包就会抛出TypeError错误。 想要带参很简单。 123456789101112131415161718192021222324import timedef add(a, b): print(a + b)def cal_time(fn): def improve_fn(*args, **kwargs): # 在这里写下形参 start_time = time.time() fn(*args, **kwargs) # 调用的时候传进去 end_time = time.time() print(&#x27;耗时：&#123;&#125;&#x27;.format(end_time - start_time)) return improve_fncal_time(add)(1, 2)---------------------------------# Output:3耗时：0.00800633430480957 接收的函数有返回值接收的函数有返回值的话，应该在闭包里对函数调用的时候把参数接收下来，然后进行返回。 1234567891011121314151617181920212223242526import timedef add(a, b): return a + bdef cal_time(fn): def improve_fn(*args, **kwargs): start_time = time.time() count = fn(*args, **kwargs) # 调用函数之后用一个变量接收返回值 end_time = time.time() print(&#x27;耗时：&#123;&#125;&#x27;.format(end_time - start_time)) return count # 然后把返回值返回出去 return improve_fnresult = cal_time(add)(5, 12)print(result)---------------------------------# Output:耗时：0.000962018966674804717 装饰器 装饰器是闭包的语法糖——@闭包名或@闭包名(参数)语法糖只是一个更方便的写法，完全可以等价转换为非语法糖的代码 装饰器、闭包，本质上也是函数，说装饰器的同时也是在说闭包 保留原函数的元信息装饰器（闭包）的原理就是把原函数当作参数传进装饰器中，经过增强后返回一个新的增强版原函数这说明返回出来的增强版函数和原来的函数不是同一个了（在内存中创建了一个新的） 既然不是在原函数上进行改造，这就导致函数的元信息（文档字符串、注解、参数签名等）都丢失了解决方法就是使用functools库中的@wraps装饰器来把原函数的元信息复制过来。 先看看不保留元信息的样子 12345678910111213141516171819202122232425262728293031323334353637import time# 装饰器函数def cal_time(fn): &#x27;&#x27;&#x27; Decorator that report the execution time. &#x27;&#x27;&#x27; def improve_fn(*args, **kwargs): start = time.time() result = fn(*args, **kwargs) end = time.time() print(fn.__name__, end - start) return result return improve_fn# 原函数@cal_timedef countdown(n): &#x27;&#x27;&#x27; Count down &#x27;&#x27;&#x27; while n &gt; 0: n -= 1if __name__ == &#x27;__main__&#x27;: countdown(10_000) print(countdown.__doc__) # 没有使用wrap，所以元信息都丢失了---------------------------------# Output:countdown 0.0010008811950683594None 再看看使用了@wraps的样子 12345678910111213141516171819202122232425262728293031323334353637383940import timefrom functools import wraps# 装饰器函数def cal_time(fn): &#x27;&#x27;&#x27; Decorator that report the execution time. &#x27;&#x27;&#x27; @wraps(fn) def improve_fn(*args, **kwargs): start = time.time() result = fn(*args, **kwargs) end = time.time() print(fn.__name__, end - start) return result return improve_fn# 原函数@cal_timedef countdown(n): &#x27;&#x27;&#x27; Count down &#x27;&#x27;&#x27; while n &gt; 0: n -= 1if __name__ == &#x27;__main__&#x27;: countdown(10000) print(countdown.__doc__) # 使用了wrap，所以元信息没有丢失---------------------------------# Output:countdown 0.0010025501251220703 Count down 无参装饰器1234567891011121314151617181920212223242526272829303132333435363738394041import timefrom functools import wrapsdef cal_time(fn): &#x27;&#x27;&#x27; Decorator that report the execution time. &#x27;&#x27;&#x27; @wraps(fn) def improve_fn(*args, **kwargs): start = time.time() result = fn(*args, **kwargs) end = time.time() print(fn.__name__, &#x27;used time:&#x27;, end - start) return result return improve_fn# 装饰器里不需要携带参数@cal_timedef add(a, b): return a + bres = add(5, 6)print(res)# 等价于## def add(a, b):# return a + b## improve_add = cal_time(add)# res = improve_add(5, 6)# print(res)---------------------------------# Output:add used time: 0.011 带参装饰器1234567891011121314151617181920212223242526272829303132333435363738394041import timefrom functools import wrapsdef cal_time(msg): # 第一层，接收装饰器参数 print(&#x27;First floor:&#x27;, msg) def decorator(fn): # 第二层，接收函数 print(&#x27;Second floor:&#x27;, msg) @wraps(fn) def improve_fn(*args, **kwargs): # 第三层，增强函数 print(&#x27;Third floor:&#x27;, msg) start = time.time() result = fn(*args, **kwargs) end = time.time() print(&#x27;Used time:&#x27;, end - start) return result return improve_fn return decorator@cal_time(&#x27;I am the message.&#x27;)def countdown(time=10000): while time &gt; 0: time -= 1if __name__ == &#x27;__main__&#x27;: countdown()---------------------------------# Output:First floor: I am the message.Second floor: I am the message.Third floor: I am the message.Used time: 0.000997781753540039 有参装饰器和无参装饰器的区别仅仅只是多了一层函数而已也就是在无参装饰器的基础上多一层函数来接收装饰器参数而已。注意带参装饰器即使不填参数也要写上括号 装饰器只在第一次被调用去装饰函数时对原函数进行增强 增强时机：第一调用之前 增强次数：只增强一次 面向切面编程如果说类里面的继承是纵向继承，那面向切面编程可以理解为横向继承 纵向继承中，子类继承了父类非私有属性和方法；同属一个父类的子类都有相同的父类属性和方法横向继承中，是给子类增加了一些功能；同属一个父类的子类不见得有相同的功能。 就好比，一个爹生了两个娃，两个娃都有手有脚的，这是继承自爹那里的（纵向继承）但是一个娃点亮了游泳的技能，另一个娃点亮了跳舞的技能（横向继承）这俩娃生了俩孙子，肯定也是有手有脚的，但不一定会游泳跳舞。 所以面向切面编程中，这种闭包、装饰器之类的通常是用在编写通用工具类上。 匿名函数 lambda [parameters]: expression冒号前面的parameters表示匿名函数的形参列表，冒号后面的expression表示要return的语句parameters可以有也可以没有。匿名函数有个限制——只能有一个表达式，不用写return，返回值就是该表达式的结果。 匿名函数类似于 es6 中的简头函数 举个栗子： 12def add(a, b): return a + b 写成匿名函数就是 1lambda a, b: a + b 写成简头函数就是 1(a, b) =&gt; a + b 匿名函数可以作为实参、返回值，在这些场景中应用的比较多。 匿名函数作为实参 123456789101112131415161718192021# 普通写法def abs(num): return (num) if num &gt;= 0 else (-num)def abs_add(a, b, fn): return fn(a) + fn(b)print(abs_add(8, -4, abs))---------------------------------# 匿名函数写法def abs_add(a, b, fn): return fn(a) + fn(b)result = abs_add(8, -4, lambda x: x if x &gt;= 0 else -x) # 匿名函数作为实参print(result)---------------------------------# Output:12 匿名函数作为返回值 123456789def build(x, y): return lambda: x * x + y * y # 匿名函数作为返回值build(2, 3)---------------------------------# Output:13 总结 函数名的本质：函数起始地址 高阶函数：接收函数作为参数的函数 返回函数：返回一个函数（即返回一个函数地址）的函数，是惰性的 闭包：接收函数作为参数，并返回一个函数的函数（闭包=高阶函数+返回函数） 装饰器：闭包的语法糖，@闭包名字 匿名函数：lambda 参数: 返回值","categories":[{"name":"Python","slug":"Python","permalink":"https://www.boii.xyz/categories/Python/"},{"name":"高级特性","slug":"Python/高级特性","permalink":"https://www.boii.xyz/categories/Python/%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7/"}],"tags":[{"name":"Python","slug":"Python","permalink":"https://www.boii.xyz/tags/Python/"},{"name":"函数式编程","slug":"函数式编程","permalink":"https://www.boii.xyz/tags/%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B/"}]},{"title":"Python【Feature】高级特性","slug":"Python【No-Feature】高级特性","date":"2020-07-12T03:17:48.000Z","updated":"2021-05-22T13:37:47.740Z","comments":true,"path":"2020/07/12/Python【No-Feature】高级特性/","link":"","permalink":"https://www.boii.xyz/2020/07/12/Python%E3%80%90No-Feature%E3%80%91%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7/","excerpt":"Python的高级特性1","text":"Python的高级特性1 切片 Slice [startWith : end : step]切片适用于 list、tuple、stringstartWith是包含，end则不包含 注意：切片是从左往右切的如果用正索引开始，就要用 正索引 或 逆索引 结束，例如 s[1:5] 或 s[1:-3] ！如果用逆索引开始，就要用 逆索引 结束（s[-1:1] 这样只会返回空字符串，正确应该是 s[-5:-1]）！逆索引记得不要弄颠倒了。（s[-1:-3] 这样只会返回空字符串，正确应该是s[-3:-1]） 索引123| P | y | t | h | o | n | 0 1 2 3 4 5 # 从左往右，下标从0开始 -6 -5 -4 -3 -2 -1 # 从右往左，下标从-1开始 12345678910111213141516171819202122&gt;&gt;&gt; s = &#x27;Python&#x27;&gt;&gt;&gt; s[0]&#x27;P&#x27;&gt;&gt;&gt; s[0:-1] # 结束索引不被截取&#x27;Pytho&#x27;&gt;&gt;&gt; s[:5] # 起始索引可以省略不写，代表从第一位开始截取&#x27;Pytho&#x27;&gt;&gt;&gt; s[0:] # 结束索引可以省略不写，代表截取至最后一位&#x27;Python&#x27;&gt;&gt;&gt; s[:] # 等于复制了一整个&#x27;Python&#x27;&gt;&gt;&gt; s[1:4]&#x27;yth&#x27;&gt;&gt;&gt; s[1:-2]&#x27;yth&#x27;&gt;&gt;&gt; s[-2:1] # 逆索引开始，不能以正索引结束&#x27;&#x27;&gt;&gt;&gt; s[-5:-2]&#x27;yth&#x27;&gt;&gt;&gt; s[-2:-5] # 只能从左往右切&#x27;&#x27; 12345678910111213141516171819&gt;&gt;&gt; l = list(range(100))&gt;&gt;&gt; l[10:20][10, 11, 12, 13, 14, 15, 16, 17, 18, 19]&gt;&gt;&gt; l[10:20:3][10, 13, 16, 19]&gt;&gt;&gt; l[80::3][80, 83, 86, 89, 92, 95, 98]&gt;&gt;&gt; l[:10:3][0, 3, 6, 9]&gt;&gt;&gt; l[::10][0, 10, 20, 30, 40, 50, 60, 70, 80, 90]&gt;&gt;&gt; l[::-10][99, 89, 79, 69, 59, 49, 39, 29, 19, 9] 迭代 Iteration判断是否迭代对象 可以用过 collections 的 Iterable 类型，用 isinstance()判断 一个对象是否是可迭代对象 1234567891011121314from collections import Iterablestr = &#x27;abc&#x27;l = [1, 2, 3]t = (1, 2, 3)d = &#123;1: 1, 2: 2, 3: 3&#125;s = (&#123;1, 2, 3&#125;)print(isinstance(str, Iterable)) # Trueprint(isinstance(l, Iterable)) # Trueprint(isinstance(t, Iterable)) # Trueprint(isinstance(d, Iterable)) # Trueprint(isinstance(s, Iterable)) # Trueprint(isinstance(123, Iterable)) # False 整数字面量不是可迭代对象 迭代 List 列表类型数据123456s = &#x27;abcdefg&#x27;for value in s: print(value, end=&#x27; &#x27;)# Output：a b c d e f g 1234567891011121314# 可以通过 enumerate() 给string，list，tuple 等生成下标s = &#x27;abcdefg&#x27;for i, value in enumerate(s): print(i, value)# Output：0 a1 b2 c3 d4 e5 f6 g 123456789l = [&#x27;a&#x27;, True, (1, 2), 43]for i, value in enumerate(l): print(i, value)# Output:0 a1 True2 (1, 2)3 43 123456789101112131415161718# 同时引用两个变量for x, y in [(11, 12), (21, 22), (31, 32)]: print(x, y)# Output:11 1221 2231 32######################################################for x, y, z in [(11, 12, 13), (21, 22, 23), (31, 32, 33)]: print(x, y, z)# Output:11 12 1321 22 2331 32 33 迭代 Dict 键-值对类型数据 默认情况下，Dict迭代的是key，如果要迭代value，可以用 for value in d.values()如果要同时迭代key 和 value， 可以用 for k, v in d.items() 123456789101112131415161718192021222324252627282930d = &#123;&#x27;a&#x27;: &#x27;Alice&#x27;, &#x27;b&#x27;: &#x27;Boii&#x27;, &#x27;c&#x27;: &#x27;Cai&#x27;&#125;for i in d: print(i)# Output:abc#############################################d = &#123;&#x27;a&#x27;: &#x27;Alice&#x27;, &#x27;b&#x27;: &#x27;Boii&#x27;, &#x27;c&#x27;: &#x27;Cai&#x27;&#125;for i in d.values(): print(i)# Output:AliceBoiiCai#############################################d = &#123;&#x27;a&#x27;: &#x27;Alice&#x27;, &#x27;b&#x27;: &#x27;Boii&#x27;, &#x27;c&#x27;: &#x27;Cai&#x27;&#125;for k, v in d.items(): print(k, &#x27;-&#x27;, v)# Output:a - Aliceb - Boiic - Cai 列表生成式 List Comprehensions列表生成式 [ i-expression for i in Iterations ][ i-expression for i in Iterations if expression ][ i-expression if expression else expression for i in Iterations ] 123[ ··· for ··· in ··· ][ ··· for ··· in ··· if ··· ][ ··· if ··· else ··· for ··· in ··· ] 列表生成式是一种非常简洁的语法，可以大幅度的压缩代码阅读方式： [i-expression for i in Iterations]遍历迭代对象 Iterations，将每个元素 e 放到 i-expression中运算后，作为这个列表 list 的元素 [i-expression for i in Iterations if expression]遍历迭代对象 Iterations，将每个元素 e 放到 if 中的 expression中运算后，放到 i-expression 中运算，然后作为这个列表 list 的元素 [i-expression if expression else expression for i in Iterations]遍历迭代对象 Iterations，将每个元素 e 放到 if else 中的 expression中运算后，放到 i-expression 中运算，然后作为这个列表 list 的元素 for 前的 if else 可以看成三目运算符，这样比较好理解 三目运算符：True时执行 if expression else Flase时执行 对比一下：[ i-expression if expression else expression for i in Iterations ] 代入一下：[ True时执行 if expression else Flase时执行 for i in Iterations ] 一句话：原本有10个，for…if 后不一定有 10 个， if…else…for 以后有10个，不过可能不尽相同。两句话：for 前必 else，for 后不else。 注意：i-expression 的计算变量和 for 里的临时变量要相同 普通列表生成式 123456789101112131415# range(1, 11) 生成1~10 [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]# for in 遍历这10个数# 每次遍历都把当前元素拿到 i-expression 即 x * x 做相乘计算# 然后作为列表的元素# 注意 for 的临时变量是 x，i-expression 的变量也是 x，这两个要相同# 这里是计算出1~10每个数的平方&gt;&gt;&gt; [x * x for x in range(1, 11)][1, 4, 9, 16, 25, 36, 49, 64, 81, 100]# 把一个 List 中所有字符串变小写&gt;&gt;&gt; L = [&#x27;Hello&#x27;, &#x27;World&#x27;, &#x27;IBM&#x27;, &#x27;Apple&#x27;]&gt;&gt;&gt; [s.lower() for s in L][&#x27;hello&#x27;, &#x27;world&#x27;, &#x27;ibm&#x27;, &#x27;apple&#x27;] for 里带 if 筛选的列表生成式 12345678910# range(1, 11) 生成1~10 [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]# for in 遍历这10个数# 每次遍历都把当前元素拿到 if 里计算, 得到 [2, 4, 6, 8, 10]# 然后放到 i-expression 即 x * x 做相乘计算得到 [4, 16, 36, 64, 100]# 最后作为列表的元素# 这里是筛选出偶数，然后计算平方&gt;&gt;&gt; [x * x for x in range(1, 11) if x % 2 == 0][4, 16, 36, 64, 100] 双循环的列表生成式 1234# 还可以使用双循环，生成全排列&gt;&gt;&gt; [m + n for m in &#x27;ABC&#x27; for n in &#x27;XYZ&#x27;][&#x27;AX&#x27;, &#x27;AY&#x27;, &#x27;AZ&#x27;, &#x27;BX&#x27;, &#x27;BY&#x27;, &#x27;BZ&#x27;, &#x27;CX&#x27;, &#x27;CY&#x27;, &#x27;CZ&#x27;] 多变量的列表生成式 1234# 一个循环多个变量也是可以的&gt;&gt;&gt; d = &#123;&#x27;x&#x27;: &#x27;A&#x27;, &#x27;y&#x27;: &#x27;B&#x27;, &#x27;z&#x27;: &#x27;C&#x27; &#125;&gt;&gt;&gt; [k + &#x27;-&#x27; + v for k, v in d.items()][&#x27;y-B&#x27;, &#x27;x-A&#x27;, &#x27;z-C&#x27;] for 前带 if 的列表生成式 123456789101112# # range(1, 11) 生成1~10 [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]# for in 遍历这10个数# 每次遍历都把当前元素拿到 for 前的 if else三目运算符里计算# x if x % 2 == 0 else -x ,偶数正常输出, 奇数变负数，得到 [-1, 2, -3, 4, -5, 6, -7, 8, -9, 10]# 最后作为列表的元素&gt;&gt;&gt; [x if x % 2 == 0 else -x for x in range(1, 11)][-1, 2, -3, 4, -5, 6, -7, 8, -9, 10]# 再稍微改动下# 把 x if x % 2 == 0 else x + 10 看作三目运算符就很好理解&gt;&gt;&gt; [x if x % 2 == 0 else x + 10 for x in range(1, 11)][11, 2, 13, 4, 15, 6, 17, 8, 19, 10] 其他生成式除了列表生成式，还有字典生成式、元组生成式，其实现都是一样的 123&#123;k: v for k, v in d.items()&#125;&#123;k: v for k, v in d.items() if condition&#125;&#123;k: v if condition else k: -v for k, v in d.items() &#125; 元组生成式 生成一个生成器对象，下面将会讲到。 错误示范12345678910111213# for 后 if 加 else&gt;&gt;&gt; [x for x in range(1, 11) if x % 2 == 0 else 0] File &quot;&lt;stdin&gt;&quot;, line 1 [x for x in range(1, 11) if x % 2 == 0 else 0] ^SyntaxError: invalid syntax# for 前 if 不加 else&gt;&gt;&gt; [x if x % 2 == 0 for x in range(1, 11)] File &quot;&lt;stdin&gt;&quot;, line 1 [x if x % 2 == 0 for x in range(1, 11)] ^SyntaxError: invalid syntax 总结 for...in... 最先，if 或 if else 随后，i-expression 最后 for 前 if 必加 else，for 后 if 不加 else for 前 if 是对 for的输出进行处理，for 后 if 是对for的输出进行控制过滤 生成器 Generator普通形式元组生成式 生成一个生成器对象，通过for或者next遍历,遍历后，原生成器对象就不存在了 ( i-expression for i in Iterations )( i-expression for i in Iterations if expression )( i-expression if expression else expression for i in Iterations ) 123(··· for ··· in ··· )(··· for ··· in ··· if ··· )(··· if ··· else ··· for ··· in ··· ) 生成器，是一种一边循环一边计算的机制比如现在需要一个1到100W的平方的列表，用列表生成式表示为[ x * x for x in range(1000000)]但如果只需要经常访问前面几个元素，则浪费了很大的空间而生成器是保存了一种算法，它不会直接创建100W个数，而是等到调用的时候通过计算获得也就是说：列表生成式是一种缩写，生成器是一种算法 生成器 vs 列表生成式：列表生成式 是使用 []，生成器 是使用 ()列表生成式是一个列表，可以直接列出所有元素；生成器要用next()或遍历来列出所有元素 12345678910111213141516171819202122232425262728293031&gt;&gt;&gt; L = [ x * x for x in range(10)]&gt;&gt;&gt; L[0, 1, 4, 9, 16, 25, 36, 49, 64, 81]&gt;&gt;&gt; G = ( x * x for x in range(10) )&gt;&gt;&gt; G&lt;generator object &lt;genexpr&gt; at 0x00000204807D8D60&gt;&gt;&gt;&gt; next(G)0&gt;&gt;&gt; next(G)1&gt;&gt;&gt; next(G)4&gt;&gt;&gt; next(G)9&gt;&gt;&gt; next(G)16&gt;&gt;&gt; next(G)25&gt;&gt;&gt; next(G)36&gt;&gt;&gt; next(G)49&gt;&gt;&gt; next(G)64&gt;&gt;&gt; next(G)81&gt;&gt;&gt; next(G)Traceback (most recent call last): File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;StopIteration 生成器是算法，是规律，是计算方式，通过next(G)计算出G的下一个元素的值，直到最后一个元素没有更多元素的时候，抛出StopIteration错误但是这种不断调用next()的方法显然不科学， 所以一般都是用for循环 123456G = ( x * x for x in range(10) )for i in G: print(i, end=&#x27; &#x27;)# Output:0 1 4 9 16 25 36 49 64 81 函数形式生成器的另一种实现方式是 函数形式 12345def funcName(): sth while True: yield sth sth 普通函数通过return语句返回生成器通过yield语句返回，并在下次调用时从yield语句处继续yield可以看成return，都是返回一个值出去只不过使用yield在下次调用时会从yield处继续。 实例例如打印杨辉三角 1234567891011 1 / \\ 1 1 / \\ / \\ 1 2 1 / \\ / \\ / \\ 1 3 3 1 / \\ / \\ / \\ / \\ 1 4 6 4 1 / \\ / \\ / \\ / \\ / \\1 5 10 10 5 1 期待输出是这样的 12345678910# [1]# [1, 1]# [1, 2, 1]# [1, 3, 3, 1]# [1, 4, 6, 4, 1]# [1, 5, 10, 10, 5, 1]# [1, 6, 15, 20, 15, 6, 1]# [1, 7, 21, 35, 35, 21, 7, 1]# [1, 8, 28, 56, 70, 56, 28, 8, 1]# [1, 9, 36, 84, 126, 126, 84, 36, 9, 1] 实现思路：先看杨辉三角的规律：头尾都是1，中间是上一层第n个+第n+1个，每一层都是list而且第一层比较特殊，是 [1]可以先把杨辉三角核心的算法搞定。 核心算法12L = [1]L = [1] + [L[n] + L[n+1] for n in range(len(L)-1)] +[1] [1] + [L[n] + L[n+1] for n in range(len(L)-1)] +[1] 就是核心算法了把他拆开来看，可以发现这个表达式是由中间段加上头尾的 [1] 组成的 再看中间段 [L[n] + L[n+1] for n in range(len(L)-1)]这是一个列表生成式range(len(L)-1)会生成 0 1 2 … 假设当前为第5层，准备生成 [1, 4, 6, 4, 1]当前的 L 是 [1, 3, 3, 1]，那么len(L)则是4，range(len(L) - 1)则等价于range(3),会生成 0 1 2 [L[n] + L[n+1] for n in range(len(L)-1)]则等价于[L[0]+L[1], L[1]+L[2], L[2]+L[3]] 则等价于[ 1 + 3, 3 + 3, 3 + 1 ]则等价于[4, 6, 4] 正好就是中间段再加上头尾两个 [1]： [1, 4, 6, 4, 1] 做成生成器因为第一层 特殊，所以用小括号列表生成式()做不出来，改用函数形式 12345def triangles(): L = [1] while True: yield L L = [1] + [L[x]+L[x+1] for x in range(len(L)-1)] + [1] 第一次迭代生成器triangles时，会执行 L = [1]，然后进入循环，遇到yield L把L返回出去 第二次迭代生成器triangles时，会从yield L处继续，然后执行核心算法 L = [1] + [L[x]+L[x+1] for x in range(len(L)-1)] + [1]之后继续循环，又遇到yield L，把更新过的 L 返回出去 接着第三次，第四次… 其实有点类似 C 语言中被static修饰的局部变量，函数调用完不会被销毁，程序结束才销毁 遍历输出12345for n, t in enumerate(triangles()): results.append(t) n += 1 if n == 10: break 生成器也是一个可迭代对象，所以可以用 for...in...来迭代输出enumerate()赋予了对应的下标这个生成器可以无限循环下去，可以获得无穷层，这里打印10层作为示范即可 最后可以得到期待输出： 12345678910[1][1, 1][1, 2, 1][1, 3, 3, 1][1, 4, 6, 4, 1][1, 5, 10, 10, 5, 1][1, 6, 15, 20, 15, 6, 1][1, 7, 21, 35, 35, 21, 7, 1][1, 8, 28, 56, 70, 56, 28, 8, 1][1, 9, 36, 84, 126, 126, 84, 36, 9, 1] 完整代码1234567891011121314151617181920212223242526272829303132def triangles(): L = [1] while True: yield L L = [1] + [L[x]+L[x+1] for x in range(len(L)-1)] + [1]results = []for n, t in enumerate(triangles()): results.append(t) n += 1 if n == 10: breakfor t in results: print(t)if results == [ [1], [1, 1], [1, 2, 1], [1, 3, 3, 1], [1, 4, 6, 4, 1], [1, 5, 10, 10, 5, 1], [1, 6, 15, 20, 15, 6, 1], [1, 7, 21, 35, 35, 21, 7, 1], [1, 8, 28, 56, 70, 56, 28, 8, 1], [1, 9, 36, 84, 126, 126, 84, 36, 9, 1]]: print(&#x27;测试通过!&#x27;)else: print(&#x27;测试失败!&#x27;) 总结普通形式-生成器：把列表生成式的[]换成()函数形式-生成器：函数中带yield，下一次调用时会从yield处继续 迭代器 Iterator 可以被next()函数调用并不断返回下一个值的对象称为迭代器：Iterator。 可迭代对象：可以直接作用于 for 循环的对象统称为可迭代对象Iterable可迭代对象Iterable： List、Tuple、Dict、Set、String； 生成器Generator、带yield的Generator Function 可以用isinstance(obj, Iterable)判断是否是可迭代对象 迭代器：不但可以作用于 for 循环，还可以被next()函数调用并不断返回下一个值则称为迭代器：Iterator。生成器Generator、带yield的Generator Function就是迭代器可以用isinstance(obj, Iterator)判断是否是迭代器 所以：Generator、Generator Function 既是 Iterator，也是 Iterable而 List、Tuple、Dict、Set、String 仅仅只是 Iterable，但是，使用iter()函数可以使他们变成迭代器Iterator 1234&gt;&gt;&gt; isinstance(iter([]), Iterator)True&gt;&gt;&gt; isinstance(iter(&#x27;Boii&#x27;), Iterator)True 迭代器的本质Python的Iterator对象表示的是一个数据流，Iterator对象可以被next()函数调用并不断返回下一个数据，直到没有数据时抛出StopIteration错误。可以把这个数据流看做是一个有序序列，但我们却不能提前知道序列的长度只能不断通过next()函数实现按需计算下一个数据，所以Iterator的计算是惰性的，只有在需要返回下一个数据时它才会计算 自定义可迭代类只要类中实现了__iter__()方法，这个类的对象就是可迭代对象Iterable。只要类中实现了__iter__()和__next__()方法，这个类就是个迭代器Iteratorn。 __iter__()方法必须返回一个迭代器。那么代码就是这样子： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051# 1. 创建一个类class Classmate: def __init__(self): self.names = list() def add(self, value): self.names.append(value) # 2. 实现__iter__方法，返回一个迭代器 def __iter__(self): &quot;&quot;&quot;只有实现了__iter__方法，才能可迭代&quot;&quot;&quot; return ClassmateIterator(self) # __iter__ 必须返回一个迭代器对象# 3. 创建一个迭代器class ClassmateIterator: &quot;&quot;&quot;实现了__iter__和__next__方法，才是一个迭代器&quot;&quot;&quot; def __init__(self, obj): self.obj = obj self.current_num = 0 # 4. 迭代器需要实现 __iter__, __next__方法 def __iter__(self): pass def __next__(self): &quot;&quot;&quot;实现了__iter__和__next__方法，才是一个迭代器&quot;&quot;&quot; if self.current_num &lt; len(self.obj.names): res = self.obj.names[self.current_num] self.current_num += 1 return res else: raise StopIterationif __name__ == &#x27;__main__&#x27;: clsm = Classmate() clsm.add(123) clsm.add(456) clsm.add(789) # 通过循环检查classmate对象是否可迭代 for i in clsm: print(i)--------------------------------------------------# Output:123456789 总结起来就是：创建一个类并实现__iter__()方法去返回一个迭代器创建一个类并实现__iter__()和__next__()方法，使其成为迭代器。 这样看起来好像为了实现一个迭代器又生成了一个迭代器既然我是想造一个迭代器，__iter__()方法有需要返回一个迭代器对象，那我返回自己不行吗？ 可以！ 1234567891011121314151617181920212223242526272829303132333435363738394041# 1. 创建一个类class Classmate: def __init__(self): self.names = list() self.current_num = 0 def add(self, value): self.names.append(value) # 2. 实现__iter__方法，返回一个迭代器 def __iter__(self): &quot;&quot;&quot;只有实现了__iter__方法，才能可迭代&quot;&quot;&quot; return self # __iter__ 必须返回一个迭代器对象，这里就返回自己就行 # 3. 实现__next__方法，这个方法会在外部使用next(Iterator)时调用。 def __next__(self): &quot;&quot;&quot;实现了__iter__和__next__方法，才是一个迭代器&quot;&quot;&quot; if self.current_num &lt; len(self.names): res = self.names[self.current_num] self.current_num += 1 return res else: raise StopIterationif __name__ == &#x27;__main__&#x27;: clsm = Classmate() clsm.add(123) clsm.add(456) clsm.add(789) # 通过循环检查classmate对象是否可迭代 for i in clsm: print(i)--------------------------------------------------# Output:123456789 总结 可迭代对象和迭代器，通过函数iter()转换 迭代器：数据流，变长，惰性的 继承关系：Iterable&gt;Iterator&gt;Generator(参考python doc) Iterable：list、tuple、dict、set、str、Iterator、Generator等 Iterator转化成Iterator：Iterator=iter(Iterable) 自定义迭代类时必须实现__iter__()和__next__()方法 __iter__()方法必须返回一个迭代器","categories":[{"name":"Python","slug":"Python","permalink":"https://www.boii.xyz/categories/Python/"},{"name":"高级特性","slug":"Python/高级特性","permalink":"https://www.boii.xyz/categories/Python/%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7/"}],"tags":[{"name":"Python","slug":"Python","permalink":"https://www.boii.xyz/tags/Python/"}]},{"title":"Python【Type】String","slug":"Python【No-Type】String","date":"2020-07-12T03:17:48.000Z","updated":"2021-05-22T13:37:47.740Z","comments":true,"path":"2020/07/12/Python【No-Type】String/","link":"","permalink":"https://www.boii.xyz/2020/07/12/Python%E3%80%90No-Type%E3%80%91String/","excerpt":"关于String的详细笔记","text":"关于String的详细笔记 12345678910111213141516a = &#x27;hello&#x27;b = &quot;good&quot;c = &quot;&quot;&quot; 哈哈哈 &quot;&quot;&quot;d = &#x27;&#x27;&#x27; 呵呵呵 &#x27;&#x27;&#x27;str1 = &#x27;OK&#x27; # OKstr2 = &quot;OK&quot; # OKstr3 = &#x27;&#x27;&#x27;I&#x27;m OK.&#x27;&#x27;&#x27; # I&#x27;m OK.str4 = &quot;&quot;&quot;哈哈哈&quot;&quot;&quot; # 哈哈哈str4 = &quot;I&#x27;m ok.&quot; # I&#x27;m ok.str5 = &#x27;I\\&#x27;m ok.&#x27; # I&#x27;m ok.str6= &quot;I\\&quot;m ok.&quot; # I&quot;m ok.str7 = &#x27;I&quot;m ok.&#x27; # I&quot;m ok.str8 = &quot;&quot;&quot;I&#x27;m &quot;Iron Man&quot;.&quot;&quot;&quot; # I&#x27;m &quot;Iron Man&quot;.str9 = r&#x27;ab\\ncd&#x27; # ab\\ncdstr0 = R&#x27;ab\\ncd&#x27; # ab\\ncd 1234567891011str_1 = &#x27;&#x27;&#x27;这是一个段落，所以可以直接换行，不需反斜杠来声明语句未结束 直到遇到下一个三单引号，才认为结束但是换行会跟着换行，空格会跟着空格&#x27;&#x27;&#x27;&quot;&quot;&quot;str_1输出为：这是一个段落，所以可以直接换行，不需反斜杠来声明语句未结束 直到遇到下一个三单引号，才认为结束但是换行会跟着换行，空格会跟着空格&quot;&quot;&quot; 12345678910111213141516\\n 换行 \\t 缩进# 使用转义字符str_2 = &#x27;ab\\ncd&#x27;&#x27;&#x27;&#x27;str_2输出为：abcd&#x27;&#x27;&#x27;r&#x27;字符串&#x27; 表示不转义# 不转义str_3 = r&#x27;ab\\ncd&#x27; # ab\\ncd 转义字符 转义字符 描述 \\ 续行符 \\ 反斜杠 &#39; 单引号 &quot; 双引号 \\a 响铃 \\b 退格 \\e 转义 \\000 空 \\n 换行 \\v 纵向制表符 \\t 横向制表符 \\r 回车 \\f 换页 \\o 八进制 \\x 十六进制 下标123| P | y | t | h | o | n | 0 1 2 3 4 5 -6 -5 -4 -3 -2 -1 查找 find、index、rfind、rindex s.find(sub[, start[, end]) -&gt; ints.rfind(sub[, start[, end]) -&gt; ints.index(sub[, start[, end]) -&gt; ints.rindex(sub[, start[, end]) -&gt; int 没r找第一个，有r找最后一个find找不到返回-1，index找不到报错 12345678910s = &#x27;abcdefghijkl abundance gg&#x27;print(s.find(&#x27;g&#x27;)) # 返回字符串中第一个 g 的下标：6print(s.find(&#x27;z&#x27;)) # 找不到则返回 -1print(s.index(&#x27;g&#x27;)) # 返回字符串中第一个 g 的下标：6print(s.index(&#x27;z&#x27;)) # 找不到则报错print(s.rfind(&#x27;g&#x27;)) # 返回字符串中最后一个 g 的下标：24print(s.rfind(&#x27;z&#x27;)) # 找不到则返回 -1print(s.rindex(&#x27;g&#x27;)) # 返回字符串中最后一个 g 的下标：24print(s.rindex(&#x27;z&#x27;)) # 找不到则报错 判断 方法名 描述 startswith(value) 判断是否以 value 开始 endswith(value) 判断是否以 value 结束 isalpha() 判断是否全是字母 isdigit() 判断是否全是数字 isalnum() 判断是否全是字母或数字或字母+数字 isdecimal() 判断是否全是浮点数 isnumeric() 判断是否全是数值 islower() 判断是否全小写 isupper() 判断是否全大写 isspace() 判断是否全空格或\\t或\\n或\\r istitle() 判断是否所有单词都是首字母大写 isdigit() VS isdecimal() VS isnumeric()isdigit()True: Unicode数字，byte数字（单字节），全角数字（双字节），罗马数字False: 汉字数字Error: 无 isdecimal()True: Unicode数字，，全角数字（双字节）False: 罗马数字，汉字数字Error: byte数字（单字节） isnumeric()True: Unicode数字，全角数字（双字节），罗马数字，汉字数字False: 无Error: byte数字（单字节） 计数 count s.count(sub[, start[, end]) -&gt; int 12s = &#x27;abcdefghijkl abundance gg&#x27;print(s.count(&#x27;g&#x27;)) # 3. 字母 g 一共出现了3次 替换 replace s.replace(old, new[, count]) -&gt; str替换字符串中指定的内容，如果指定次数count， 则替换不会超过count次。 123s = &#x27;abcdefghijkl abundance gg&#x27;print(s.replace(&#x27;g&#x27;, &#x27;*&#x27;)) # abcdef*hijkl abundance **print(s.replace(&#x27;g&#x27;, &#x27;*&#x27;, 2)) # abcdef*hijkl abundance *g 分割 split、rsplit、partition、rpartition、splitlines s.split(sep[, maxsplit]) -&gt; list[str]：按 sep 分割，从左边开始，只分割两次s.rsplit(sep[, maxsplit]) -&gt; list[str]：按 sep 分割，从右边开始，只分割两次s.patition(sep) -&gt; tuple(str, str, str)：按 sep 分割，从左边开始，分成 (前部，分割符号，后部)s.rpartition(sep) -&gt; tuple(str, str, str)：按 sep 分割，从右边开始，分成 (前部，分割符号，后部) 1234567891011s1 = &#x27;Alice,Boii,Candy,Dannis,Eva,Fiona&#x27;print(s1.split(&#x27;,&#x27;)) # [&#x27;Alice&#x27;, &#x27;Boii&#x27;, &#x27;Candy&#x27;, &#x27;Dannis&#x27;, &#x27;Eva&#x27;, &#x27;Fiona&#x27;]print(s1.split(&#x27;,&#x27;, 2)) # [&#x27;Alice&#x27;, &#x27;Boii&#x27;, &#x27;Candy,Dannis,Eva,Fiona&#x27;]print(s1.rsplit(&#x27;,&#x27;, 2)) # [&#x27;Alice,Boii,Candy,Dannis&#x27;, &#x27;Eva&#x27;, &#x27;Fiona&#x27;]s2 = &#x27;2020.8.8拍摄.mp4&#x27;print(s2.partition(&#x27;.&#x27;)) # (&#x27;2020&#x27;, &#x27;.&#x27;, &#x27;8.8拍摄.mp4&#x27;)print(s2.rpartition(&#x27;.&#x27;)) # (&#x27;2020.8.8拍摄&#x27;, &#x27;.&#x27;, &#x27;mp4&#x27;) s.splitlines([keepends]) -&gt; list[str]：按换行符（\\n，\\r，\\r\\n）分割keepends – 在输出结果里是否保留换行符(‘\\r’, ‘\\r\\n’, \\n’)，默认为 False，不包含换行符，如果为 True，则保留换行符。 12345str1 = &#x27;ab c\\n\\nde fg\\rkl\\r\\n&#x27;print(str1.splitlines()) # [&#x27;ab c&#x27;, &#x27;&#x27;, &#x27;de fg&#x27;, &#x27;kl&#x27;]str2 = &#x27;ab c\\n\\nde fg\\rkl\\r\\n&#x27;print(str2.splitlines(True)) # [&#x27;ab c\\n&#x27;, &#x27;\\n&#x27;, &#x27;de fg\\r&#x27;, &#x27;kl\\r\\n&#x27;] 切片从字符串里截取一段指定的内容，生成一个新的字符串切片都是包头不包尾 具体参考 高级特性-&gt;切片 转换大小写12345678910s = &#x27;hello woRlD.good mornIng&#x27;# 将第一个字符转成大写，其他字符转成小写print(s.capitalize()) # Hello world.good morning# 将全部字符转成大写print(s.upper()) # HELLO WORLD.GOOD MORNING# 将全部字符转成小写print(s.lower()) # hello world.good morning# 将每个单词首字母转成大写print(s.title()) # Hello World.Good Morning 填充 s.ljust(weight, fillchar=&#39;&#39;) -&gt; strs.rjust(weight, fillchar=&#39;&#39;) -&gt; strs.center(weight, fillchar=&#39;&#39;) -&gt; str 不足 weight 的话，用 fillchar 填充，fillchar默认空格 123456print(&#x27;|&#x27; + &#x27;Monday&#x27;.ljust(10) + &#x27;|&#x27;) # |Monday |print(&#x27;|&#x27; + &#x27;Monday&#x27;.ljust(10, &#x27;^&#x27;) + &#x27;|&#x27;) # |Monday^^^^|print(&#x27;|&#x27; + &#x27;Monday&#x27;.rjust(10) + &#x27;|&#x27;) # | Monday|print(&#x27;|&#x27; + &#x27;Monday&#x27;.rjust(10, &#x27;#&#x27;) + &#x27;|&#x27;) # |####Monday|print(&#x27;|&#x27; + &#x27;Friday&#x27;.center(20, &#x27;*&#x27;) + &#x27;|&#x27;) # |*******Friday*******|print(&#x27;|&#x27; + &#x27;Friday&#x27;.center(4, &#x27;*&#x27;) + &#x27;|&#x27;) # |Friday| 修剪 s.lstrip(chars) -&gt; strs.rstrip(chars) -&gt; strs.strip(chars) -&gt; str 删除字符串 左边 / 右边 / 左边+右边 的 chars 字符 1234567print(&#x27;|&#x27; + &#x27; Couldy Sunny &#x27;.lstrip() + &#x27;|&#x27;) # |Couldy Sunny |print(&#x27;|&#x27; + &#x27; Couldy Sunny &#x27;.rstrip() + &#x27;|&#x27;) # | Couldy Sunny|print(&#x27;|&#x27; + &#x27; Couldy Sunny &#x27;.strip() + &#x27;|&#x27;) # |Couldy Sunny|print(&#x27;|&#x27; + &#x27; Couldy+Sunny+++&#x27;.lstrip(&#x27;+&#x27;) + &#x27;|&#x27;) # | Couldy+Sunny+++|print(&#x27;|&#x27; + &#x27; Couldy+Sunny+++&#x27;.rstrip(&#x27;+&#x27;) + &#x27;|&#x27;) # | Couldy+Sunny|print(&#x27;|&#x27; + &#x27; Couldy+Sunny+++&#x27;.strip(&#x27;+&#x27;) + &#x27;|&#x27;) # | Couldy+Sunny| 拼接 s.join(iterable) -&gt; str将 s 拼接到 iterable 的每一个元素上 1234567li = [&#x27;Alice&#x27;, &#x27;Boii&#x27;, &#x27;Candy&#x27;, &#x27;Dannis&#x27;, &#x27;Eva&#x27;, &#x27;Fiona&#x27;]print(&#x27; - &#x27;.join(li)) # Alice - Boii - Candy - Dannis - Eva - Fionaprint(&#x27;+&#x27;.join(&#x27;Hello&#x27;)) # H+e+l+l+odic = &#123;&#x27;name1&#x27;: &#x27;Alice&#x27;, &#x27;name2&#x27;: &#x27;Boii&#x27;&#125;print(&#x27; - &#x27;.join(dic)) # name1 - name2 编码 ASCII 0~127共128个，占用 1byte 即 8bit 的长度，共使用了7位的长度，从0000 0000 到 0111 1111。 48-57 -&gt; 0-9，65-90 -&gt; A-Z，97-122 -&gt; a-z ISO-8859-1 0255共256个，占用 1byte 即 8bit 的长度，共使用了8位的长度，从 0000 0000到1111 1111。 0127与ASCII完全兼容，128~255是一些欧洲字母 Unicode 万国码，汉字每个占 3byte GBK 国标扩，汉字每个占 2byte 长度格式化不可变性字符串是不可变对象。当执行一个 str = &#39;abc&#39; 的语句时，python在字符串池中创建了一个字符串 &#39;abc&#39; ，然后在内存中创建一个变量 str指向字符串池中的 &#39;abc&#39; 如果对str进行修改 str = &#39;xyz&#39;python会在字符串池中再创建一个字符串 &#39;xyz&#39;，然后让变量 str 指向字符串池中的 &#39;xyz&#39;此时字符串池其实有 &#39;abc&#39; 和 &#39;xyz&#39;，只不过&#39;abc&#39;没有被指向， &#39;xyz&#39; 被str指向 所以，对于不变对象来说，调用对象自身的任意方法，也不会改变该对象自身的内容。相反，这些方法会创建新的对象并返回这样，就保证了不可变对象本身永远是不可变的。","categories":[{"name":"Python","slug":"Python","permalink":"https://www.boii.xyz/categories/Python/"},{"name":"基础","slug":"Python/基础","permalink":"https://www.boii.xyz/categories/Python/%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"Python","slug":"Python","permalink":"https://www.boii.xyz/tags/Python/"}]},{"title":"Python【No-6】函数","slug":"Python【No-6】函数","date":"2020-07-11T03:17:48.000Z","updated":"2021-05-22T13:37:47.723Z","comments":true,"path":"2020/07/11/Python【No-6】函数/","link":"","permalink":"https://www.boii.xyz/2020/07/11/Python%E3%80%90No-6%E3%80%91%E5%87%BD%E6%95%B0/","excerpt":"一等公民：函数","text":"一等公民：函数 定义函数123def functionName(paramters): function body [return] 调用函数1funcName([paras]) 返回值 不管有没有 return 函数都会返回有 return 时函数返回相应的值没有 return 时函数返回 None return None 可以简写为 return 返回多个值python 函数可以返回多个值但其本质其实是返回一个多元素的Tuple，因为语法上tuple可以省略括号，所以看起来像返回多个值如果显式的返回一个list，dict，tuple，set，则是返回值本身 1234567891011121314import mathdef move(x, y, step, angle=0): nx = x + step * math.cos(angle) ny = y - step * math.sin(angle) return nx, ny&gt;&gt;&gt; x, y = move(100, 100, 60, math.pi / 6)&gt;&gt;&gt; print(x, y)151.96152422706632 70.0&gt;&gt;&gt; r = move(100, 100, 60, math.pi / 6)&gt;&gt;&gt; print(r)(151.96152422706632, 70.0) 空函数 空函数可以作为占位符，比如现在还没想好怎么写函数的代码，就可以先放一个pass，让代码能运行起来。 12def func(): pass 参数参数检查 python解释器会检查参数 个数 ，但不会检查参数 类型类型检查需要自己做可以使用内置函数 isinstance(obj,class_of_tuple) 并抛出错误 12345678def my_abs(x): return x if x &gt;= 0 else -x# 添加检查类型def my_abs(x): if not isinstance(x, (int, float)): # 检查类型 raise TypeError(&#x27;bad operand type&#x27;) # 抛出错误 return x if x &gt;= 0 else -x isinstance() isinstance(被检查对象,检查类型元组)isinstance() 接受两个参数，第一个是被检查对象，第二个是要求的类型元组类型元组中只要有一个被满足，则返回True，反之返回False 默认参数、可变参数和关键字参数默认参数 = def funcName( [para1 ... ,] paraN = defaultValue)当参数的值不确定的时候，就可以使用默认参数 默认参数 para1 = defaultValue 必须放在最后面当有多个默认参数的情况下，想指定某个默认参数不使用默认，可以将默认参数的形参名带上默认参数必须指向不变对象！ 12345678910111213def power(x,n=2): s = 1 while n &gt; 0: s *= x n -= 1 return s&gt;&gt;&gt; power(5)25&gt;&gt;&gt; power(5, 2)25&gt;&gt;&gt; power(5, 3)125 当有多个默认参数的情况下，想指定某个默认参数不使用默认，可以将默认参数的形参名带上 1234567891011121314151617181920212223242526def enroll(name, gender, age=6, city=&#x27;SWA&#x27;): print(name) print(gender) print(age) print(city)&gt;&gt;&gt; enroll(&#x27;Boii&#x27;, &#x27;M&#x27;, 23, &#x27;BJ&#x27;)BoiiM23BJ&gt;&gt;&gt; enroll(&#x27;Boii&#x27;, &#x27;M&#x27;, 23)BoiiM23SWA&gt;&gt;&gt; enroll(&#x27;Boii&#x27;, &#x27;M&#x27;, city=&#x27;NJ&#x27;)BoiiM6NJ&gt;&gt;&gt; enroll(&#x27;Boii&#x27;, &#x27;M&#x27;)BoiiM6SWA 默认参数必须指向不变对象！ 1234567891011121314def add_end(L=[]): L.append(&#x27;END&#x27;) return L&gt;&gt;&gt; add_end([1,2,3])[1,2,3,&#x27;END&#x27;]&gt;&gt;&gt; add_end([&#x27;x&#x27;, &#x27;y&#x27;, &#x27;z&#x27;])[&#x27;x&#x27;, &#x27;y&#x27;, &#x27;z&#x27;, &#x27;END&#x27;]# 坑来了&gt;&gt;&gt; add_end()[&#x27;END&#x27;] # 这里还是正常的&gt;&gt;&gt; add_end()[&#x27;END&#x27;, &#x27;END&#x27;] # 这里就不正常了 猜测可能是python内部在使用默认参数的时候会创建对象，比如这个list，但是这个对象不会被销毁导致的 改进： 12345678910def add_end(L=None) if L is None: L = [] L.append(&#x27;END&#x27;) return L &gt;&gt;&gt; add_end()[&#x27;END&#x27;]&gt;&gt;&gt; add_end()[&#x27;END&#x27;] 可变参数 * 可变参数可以接收 0~N个参数 def funcName( [para1 ... ,] *paraN)当参数的个数不确定的时候，就可以使用可变参数 *paraN形参和实参都可以使用可变参数。形参 使用可变参数，则是告诉调用者我可以接受0~N个参数，实参 使用可变参数，则是告诉函数我已经打包好了。 可变参数的 实际原理：其实可变参数在函数被调用时，将所有参数自动打包成一个tuple，然后传递给函数函数接收到之后再解构这个tuple，或者通过 for 迭代 遍历这个tuple来使用里面的元素 12345678910111213141516def calc(*numbers): # 形参 使用可变参数，则是告诉调用者我可以接受0~N个参数 sum = 0 for n in numbers: sum += n*n return sum&gt;&gt;&gt; calc(1, 2)5&gt;&gt;&gt; calc()0&gt;&gt;&gt; nums = [1, 2, 3]&gt;&gt;&gt; calc(nums[0], nums[1], nums[2]) # 这种分散一个个的参数在传递之前也是被自动打包成一个tuple的14&gt;&gt;&gt; calc(*nums) # 实参 使用可变参数，则是告诉函数我已经打包好了14 关键字参数 ** 这种方式，调用者可以传入 0~N 个关键字参数，关键字 key 随意 def funcName( [para1 ... ,] **key_paraN)即通过关键字来指定参数，或者说通过键-值对的方式来传实参而在函数里，形参 关键字参数 **paraN 将传过来的这些键-值对打包成一个dict 其原理跟可变参数类似 可变参数 *paraN 是把 除了必选参数外的所有参数 打包成一个tuple传给函数 关键字参数 **paraN 是把 除了必选参数外的所有参数 打包成一个dict传给函数 之后函数内部可以通过 for 迭代 遍历这个dict来使用里面的键-值对因为是使用键-值对的方式，所以传参时的 传给关键字参数的参数顺序是无所谓的 123456789101112131415161718192021222324def person(name, age, **kv): print(&#x27;name:&#x27;, name, &#x27;--&#x27; , &#x27;age:&#x27;, age, &#x27;--&#x27; , &#x27;other:&#x27; kv)# 只填必选参数的调用方法&gt;&gt;&gt; person(&#x27;Boii&#x27;, 23)name: Boii -- age: 23 -- other: &#123;&#125;# 填了必选参数和自定义参数的调用方法&gt;&gt;&gt; person(&#x27;Boii&#x27;, 23, city=&#x27;SWA&#x27;)name: Boii -- age: 23 -- other: &#123;&#x27;city&#x27;:&#x27;SWA&#x27;&#125;&gt;&gt;&gt; person(&#x27;Adam&#x27;, 45, gender=&#x27;M&#x27;, job=&#x27;Engineer&#x27;)name: Adam -- age: 45 -- other: &#123;&#x27;gender&#x27;: &#x27;M&#x27;, &#x27;job&#x27;: &#x27;Engineer&#x27;&#125;# 关键字实参的顺序无所谓&gt;&gt;&gt; person(&#x27;Adam&#x27;, 45, job=&#x27;Engineer&#x27;, gender=&#x27;M&#x27;)name: Adam -- age: 45 -- other: &#123;&#x27;job&#x27;: &#x27;Engineer&#x27;, &#x27;gender&#x27;: &#x27;M&#x27;&#125;# 还可以自己把参数打包成dict，然后传给函数, 原理和可变参数类似&gt;&gt;&gt; d = &#123;&#x27;job&#x27;: &#x27;Engineer&#x27;, &#x27;gender&#x27;: &#x27;M&#x27;&#125;&gt;&gt;&gt; person(&#x27;Adam&#x27;, 45, **d)name: Adam -- age: 45 -- other: &#123;&#x27;job&#x27;: &#x27;Engineer&#x27;, &#x27;gender&#x27;: &#x27;M&#x27;&#125; 命名关键字参数 *， def funcName( [para1 ... ,] *, key_paraN)对比关键字参数 ↓def funcName( [para1 ... ,] **key_paraN) 区别于关键字参数： 如果想要求调用者在调用的时候必须用你给的 key，则可以用 命名关键字参数 *, key_paraN 这种方式，调用者必须 遵循个数 和 关键字 123456789101112131415161718def person(*, city, nationality): print(&#x27;city:&#x27;, city) print(&#x27;nationality:&#x27;, nationality)&gt;&gt;&gt; person(city=&#x27;SWA&#x27;, nationality=&#x27;China&#x27;)city: SWAnationality: China&gt;&gt;&gt; person(nationality=&#x27;China&#x27;, city=&#x27;SWA&#x27;)city: SWAnationality: China# 错误示例&gt;&gt;&gt; person()TypeError: person() missing 2 required keyword-only arguments: &#x27;city&#x27; and &#x27;nationality&#x27;&gt;&gt;&gt; person(&#x27;SWA&#x27;, &#x27;China&#x27;)TypeError: person() takes 0 positional arguments but 2 were given 123456789101112131415161718192021def person(name, age, *, city, nationality): print(&#x27;name:&#x27;, name) print(&#x27;age:&#x27;, age) print(&#x27;city:&#x27;, city) print(&#x27;nationality:&#x27;, nationality)&gt;&gt;&gt; person(&#x27;Boii&#x27;, 23, city=&#x27;SWA&#x27;, nationality=&#x27;China&#x27;)name: Boiiage: 23city: SWAnationality: China&gt;&gt;&gt; person(&#x27;Boii&#x27;, 23, nationality=&#x27;China&#x27;, city=&#x27;SWA&#x27;)name: Boiiage: 23city: SWAnationality: China# 错误示例&gt;&gt;&gt; person(city=&#x27;SWA&#x27;, nationality=&#x27;China&#x27;)TypeError: person() missing 2 required positional arguments: &#x27;name&#x27; and &#x27;age&#x27; 参数组合 在Python中定义函数，可以用必选参数、默认参数、可变参数、关键字参数和命名关键字参数这5种参数都可以组合使用。但是请注意，参数定义的顺序必须是：必选参数、默认参数、可变参数、命名关键字参数和关键字参数。 123456789101112131415161718192021def f1(a, b, c=0, *args, **kw): print(&#x27;a =&#x27;, a, &#x27;b =&#x27;, b, &#x27;c =&#x27;, c, &#x27;args =&#x27;, args, &#x27;kw =&#x27;, kw)def f2(a, b, c=0, *, d, **kw): print(&#x27;a =&#x27;, a, &#x27;b =&#x27;, b, &#x27;c =&#x27;, c, &#x27;d =&#x27;, d, &#x27;kw =&#x27;, kw)&gt;&gt;&gt; f1(1, 2)a = 1 b = 2 c = 0 args = () kw = &#123;&#125;&gt;&gt;&gt; f1(1, 2, c=3)a = 1 b = 2 c = 3 args = () kw = &#123;&#125;&gt;&gt;&gt; f1(1, 2, 3, &#x27;a&#x27;, &#x27;b&#x27;)a = 1 b = 2 c = 3 args = (&#x27;a&#x27;, &#x27;b&#x27;) kw = &#123;&#125;&gt;&gt;&gt; f1(1, 2, 3, &#x27;a&#x27;, &#x27;b&#x27;, x=99)a = 1 b = 2 c = 3 args = (&#x27;a&#x27;, &#x27;b&#x27;) kw = &#123;&#x27;x&#x27;: 99&#125;&gt;&gt;&gt; f2(1, 2, d=99, ext=None)a = 1 b = 2 c = 0 d = 99 kw = &#123;&#x27;ext&#x27;: None&#125; 最神奇的是通过一个tuple和dict，你也可以调用上述函数： 1234567891011121314151617181920def f1(a, b, c=0, *args, **kw): print(&#x27;a =&#x27;, a, &#x27;b =&#x27;, b, &#x27;c =&#x27;, c, &#x27;args =&#x27;, args, &#x27;kw =&#x27;, kw)def f2(a, b, c=0, *, d, **kw): print(&#x27;a =&#x27;, a, &#x27;b =&#x27;, b, &#x27;c =&#x27;, c, &#x27;d =&#x27;, d, &#x27;kw =&#x27;, kw)&gt;&gt;&gt; args = (1, 2, 3, 4)&gt;&gt;&gt; kw = &#123;&#x27;d&#x27;: 99, &#x27;x&#x27;: &#x27;#&#x27;&#125;&gt;&gt;&gt; f1(*args, **kw)a = 1 b = 2 c = 3 args = (4,) kw = &#123;&#x27;d&#x27;: 99, &#x27;x&#x27;: &#x27;#&#x27;&#125;&gt;&gt;&gt; args = (1, 2, 3)&gt;&gt;&gt; kw = &#123;&#x27;d&#x27;: 88, &#x27;x&#x27;: &#x27;#&#x27;&#125;&gt;&gt;&gt; f2(*args, **kw)a = 1 b = 2 c = 3 d = 88 kw = &#123;&#x27;x&#x27;: &#x27;#&#x27;&#125; 所以，对于任意函数，都可以通过类似func(*args, **kw)的形式调用它，无论它的参数是如何定义的。！！虽然可以组合多达5种参数，但不要同时使用太多的组合，否则函数接口的可理解性很差。 递归函数 自己调用自己递归要素： 自己调用自己 有判断条件 （没判断就死循环了，会导致溢出） 有变量迭代 （没变量迭代就死循环了） 1234567def fact(n): return 1 if n == 1 else n * fact(n-1)&gt;&gt;&gt; fact(5)120&gt;&gt;&gt; fact(10)3628800 计算 fact(5) 的时候 ===&gt; fact(5)===&gt; 5 * fact(4)===&gt; 5 * (4 * fact(3))===&gt; 5 * (4 * (3 * fact(2)))===&gt; 5 * (4 * (3 * (2 * fact(1))))===&gt; 5 * (4 * (3 * (2 * 1)))===&gt; 5 * (4 * (3 * 2))===&gt; 5 * (4 * 6)===&gt; 5 * 24===&gt; 120","categories":[{"name":"Python","slug":"Python","permalink":"https://www.boii.xyz/categories/Python/"},{"name":"基础","slug":"Python/基础","permalink":"https://www.boii.xyz/categories/Python/%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"Python","slug":"Python","permalink":"https://www.boii.xyz/tags/Python/"}]},{"title":"Python【No-5】运算符","slug":"Python【No-5】运算符","date":"2020-07-10T09:28:48.000Z","updated":"2021-05-22T13:37:47.727Z","comments":true,"path":"2020/07/10/Python【No-5】运算符/","link":"","permalink":"https://www.boii.xyz/2020/07/10/Python%E3%80%90No-5%E3%80%91%E8%BF%90%E7%AE%97%E7%AC%A6/","excerpt":"基础难点：运算符","text":"基础难点：运算符 算术运算符以下假设变量a为10，变量b为21： 运算符 描述 实例 + 加 两个对象相加 a + b 输出结果 31 - 减 得到负数或是一个数减去另一个数 a - b 输出结果 -11 * 乘 两个数相乘或是返回一个被重复若干次的字符串 a * b 输出结果 210 / 除 x 除以 y b / a 输出结果 2.1 % 取模 返回除法的余数 b % a 输出结果 1 ** 幂 返回x的y次幂 a**b 为10的21次方 // 取整除 向下取接近商的整数 -9//2输出结果为-5 比较运算符以下假设变量a为10，变量b为20： 运算符 描述 实例 == 等于 比较对象是否相等 (a == b) 返回 False。 != 不等于 比较两个对象是否不相等 (a != b) 返回 True。 &gt; 大于 返回x是否大于y (a &gt; b) 返回 False。 &lt; 小于 返回x是否小于y (a &lt; b) 返回 True。 &gt;= 大于等于 返回x是否大于等于y。 (a &gt;= b) 返回 False。 &lt;= 小于等于 返回x是否小于等于y。 (a &lt;= b) 返回 True。 所有比较运算符返回1表示真，返回0表示假。这分别与特殊的变量True和False等价。注意，这些变量名的大写。 赋值运算符以下假设变量a为10，变量b为20： 运算符 描述 实例 = 简单的赋值运算符 c = a + b 将 a + b 的运算结果赋值为 c += 加法赋值运算符 c += a 等效于 c = c + a -= 减法赋值运算符 c -= a 等效于 c = c - a *= 乘法赋值运算符 c *= a 等效于 c = c * a /= 除法赋值运算符 c /= a 等效于 c = c / a %= 取模赋值运算符 c %= a 等效于 c = c % a **= 幂赋值运算符 c **= a 等效于 c = c ** a //= 取整除赋值运算符 c //= a 等效于 c = c // a := 海象运算符，可在表达式内部为变量赋值。 海象运算符/成为运算符/命名表达式运算符例1 1234567age = 20if age&gt; 18: print(&#x27;Adult&#x27;)# 使用海象if (age := 20) &gt; 18: print(&#x27;Adult&#x27;) 例2 123456789L = [1, 2, 3]n = len(L)if n &gt; 2: print(&#x27;Length of L is&#x27;, len(L))# 使用海象L = [1, 2, 3]if (n := len(L)) &gt; 2: print(&#x27;Length of L is&#x27;, n) 可以理解为 len(L) 的返回值赋值给n，然后判断 n&gt;2这样做的好处可以提升运行效率 因为在需要多次调用函数这种会降低运行效率的时候我们通常会减少相同的函数调用，将函数调用后的返回值保存在一个变量里然后 频繁调用函数 换成 频繁使用这个变量 但是这样就需要多一行保存返回值的表达式而 海象运算符 或者说 成为运算符 则兼顾了两者，即使用了变量保存返回值，又不用多一行代码。 12345678910n = 0while n &lt; 3: print(n) # 0,1,2 n += 1 # 当转换为海象运算符时w = 0while (w := w + 1) &lt; 3: print(w) # 1,2 12345678while True: p = input(&quot;Enter the password: &quot;) if p == &quot;the password&quot;: break # 当转换为海象运算符时while (p := input(&quot;Enter the password: &quot;)) != &quot;the password&quot;: continue 位运算符按位运算符是把数字看作二进制来进行计算的。Python中的按位运算法则如下：下表中变量 a 为 60，b 为 13二进制格式如下： 12345678910111213a = 0011 1100 # 60b = 0000 1101 # 13-----------------a&amp;b = 0000 1100 # 12a|b = 0011 1101 # 61a^b = 0011 0001 # 49~a = 1100 0011 # 195 运算符 描述 实例 &amp; 按位与运算符：参与运算的两个值,如果两个相应位都为1,则该位的结果为1,否则为0 (a &amp; b) 输出结果 12 ，二进制解释： 0000 1100 | 按位或运算符：只要对应的二个二进位有一个为1时，结果位就为1。 (a| b) 输出结果 61 ，二进制解释： 0011 1101 ^ 按位异或运算符：当两对应的二进位相异时，结果为1 (a ^ b) 输出结果 49 ，二进制解释： 0011 0001 ~ 按位取反运算符：对数据的每个二进制位取反,即把1变为0,把0变为1 (~a ) 输出结果 -61 ，二进制解释： 1100 0011， 在一个有符号二进制数的补码形式。 &lt;&lt; 左移动运算符：运算数的各二进位全部左移N位.高位丢弃，低位补0。 a &lt;&lt; 2 输出结果 240 ，二进制解释： 1111 0000 &gt;&gt; 右移动运算符：运算数的各二进位全部右移N位， a &gt;&gt; 2 输出结果 15 ，二进制解释： 0000 1111 a &lt;&lt; 1 等价于 a * 2a &lt;&lt; 2 等价于 a * 2 * 2a &gt;&gt; 1 等价于 a / 2a &gt;&gt; 2 等价于 a / 2 / 2a ^= a 等价于 a = a ^ a 等价于置零 a = 0a = a ^ (~a) + 1 等价于置零 a = 0~a + 1 为a的补码 逻辑运算符Python语言支持逻辑运算符，以下假设变量 a 为 10, b为 20: 运算符 表达式 描述 实例 and x and y 布尔”与” - 如果 x 为 False，x and y 返回 False，否则它返回 y 的计算值。 (a and b) 返回 20。 or x or y 布尔”或” - 如果 x 是 True，它返回 x 的值，否则它返回 y 的计算值。 (a or b) 返回 10。 not not x 布尔”非” - 如果 x 为 True，返回 False 。如果 x 为 False，它返回 True。 not(a and b) 返回 False 成员运算符除了以上的一些运算符之外，Python还支持成员运算符，测试实例中包含了一系列的成员，包括字符串，列表或元组。 运算符 描述 实例 in 如果在指定的序列中找到值返回 True，否则返回 False。 x 在 y 序列中 , 如果 x 在 y 序列中返回 True。 not in 如果在指定的序列中没有找到值返回 True，否则返回 False。 x 不在 y 序列中 , 如果 x 不在 y 序列中返回 True。 身份运算符身份运算符用于比较两个对象的存储单元 运算符 描述 实例 is is 是判断两个标识符是不是引用自一个对象 x is y, 类似 id(x) == id(y) , 如果引用的是同一个对象则返回 True，否则返回 False is not is not 是判断两个标识符是不是引用自不同对象 x is not y ， 类似 id(a) != id(b)。如果引用的不是同一个对象则返回结果 True，否则返回 False。 id() id() 函数用于获取对象内存地址 12345678#id()&gt;&gt;&gt;a = &#x27;runoob&#x27;&gt;&gt;&gt; id(a)4531887632&gt;&gt;&gt; b = 1&gt;&gt;&gt; id(b)140588731085608 三目运算符 true if expression else flase满足表达式时 if 表达式 else 不满足表达式时 12345678&gt;&gt;&gt; a = 1&gt;&gt;&gt; b = 2&gt;&gt;&gt; h = a + b if a &lt; b else a - b&gt;&gt;&gt; h3&gt;&gt;&gt; q = (a + b) if (a &lt; b) else (a - b)&gt;&gt;&gt; q3 运算符优先级以下表格列出了从最高到最低优先级的所有运算符： 运算符 描述 ** 指数 (最高优先级) ~、+、- 按位取反、正、负 *、/、%、// 乘，除，求余数和取整除 +、- 加、减 &lt;&lt;、&gt;&gt; 左移、右移 &amp; 按位与 ^、| 按位异或、按位或 &lt;=、&lt;、&gt;、&gt;= 比较运算符 ==、!= 等于运算符 =、%=、/=、//=、-=、+=、*=、**= 赋值运算符 is、is not 身份运算符 in、not in 成员运算符 and、or、not 逻辑运算符","categories":[{"name":"Python","slug":"Python","permalink":"https://www.boii.xyz/categories/Python/"},{"name":"基础","slug":"Python/基础","permalink":"https://www.boii.xyz/categories/Python/%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"Python","slug":"Python","permalink":"https://www.boii.xyz/tags/Python/"}]},{"title":"Python【No-4】数据类型","slug":"Python【No-4】数据类型","date":"2020-07-09T13:41:48.000Z","updated":"2021-05-22T13:37:47.723Z","comments":true,"path":"2020/07/09/Python【No-4】数据类型/","link":"","permalink":"https://www.boii.xyz/2020/07/09/Python%E3%80%90No-4%E3%80%91%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/","excerpt":"基础知识：数据类型","text":"基础知识：数据类型 常见内置类型 内置类型：None（全局只有一个）数值类型：int、float、complax（复数）、bool迭代类型序列类型：list、bytes、range、tuple、string、array映射类型：dict集合类型：set、frozenset上下文管理类型：with 可变类型：list、set、dict不可变类型：int、float、string、tuple 基本数据类型整型可以是任意大小的整数与数学上的表示方法一样 如：1，100，-800，0可以用十六进制表示法 如：0xFF00, 0xab54f 常用基本运算 加（+） 减（-） 乘（*） 除（/） 模（%） 1234567891011121314&gt;&gt;&gt; 3 + 25&gt;&gt;&gt; 3 - 21&gt;&gt;&gt; 3 * 26&gt;&gt;&gt; 3 / 21.5&gt;&gt;&gt; 2 + 3 * 414&gt;&gt;&gt; (2 + 3) * 420&gt;&gt;&gt; 17 % 32 除法运算 （/）永远返回浮点型 12&gt;&gt;&gt; 9 / 33.0 乘方（**） 截断除法、整数除（//） 123456&gt;&gt;&gt; 3 ** 29&gt;&gt;&gt; 3 ** 327&gt;&gt;&gt; 17 // 35 包含多种混合类型运算数的运算会把整数转换为浮点数 12&gt;&gt;&gt; 4 * 3.75 - 114.0 浮点数即小数 如：1.2，524.33，-9.11如果是很大或很小的浮点数，必须用科学计数法表示，用e+指数代替底数 10^指数，如： 1.23×10^9 就是 1.23e9 或 12.3e8， 0.000012 就是 1.2e-5浮点数运算可能会有四舍五入的误差 字符串123456str1 = &#x27;OK&#x27; # OKstr2 = &quot;OK&quot; # OKstr3 = &quot;I&#x27;m ok.&quot; # I&#x27;m ok.str4 = &#x27;I\\&#x27;m ok.&#x27; # I&#x27;m ok.str5 = &quot;I\\&quot;m ok.&quot; # I&quot;m ok.str6 = &#x27;I&quot;m ok.&#x27; # I&quot;m ok. 1234567891011str7 = &#x27;&#x27;&#x27;这是一个段落，所以可以直接换行，不需反斜杠来声明语句未结束 直到遇到下一个三单引号，才认为结束但是换行会跟着换行，空格会跟着空格&#x27;&#x27;&#x27;&quot;&quot;&quot;str7输出为：这是一个段落，所以可以直接换行，不需反斜杠来声明语句未结束 直到遇到下一个三单引号，才认为结束但是换行会跟着换行，空格会跟着空格&quot;&quot;&quot; 12345678910111213141516\\n 换行 \\t 缩进# 使用转义字符str8 = &#x27;ab\\ncd&#x27;&#x27;&#x27;&#x27;str8输出为：abcd&#x27;&#x27;&#x27;r&#x27;字符串&#x27; 表示不转义# 不转义str9 = r&#x27;ab\\ncd&#x27; # ab\\ncd 转义字符 转义字符 描述 \\ 续行符 \\ 反斜杠 &#39; 单引号 &quot; 双引号 \\a 响铃 \\b 退格 \\e 转义 \\000 空 \\n 换行 \\v 纵向制表符 \\t 横向制表符 \\r 回车 \\f 换页 \\o 八进制 \\x 十六进制 布尔值 True False 可以用 and , or , not 运算 空值 空值是一个特殊的值，用 None 表示。None 不等于 0，0 是有意义的.全局只有一个None 复合数据类型列表 List 一种有序的、可变的 元素集合用 [ ] 标识 可随机添加和删除其中的元素可理解为可变的数组是一种复合数据类型List 中的元素可以不同类型区别于元组Tuple：List 中的元素可变 123&gt;&gt;&gt; name = [&#x27;Alice&#x27;, &#x27;Boii&#x27;, &#x27;Chen&#x27;, &#x27;Dannie&#x27;, &#x27;Eva&#x27;]&gt;&gt;&gt; print(name)[&#x27;Alice&#x27;, &#x27;Boii&#x27;, &#x27;Chen&#x27;, &#x27;Dannie&#x27;, &#x27;Eva&#x27;] List索引123| P | y | t | h | o | n | 0 1 2 3 4 5 # 从左往右，下标从0开始 -6 -5 -4 -3 -2 -1 # 从右往左，下标从-1开始 List的增删改查初始化 listName = [element1, element2, element3, …] 增追加到末尾 append listName.append(value) 1234&gt;&gt;&gt; name = [&#x27;Alice&#x27;, &#x27;Boii&#x27;, &#x27;Chen&#x27;, &#x27;Dannie&#x27;, &#x27;Eva&#x27;]&gt;&gt;&gt; name.append(&#x27;Fit&#x27;)&gt;&gt;&gt; name[&#x27;Alice&#x27;, &#x27;Boii&#x27;, &#x27;Chen&#x27;, &#x27;Dannie&#x27;, &#x27;Eva&#x27;, &#x27;Fit&#x27;] 插入到指定位置 insert listName.insert(index, value) 1234&gt;&gt;&gt; name = [&#x27;Alice&#x27;, &#x27;Boii&#x27;, &#x27;Chen&#x27;, &#x27;Dannie&#x27;, &#x27;Eva&#x27;]&gt;&gt;&gt; name.insert(3, &#x27;Fit&#x27;)&gt;&gt;&gt; name[&#x27;Alice&#x27;, &#x27;Boii&#x27;, &#x27;Chen&#x27;, &#x27;Fit&#x27;, &#x27;Dannie&#x27;, &#x27;Eva&#x27;] 删删除末尾元素 pop listName.pop() 123456&gt;&gt;&gt; name = [&#x27;Alice&#x27;, &#x27;Boii&#x27;, &#x27;Chen&#x27;, &#x27;Dannie&#x27;, &#x27;Eva&#x27;]&gt;&gt;&gt; &gt;&gt;&gt; name.pop()&#x27;Eva&#x27;&gt;&gt;&gt; name[&#x27;Alice&#x27;, &#x27;Boii&#x27;, &#x27;Chen&#x27;, &#x27;Dannie&#x27;] 删除指定位置元素 pop listName.pop(index)或del listName[index] 1234567&gt;&gt;&gt; name = [&#x27;Alice&#x27;, &#x27;Boii&#x27;, &#x27;Chen&#x27;, &#x27;Dannie&#x27;, &#x27;Eva&#x27;]&gt;&gt;&gt; name.pop(3)&#x27;Dannie&#x27;&gt;&gt;&gt; name[&#x27;Alice&#x27;, &#x27;Boii&#x27;, &#x27;Chen&#x27;, &#x27;Eva&#x27;]&gt;&gt;&gt; del name[2][&#x27;Alice&#x27;, &#x27;Boii&#x27;, &#x27;Eva&#x27;] 改 修改某个元素，直接给该元素赋新值即可listName[index] = value 12345&gt;&gt;&gt; name = [&#x27;Alice&#x27;, &#x27;Boii&#x27;, &#x27;Chen&#x27;, &#x27;Dannie&#x27;, &#x27;Eva&#x27;]&gt;&gt;&gt; &gt;&gt;&gt; name[2] = &#x27;Cai&#x27;&gt;&gt;&gt; name[&#x27;Alice&#x27;, &#x27;Boii&#x27;, &#x27;Cai&#x27;, &#x27;Dannie&#x27;, &#x27;Eva&#x27;] 查 使用下标来访问List中的元素listName[index] 12345name = [&#x27;Alice&#x27;, &#x27;Boii&#x27;, &#x27;Chen&#x27;, &#x27;Dannie&#x27;, &#x27;Eva&#x27;]print(name[0]) # &#x27;Alice&#x27; 访问List第一个元素print(name[1]) # &#x27;Boii&#x27; 访问List第二个元素print(name[-1]) # &#x27;Eva&#x27; 访问List最后一个元素 获得长度 len() len(List名) 123&gt;&gt;&gt; name = [&#x27;Alice&#x27;, &#x27;Boii&#x27;, &#x27;Chen&#x27;, &#x27;Dannie&#x27;, &#x27;Eva&#x27;]&gt;&gt;&gt; len(name)5 List中元素可以不同类型123&gt;&gt;&gt; L = [&#x27;Boii&#x27;, 23, True, &#x27;https://tcp404.com&#x27;]&gt;&gt;&gt; L[&#x27;Boii&#x27;, 23, True, &#x27;https://tcp404.com&#x27;] List嵌套List 类似于多维数组的概念 12345&gt;&gt;&gt; l_main = [&#x27;Boii&#x27;, 23, [&#x27;https://&#x27;, &#x27;tcp404&#x27;, &#x27;.com&#x27;], 443]&gt;&gt;&gt; len(l_main)4&gt;&gt;&gt; len(l_main[2])3 等价于 1234567&gt;&gt;&gt; l_sub = [&#x27;https://&#x27;, &#x27;tcp404&#x27;, &#x27;.com&#x27;]&gt;&gt;&gt; l_main = [&#x27;Boii&#x27;, 23, l_sub, 443]#获取 tcp404可以用一下方式&gt;&gt;&gt; l_main[2][1]&#x27;tcp404&#x27; 空List123456&gt;&gt;&gt; L = []&gt;&gt;&gt; len(L)0&gt;&gt;&gt; li = list()&gt;&gt;&gt; len(li)0 元组 Tuple 一种 有序的、不可变的 元素集合用 ( ) 标识 Tuple中的元素一旦初始化就不可变可理解为不可变的数组是一种复合数据类型Tuple中的元素可以不同类型区别于List：Tuple 中的元素 不可变 初始化 tupleName = (elem1, elem2, elem3, …) Tuple索引123| P | y | t | h | o | n | 0 1 2 3 4 5 # 从左往右，下标从0开始 -6 -5 -4 -3 -2 -1 # 从右往左，下标从-1开始 Tuple的增删改查 Tuple不可变，所以不可以 增加、删除、修改，只能查询查询与List相同 查 tupleName[index] 1234567&gt;&gt;&gt; T = (1, 2, &#x27;Boii&#x27;)&gt;&gt;&gt; T[2]&#x27;Boii&#x27;&gt;&gt;&gt; T[0]1&gt;&gt;&gt; T(1, 2, &#x27;Boii&#x27;) 空Tuple ()123&gt;&gt;&gt; tr = ()&gt;&gt;&gt; tr() 定义单元素的Tuple (element，) 为避免与数学的括号混淆，定义一个元素的Tuple时，要在元素后加上逗号 123&gt;&gt;&gt; tr = (&#x27;Boii&#x27;,)&gt;&gt;&gt; tr(&#x27;Boii&#x27;,) 且在python解释中： tr = (1) 会被认为是 tr = 1, tr 就变成一个普通的整型变量 tr = (‘Boii’) 会被认为是 tr = ‘Boii’, tr 就变成一个普通的字符串变量 1234567891011&gt;&gt;&gt; tr = (1) # 等价于 tr = 1&gt;&gt;&gt; tr1&gt;&gt;&gt; tr = (&#x27;Boii&#x27;) # 等价于 tr = &#x27;Boii&#x27;&gt;&gt;&gt; tr&#x27;Boii&#x27;&gt;&gt;&gt; &gt;&gt;&gt; &gt;&gt;&gt; tr = (&#x27;Boii&#x27;,) # √ 正确定义单元素Tuple&gt;&gt;&gt; tr(&#x27;Boii&#x27;,) Tuple不可变的意义 因为tuple不可变，所以代码更安全。如果可能，能用tuple代替list就尽量用tuple。 ！！！不可变Tuple中的可变元素 Tuple的不可变指的是Tuple指向的元素不可变如果元素中有 可变的Listlist ，那么Tuple依然可以修改 12345&gt;&gt;&gt; t = (&#x27;a&#x27;, &#x27;b&#x27;, [&#x27;A&#x27;, &#x27;B&#x27;])&gt;&gt;&gt; t[2][0] = &#x27;X&#x27;&gt;&gt;&gt; t[2][1] = &#x27;Y&#x27;&gt;&gt;&gt; t(&#x27;a&#x27;, &#x27;b&#x27;, [&#x27;X&#x27;, &#x27;Y&#x27;]) 定义Tuplet时 修改Tuplet的元素后 字典 Dict 一种 无序的、可变的 键-值对集合用 &#123; &#125; 标识 键key 必须是不可变对象 （如字符串、整数。而list，tuple这些不可以作为key）键key 不可以重复键key 可以不同类型，但不建议键key 可以是变量，但是这个变量必须指向字符串、整数这类不可变对象 Dictionary VS List Dict 查找和插入的速度极快，不会随着key的增加而变慢； Dict 需要占用大量的内存，内存浪费多。 List 查找和插入的时间随着元素的增加而增加； List 占用空间小，浪费内存很少。 初始化 dictName = { key1 : value1, key2 : value2, key3 : value3, … } 1234d = &#123;&#x27;a&#x27;: 1, &#x27;b&#x27;: 2, &#x27;c&#x27;: 3, &#x27;d&#x27;: 4&#125;# 键可以不同类型dd = &#123;&#x27;a&#x27;:&#x27;Alice&#x27;, &#x27;b&#x27;:&#x27;Boii&#x27;, 18:&#x27;Kk&#x27;&#125; Dict索引 Dict的索引就是 键key。 Dict的增删改查和判断增 dictName[key] = value 1234567891011&gt;&gt;&gt; d = &#123;&#x27;a&#x27;: 1, &#x27;b&#x27;: 2, &#x27;c&#x27;: 3, &#x27;d&#x27;: 4&#125;&gt;&gt;&gt; d[&#x27;AC&#x27;] = &#x27;diu&#x27;&gt;&gt;&gt; d&#123;&#x27;a&#x27;: 1, &#x27;b&#x27;: 2, &#x27;c&#x27;: 3, &#x27;d&#x27;: 4, &#x27;AC&#x27;:&#x27;diu&#x27;&#125;# 使用变量作为key&gt;&gt;&gt; d = &#123;&#x27;a&#x27;: 1, &#x27;b&#x27;: 2, &#x27;c&#x27;: 3, &#x27;d&#x27;: 4&#125;&gt;&gt;&gt; a = &#x27;x&#x27;&gt;&gt;&gt; d[a] = &#x27;what&#x27;&gt;&gt;&gt; d&#123;&#x27;a&#x27;: 1, &#x27;b&#x27;: 2, &#x27;c&#x27;: 3, &#x27;d&#x27;: 4, &#x27;x&#x27;:&#x27;what&#x27;&#125; 删 pop、del dictName.pop(key)del dictName[key] 123456&gt;&gt;&gt; d = &#123;&#x27;a&#x27;: 1, &#x27;b&#x27;: 2, &#x27;c&#x27;: 3, &#x27;d&#x27;: 4&#125;&gt;&gt;&gt; d.pop(&#x27;a&#x27;)&#123;&#x27;b&#x27;: 2, &#x27;c&#x27;: 3, &#x27;d&#x27;: 4&#125;&gt;&gt;&gt; del d[&#x27;c&#x27;]&#123;&#x27;b&#x27;: 2, &#x27;d&#x27;: 4&#125; 改 dictName[key] = newValue因为key不能重复，所以如果key不存在，会变成添加，如果key存在，newValue会覆盖oldValue 1234567&gt;&gt;&gt; d = &#123;&#x27;a&#x27;: 1, &#x27;b&#x27;: 2, &#x27;c&#x27;: 3, &#x27;d&#x27;: 4&#125;&gt;&gt;&gt; d[&#x27;a&#x27;] = 25&gt;&gt;&gt; d&#123;&#x27;a&#x27;: 25, &#x27;b&#x27;: 2, &#x27;c&#x27;: 3, &#x27;d&#x27;: 4&#125;&gt;&gt;&gt; d[&#x27;e&#x27;] = 15&gt;&gt;&gt; d&#123;&#x27;a&#x27;: 25, &#x27;b&#x27;: 2, &#x27;c&#x27;: 3, &#x27;d&#x27;: 4, &#x27;e&#x27;: 15&#125; 查 get dictName.get(key)如果key存在，返回对应的value如果key不存在，返回None 123d = &#123;&#x27;a&#x27;: 1, &#x27;b&#x27;: 2, &#x27;c&#x27;: 3, &#x27;d&#x27;: 4&#125;d.get(&#x27;a&#x27;) # 1d.get(&#x27;z&#x27;) # None dictName.get(key, return)如果key存在，返回对应的value如果key不存在，返回指定的返回值return，return可以是整型、字符串，甚至是List等 12345678910&gt;&gt;&gt; d = &#123;&#x27;a&#x27;: 1, &#x27;b&#x27;: 2, &#x27;c&#x27;: 3, &#x27;d&#x27;: 4&#125;&gt;&gt;&gt; &gt;&gt;&gt; d.get(&#x27;z&#x27;, 0)0&gt;&gt;&gt; d.get(&#x27;z&#x27;, &#x27;No This Key&#x27;)&#x27;No This Key&#x27;&gt;&gt;&gt; d.get(&#x27;z&#x27;, [0, 0])[0, 0]&gt;&gt;&gt; d.get(&#x27;z&#x27;, &#123;1:&#x27;a&#x27;, 2:&#x27;b&#x27;&#125;)&#123;1:&#x27;a&#x27;, 2:&#x27;b&#x27;&#125; 判断 in、not in key in dictName 12345&gt;&gt;&gt; d = &#123;&#x27;a&#x27;: 25, &#x27;b&#x27;: 2, &#x27;c&#x27;: 3, &#x27;d&#x27;: 4&#125;&gt;&gt;&gt; &#x27;b&#x27; in dTrue&gt;&gt;&gt; &#x27;z&#x27; in dFalse 集合 Set 一种 无序的、不重复的、可变的 的元素的集合用 set([ ]) 或 &#123;key, key, ...&#125; 标识 类似数学概念中的集合可以通过 Dict 来理解：Set 是一种不存储 value 的 Dict（因为key不能重复）是一种复合数据类型Set 中的元素可以不同类型 Set索引 Set 是无序的，所以没有索引，只有元素，或者说只有key 初始化 setName = set(key_list)setName = {key1, key2, key3, …} 1234567891011&gt;&gt;&gt; s1 = set([1, 2, 3, &#x27;a&#x27;, (32, &#x27;a&#x27;, False), 55])&gt;&gt;&gt; s1&#123;1, 2, 3, 55, (32, &#x27;a&#x27;, False), &#x27;a&#x27;&#125;&gt;&gt;&gt; s2 = set(&#x27;abadfgaae&#x27;)&gt;&gt;&gt; s2&#123;&#x27;g&#x27;, &#x27;b&#x27;, &#x27;e&#x27;, &#x27;f&#x27;, &#x27;d&#x27;, &#x27;a&#x27;&#125;&gt;&gt;&gt; s3 = &#123;1,2,3,4,4,4,5,5&#125;&gt;&gt;&gt; s3&#123;1, 2, 3, 4, 5&#125; Set的增删改查增 add、update setName.add(key) 只能添加基本数据类型setName.update(key) 可以添加基本数据类型和复合数据类型 123456789&gt;&gt;&gt; s3 = set([1,2,3,4,4,4,5,5])&gt;&gt;&gt; s3.add(7)&gt;&gt;&gt; s3&#123;1, 2, 3, 4, 5, 7&#125;&gt;&gt;&gt; s3.update([&#x27;a&#x27;, &#x27;b&#x27;])&gt;&gt;&gt; s3&#123;1, 2, 3, 4, 5, 7, &#x27;a&#x27;, &#x27;b&#x27;&#125; 删除 remove、discard、pop setName.remove(key) 删除指定元素，如果元素不存在会存在错误setName.discard(key) 删除指定元素，如果元素不存在不会存在错误setName.pop() 随机删除一个元素 123456789101112131415161718192021222324252627282930&gt;&gt;&gt; s = set([1, 2, 3, 4, 7, 4, 15, 4, 5, 5])&gt;&gt;&gt; s&#123;1, 2, 3, 4, 5, 7, 15&#125;&gt;&gt;&gt; s.remove(5)&gt;&gt;&gt; s&#123;1, 2, 3, 4, 7, 15&#125;&gt;&gt;&gt; s.remove(20)Traceback (most recent call last): File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;KeyError: 20&gt;&gt;&gt; s.discard(15)&gt;&gt;&gt; s&#123;1, 2, 3, 4, 7&#125;&gt;&gt;&gt; s.discard(20)&gt;&gt;&gt;&gt;&gt;&gt; s.pop()4&gt;&gt;&gt; s&#123;2, 3, 1, 7&#125;&gt;&gt;&gt; s.pop()3&gt;&gt;&gt; s&#123;2, 1, 7&#125;&gt;&gt;&gt; s.pop()2&gt;&gt;&gt; s&#123;1, 7&#125; 改 remove + add Set 中没有改的办法，因为集合是无序的，改一个元素没有意义只能删除要改的key，然后添加新的key setName.remove(key)setName.add(key) 查强制类型转换 函数 描述 int(x [,base]) 将x转换为一个整数 long(x [,base] ) 将x转换为一个长整数 float(x) 将x转换到一个浮点数 complex(real [,imag]) 创建一个复数 str(x) 将对象 x 转换为字符串 repr(x) 将对象 x 转换为表达式字符串 eval(str) 用来计算在字符串中的有效Python表达式,并返回一个对象 tuple(s) 将序列 s 转换为一个Tuple list(s) 将序列 s 转换为一个List set(s) 转换为可变集合 dict(d) 创建一个Dict。d 必须是一个序列 (key,value)Tuple。 frozenset(s) 转换为不可变集合 chr(x) 将一个整数转换为一个字符 unichr(x) 将一个整数转换为Unicode字符 ord(x) 将一个字符转换为它的ASCII十进制整数值 hex(x) 将一个整数转换为一个十六进制字符串 oct(x) 将一个整数转换为一个八进制字符串 12345678910111213141516 数字 整数 -1 0 1 浮点 -0.1 0.0 1.0 二进制 0b11 结果 3 八进制 0o77 结果 63 16进制 0xFF 结果 255 字符串 &lt;class &#x27;str&#x27;&gt; 纯字符串 &#x27;str&#x27; &quot;str&quot; &#x27;&#x27;&#x27;str&#x27;&#x27;&#x27; &quot;&quot;&quot;str&quot;&quot;&quot; 字符串数字(二进制 0b) &#x27;0b0&#x27; 转成字符 str(0b10) 结果 &#x27;2&#x27; ## 可以前置补零str(0b00000010) 字符串数字(八进制 0o) &#x27;0o0&#x27; 转换字符 str(0o77) 结果 &#x27;63&#x27; ## 可以前置补零str(0o0077) 字符串数字(十进制) &#x27;0&#x27; 转换字符 str(100) 结果 &#x27;100&#x27; ## 不能前置补零 字符串数字(16进制 0x) &#x27;0x0&#x27; 转换字符 str(0xFF) 结果 &#x27;255&#x27; ## 可以前置补零str(0x00FF)二进制 &lt;class &#x27;bytes&#x27;&gt; 二进制字节表示 b&#x27;&#x27; # ASCII 字符 0-9 a-z A-Z 等 数字 转 字符串1234567891011## 255(10进制) 0b11(2进制) 0xFF(16进制)## (10进制数)&gt;&gt;&gt; bin(255) &#x27;0b11111111&#x27;&gt;&gt;&gt; oct(255) &#x27;0o377&#x27;&gt;&gt;&gt; hex(255) &#x27;0xff&#x27;## (2进制数)&gt;&gt;&gt; bin(0b11) &#x27;0b11&#x27;&gt;&gt;&gt; hex(0xFF) &#x27;0xff&#x27;## (16进制数)&gt;&gt;&gt; bin(0xFF) &#x27;0b11111111&#x27;&gt;&gt;&gt; hex(0xFF) &#x27;0xff&#x27; 字符串 转 数字（十进制数）123456789101112131415## &#x27;123&#x27;(以10进制解析) &#x27;10&#x27;(以2进制解析) &#x27;a&#x27;(以16进制解析)## (10进制表示的字符串)&gt;&gt;&gt; int(&#x27;123&#x27;) 123 ## 十进制字符转十进制数字&gt;&gt;&gt; int(&#x27;123&#x27;,10) 123 ## 默认是十进制## (二进制表示的字符串)&gt;&gt;&gt; int(&#x27;100&#x27;,2) 4 ## 二进制的 100 等于 十进制的 4（可以不加前置 0b）&gt;&gt;&gt; int(&#x27;0b100&#x27;,2) 4 ## 二进制的 100 等于 十进制的 4&gt;&gt;&gt; int(&#x27;0b0100&#x27;,2) 4 ## 可以前置补零## (16进制表示的字符串)&gt;&gt;&gt; int(&#x27;a&#x27;,16) 10 ## 16进制的 a 等于 十进制的 10（可以不加前置 0x）&gt;&gt;&gt; int(&#x27;0xa&#x27;,16) 10 ## 16进制的 a 等于 十进制的 10&gt;&gt;&gt; int(&#x27;0x0a&#x27;,16) 10 ## 16进制的 a 等于 十进制的 10（可以前置补零）&gt;&gt;&gt; int(&#x27;10&#x27;,16) 16 ## 16进制的10 等于 十进制的 16（可以不加前置 0x）&gt;&gt;&gt; int(&#x27;0x10&#x27;,16) 16 ## 16进制的10 等于 十进制的 16&gt;&gt;&gt; int(&#x27;0x0010&#x27;,16) 16 ## 16进制的10 等于 十进制的 16（可以前置补零） 数字 转 数字123456789101112131415## 0b11 0xFF## 十进制 转 十进制&gt;&gt;&gt; int(255) 255 # 无意义操作&gt;&gt;&gt; 255 255 # 无意义操作## 二进制 转 十进制&gt;&gt;&gt; int(0b11) 3 # 可加前置零 int(0b0011)&gt;&gt;&gt; 0b11111111 255 # 等价## 16进制 转 十进制&gt;&gt;&gt; int(0xFF) 255&gt;&gt;&gt; 0xff 255 # 等价 且 忽略大小写&gt;&gt;&gt; 0xFF 255 # 等价 且 忽略大小写## 十进制 转 二进制（使用 数字 转 字节码/字符）255 等价 0b11111111## 十进制 转 16进制（使用 数字 转 字节码/字符）255 等价 0xff 字符串 转 字节码123456789101112&gt;&gt;&gt; bytes(&#x27;abc&#x27;,&#x27;utf-8&#x27;) b&#x27;abc&#x27;&gt;&gt;&gt; bytes(&#x27;编程&#x27;,&#x27;utf-8&#x27;) b&#x27;\\xe7\\xbc\\x96\\xe7\\xa8\\x8b&#x27;&gt;&gt;&gt; bytes(&#x27;Python3编程&#x27;,&#x27;utf-8&#x27;) b&#x27;Python3\\xe7\\xbc\\x96\\xe7\\xa8\\x8b&#x27;&gt;&gt;&gt; &#x27;Python3编程&#x27;.encode(&#x27;UTF-8&#x27;) b&#x27;Python3\\xe7\\xbc\\x96\\xe7\\xa8\\x8b&#x27;&gt;&gt;&gt; S = &#x27;Python3编程&#x27; &#x27;Python3编程&#x27;&gt;&gt;&gt; B = bytes(S,&#x27;utf-8&#x27;) b&#x27;Python3\\xe7\\xbc\\x96\\xe7\\xa8\\x8b&#x27;&gt;&gt;&gt; FMT = str(len(B)) + &#x27;s&#x27; &#x27;13s&#x27;&gt;&gt;&gt; struct.pack(FMT,B) b&#x27;Python3\\xe7\\xbc\\x96\\xe7\\xa8\\x8b&#x27;## 以16进制数字写的字符串，直接转成一样的字节码（2个16进制字符才是一个字节）&gt;&gt;&gt; bytes.fromhex(&#x27;01&#x27;) b&#x27;\\x01&#x27; # 单字节&gt;&gt;&gt; bytes.fromhex(&#x27;0001&#x27;) b&#x27;\\x00\\x01&#x27; # 双字节&gt;&gt;&gt; bytes.fromhex(&#x27;aabbccddeeff&#x27;) b&#x27;\\xaa\\xbb\\xcc\\xdd\\xee\\xff&#x27; # 多字节 字节码 转 字符串1234567## 取出16进制表示的内容&gt;&gt;&gt; b&#x27;abc&#x27;.decode(&#x27;UTF-8&#x27;) &#x27;abc&#x27;&gt;&gt;&gt; b&#x27;Python3\\xe7\\xbc\\x96\\xe7\\xa8\\x8b&#x27;.decode(&#x27;UTF-8&#x27;) &#x27;Python3编程&#x27;&gt;&gt;&gt; b&#x27;\\xaa\\xbb\\xcc\\xdd\\xee\\xff&#x27;.hex() &#x27;aabbccddeeff&#x27;&gt;&gt;&gt; b&#x27;0&#x27;.hex() &#x27;30&#x27; ## 字符0在ASCII码上的数字（数字是16进制表示）== 48（十进制）&gt;&gt;&gt; b&#x27;1&#x27;.hex() &#x27;31&#x27;&gt;&gt;&gt; b&#x27;z&#x27;.hex() &#x27;7a&#x27; 数字 转 字节码（是二进制，用16进制显示）123456789101112131415161718# 10进制数 转 字节码import struct&gt;&gt;&gt; struct.pack(&#x27;B&#x27;,0) b&#x27;\\x00&#x27;&gt;&gt;&gt; struct.pack(&#x27;B&#x27;,1) b&#x27;\\x01&#x27;&gt;&gt;&gt; struct.pack(&#x27;B&#x27;,101) b&#x27;e&#x27; ## 101 对应 16进制的 0x65（此处返回值是显示为当前整数 101 对应的 ASCII字符 e）&gt;&gt;&gt; struct.pack(&#x27;B&#x27;,255) b&#x27;\\xff&#x27; # 无符号最大单字符可以表示的数字&gt;&gt;&gt; struct.pack(&#x27;&gt;i&#x27;,255) b&#x27;\\x00\\x00\\x00\\xff&#x27; # 4字节大端表示的数字&gt;&gt;&gt; struct.pack(&#x27;&lt;i&#x27;,255) b&#x27;\\xff\\x00\\x00\\x00&#x27; # 4字节小端表示的数字# 2进制数 转 字节码import struct&gt;&gt;&gt; struct.pack(&#x27;B&#x27;,0b11111111) b&#x27;\\xff&#x27;&gt;&gt;&gt; struct.pack(&#x27;&gt;i&#x27;,0b111) b&#x27;\\x00\\x00\\x00\\x07&#x27; # 0b111 等于 7（10进制）&gt;&gt;&gt; struct.pack(&#x27;&gt;i&#x27;,0b1111) b&#x27;\\x00\\x00\\x00\\x0f&#x27; # 0b1111 等于 15（10进制）&gt;&gt;&gt; struct.pack(&#x27;&gt;i&#x27;,0b11111) b&#x27;\\x00\\x00\\x00\\x1f&#x27; # 0b11111 等于 31（10进制）# 16进制数 转 字节码import struct&gt;&gt;&gt; struct.pack(&#x27;B&#x27;,0xff) b&#x27;\\xff&#x27;&gt;&gt;&gt; struct.pack(&#x27;&gt;i&#x27;,0xfff) b&#x27;\\x00\\x00\\x0f\\xff&#x27; 字节码 转 数字1234567891011import struct 16进制表现 10进制等值&gt;&gt;&gt; struct.unpack(&#x27;B&#x27;, b&#x27;\\xff&#x27;) (255,) # 单字节&gt;&gt;&gt; struct.unpack(&#x27;&gt;i&#x27;, b&#x27;\\x00\\x00\\x00\\xff&#x27;) (255,) # 4字节，大端模式&gt;&gt;&gt; struct.unpack(&#x27;&lt;i&#x27;, b&#x27;\\x00\\x00\\x00\\xff&#x27;) (-16777216,) # 4字节，小端模式## 手动 转换字节码 -&gt; 字符串&gt;&gt;&gt; B = b&#x27;\\xe9&#x27;&gt;&gt;&gt; S = B.hex()&gt;&gt;&gt; S # 值 &#x27;e9&#x27;字符串（16进制格式）-&gt; 数字（10进制）&gt;&gt;&gt; int(S,16) # 值 233 ASCII 字符 和 数字字节 b’\\x05’字符串 ‘\\x05’将一个整数 (0-1114111) 转换为 一个字符（整数对应的 ASCII 字符）ValueError: chr() arg not in range(0x110000) 1234567&gt;&gt;&gt; chr(0) &#x27;\\x00&#x27;&gt;&gt;&gt; chr(1) &#x27;\\x01&#x27;&gt;&gt;&gt; chr(97) &#x27;a&#x27;&gt;&gt;&gt; chr(1114111) &#x27;\\U0010ffff&#x27;&gt;&gt;&gt; len(chr(101)) 1 # 长度为 1个字符&gt;&gt;&gt; len(chr(1114111)) 1 # 长度为 1个字符 将一个 ASCII字符 转换为 一个整数12345678&gt;&gt;&gt; ord(&#x27;\\x00&#x27;) 0&gt;&gt;&gt; ord(&#x27;\\x01&#x27;) 1&gt;&gt;&gt; ord(&#x27;a&#x27;) 97&gt;&gt;&gt; ord(&#x27;0&#x27;) 48&gt;&gt;&gt; ord(&#x27;1&#x27;) 49&gt;&gt;&gt; ord(&#x27;A&#x27;) 65&gt;&gt;&gt; ord(&#x27;Z&#x27;) 90&gt;&gt;&gt; ord(&#x27;\\U0010ffff&#x27;) 1114111 ASCII 字符 和 bin(字节)12345678from binascii import b2a_hex, a2b_hex&gt;&gt;&gt; a2b_hex(&#x27;ab&#x27;)b&#x27;\\xab&#x27;&gt;&gt;&gt; b2a_hex(b&#x27;ab&#x27;)b&#x27;6162&#x27;&gt;&gt;&gt; a2b_hex(b&#x27;6162&#x27;)b&#x27;ab&#x27; 总结 (摘自 羋虹光)int 类型解析较小的整数会很频繁的被使用，所以python将这些对象放置到了一个池子中，每次需要这些对象的时候就到池子中获取这个值，避免多次的重复创建对象引起的许多不必要的开销。这个池子内的数字范围是[-5, 257), 所以都是从池子里面取值，自然id不变。 float类型解析对于float类型的使用自然没有int那么频繁，并且float类型也不好定义哪些常用，也就没有池子给到这个类型，所以每次重新创建即可。 tuple类型解析对于tuple类型，与float类型的思维相似，所以也是每次重新创建。 string类型解析单词类型的str由于被重复使用的概率比较大，所以在python中为单词类型的str做了一个缓存，也就是说如果是单词类型的str， 会被存储到一个字典(dict)中，字典的内容是字符串为key， 地址为value。当有一个字符串需要创建，就先去访问这个字典，如果存在则返回字典中字符串的地址，如果不存在，则返回新创建的地址，并将这个字符串添加进入字典。这是字符串的intern机制。","categories":[{"name":"Python","slug":"Python","permalink":"https://www.boii.xyz/categories/Python/"},{"name":"基础","slug":"Python/基础","permalink":"https://www.boii.xyz/categories/Python/%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"Python","slug":"Python","permalink":"https://www.boii.xyz/tags/Python/"}]},{"title":"Python【No-3】判断和循环","slug":"Python【No-3】判断和循环","date":"2020-07-09T12:41:48.000Z","updated":"2021-05-22T13:37:47.723Z","comments":true,"path":"2020/07/09/Python【No-3】判断和循环/","link":"","permalink":"https://www.boii.xyz/2020/07/09/Python%E3%80%90No-3%E3%80%91%E5%88%A4%E6%96%AD%E5%92%8C%E5%BE%AA%E7%8E%AF/","excerpt":"程序结构：判断与循环","text":"程序结构：判断与循环 Judgment&amp;circulation ！！不要用浮点数比较相等！！ 判断123456if condition: print()elif condition: print()else: print() 例如 12345678age = 20if age &gt; = 6: print(&#x27;teenager&#x27;)elif age &gt;= 18: print(&#x27;adult&#x27;)else: print(&#x27;kid&#x27;) 还可以简写 123456if x: print(&#x27;True&#x27;)或if x: print(&#x27;True&#x27;) 只要 x 是非零数值、非空字符串、非空list、非空tuple，也不是None，就判断为True，否则为False 循环for12for x in Iterable: do sth 例如 1234567Li = [1, 2, 3, 4, 5, 6]sum = 0for x in Li: sum += xprint(sum)# 21 123456sum = 0for x in [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]: sum = sum + xprint(sum)#55 range()1234&gt;&gt;&gt; range(5)0, 1, 2, 3, 4&gt;&gt;&gt; list(range(5))[0, 1, 2, 3, 4] 12345678# 从1加到100sum = 0for x in range(101): sum = sum + xprint(sum)# 5050 while12while condition: do sth 1234567sum = 0n = 99while n &gt; 0: sum = sum + n n = n - 2print(sum) break 跳出整个循环，且不执行else子句 continue 跳出本次循环 else else 子句会在循环不满足条件退出时执行但如果 break 跳出循环时，不会执行else子句 123456789101112131415sum = 0n = 99while n &gt; 0: sum = sum + n n = n - 2else: print(&#x27;else&#x27;) # 循环结束后会执行这句话print(sum)---------------------------------# Output:else2500 12345678910111213141516sum = 0n = 99while n &gt; 0: sum = sum + n n = n - 2 if n &lt; 10: break # n 小于 10的时候会跳出循环，并且不会执行 else 子句else: print(&#x27;else&#x27;)print(sum)---------------------------------# Output:2475 pass pass 语句什么也不做。当语法上需要一个语句，但程序需要什么动作也不做时，可以使用它。 12345678&gt;&gt;&gt; while True:... pass # Busy-wait for keyboard interrupt (Ctrl+C)&gt;&gt;&gt; class MyEmptyClass:... pass&gt;&gt;&gt; def initlog(*args):... pass # Remember to implement this!","categories":[{"name":"Python","slug":"Python","permalink":"https://www.boii.xyz/categories/Python/"},{"name":"基础","slug":"Python/基础","permalink":"https://www.boii.xyz/categories/Python/%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"Python","slug":"Python","permalink":"https://www.boii.xyz/tags/Python/"}]},{"title":"Python【No-2】基础","slug":"Python【No-2】基础","date":"2020-07-02T09:40:48.000Z","updated":"2021-05-22T13:37:47.723Z","comments":true,"path":"2020/07/02/Python【No-2】基础/","link":"","permalink":"https://www.boii.xyz/2020/07/02/Python%E3%80%90No-2%E3%80%91%E5%9F%BA%E7%A1%80/","excerpt":"Python 基础知识","text":"Python 基础知识 输入 &amp; 输出输出 print(‘输出内容’) 12345&gt;&gt;&gt; print(300) # 300&gt;&gt;&gt; print(100 + 200) # 300&gt;&gt;&gt; print(&#x27;100 + 200 =&#x27;, 100 + 200) # 100 + 200 = 300&gt;&gt;&gt; print(&#x27;Hello World!&#x27;) # Hello World!&gt;&gt;&gt; print(&#x27;The quick&#x27;, &#x27;brown for&#x27;, &#x27;jumps over.&#x27;) # The quick brown for jumps over. 输入 承接变量 = input(‘提示信息’) 123456&gt;&gt;&gt; name = input()Boii&gt;&gt;&gt; name&#x27;Boii&#x27;&gt;&gt;&gt; print(name)Boii 1234# name.pyname = input(&#x27;Please enter your name:&#x27;)print(&#x27;Hello&#x27;, name) &gt;_: python name.py Please enter your name: BoiiHello Boii 变量 大小写英文、数字、下划线_ 不能数字开头 大小写敏感 不能用关键字 不需要声明类型 简洁明了，信达雅原则。变量名用名词，函数名方法名用动词 由于python是动态语言，不需要声明类型，所以命名尽量体现类型或用前缀体现。如 i_age, fPrice, b_flag 慎用字母O和I 12345678910111213a = 1 # a是一个整型b = 1.0 # b是一个浮点型c = &#x27;abc&#x27; # c是一个字符串d = True # d是一个布尔值e = None # e是一个空值# 多个变量同时赋值a = b = c = 1# 以上语句, 内存中会创建一个空间,值为1; 再创建三个空间a, b, c, 存放1的地址，即指向1那块内存x, y, z = 1, 2, &quot;Boii&quot;# 以上语句, x为1, y为2, z为Boii 变量实际上是指向12345&gt;&gt;&gt; a = &#x27;ABC&#x27;&gt;&gt;&gt; b = a&gt;&gt;&gt; a = &#x27;XYZ&#x27;&gt;&gt;&gt; print(b)ABC a = &#39;ABC&#39; b = a a = &#39;XYZ&#39; 数据类型数据类型.md 运算符运算符 缩进Python以缩进来区分代码块。连续的相同缩进视为同一代码块，同一作用域，如同C中的花括号。 按照约定俗成，4个空格为一个缩进。在IDE中最好设置好tab自动转换为4个空格 多行语句如果一个语句太长，可以使用 \\ 声明此语句未结束 123total = item_one + \\ item_two + \\ item_three 注释12345678910111213# 这是单行注释&#x27;&#x27;&#x27;这是多行注释，使用单引号这是多行注释，使用单引号这是多行注释，使用单引号&#x27;&#x27;&#x27;&quot;&quot;&quot;这是多行注释，使用双引号这是多行注释，使用双引号这是多行注释，使用双引号&quot;&quot;&quot;","categories":[{"name":"Python","slug":"Python","permalink":"https://www.boii.xyz/categories/Python/"},{"name":"基础","slug":"Python/基础","permalink":"https://www.boii.xyz/categories/Python/%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"Python","slug":"Python","permalink":"https://www.boii.xyz/tags/Python/"}]},{"title":"Python【No-1】总叙","slug":"Python【No-1】总叙","date":"2020-07-02T02:41:48.000Z","updated":"2021-05-22T13:37:47.723Z","comments":true,"path":"2020/07/02/Python【No-1】总叙/","link":"","permalink":"https://www.boii.xyz/2020/07/02/Python%E3%80%90No-1%E3%80%91%E6%80%BB%E5%8F%99/","excerpt":"关于Python","text":"关于Python 语言哲学： 简洁 类型：解释型语言、动态语言、面向对象（一切皆对象） 缺点： 速度慢 代码不能加密 语言思想： 一切皆对象 函数是一等公民 解释器CPython 默认解释器。 PyPy 目标是执行速度，采用JIT技术，对python代码进行动编译。但是与CPython不同。 PyPy VS CPython Jython Jython是运行在Java平台上的Python解释器，可以直接把Python代码编译成Java字节码执行。 IronPython IronPython和Jython类似，只不过IronPython是运行在微软.Net平台上的Python解释器，可以直接把Python代码编译成.Net的字节码。 命令行模式 &amp; 交互模式命令行模式┌──────────────────────────────────────┐│Command Prompt - □ x │├──────────────────────────────────────┤│Microsoft Windows [Version 10.0.0] ││(c) 2015 Microsoft Corporation. All rights reserved. ││ ││C:&gt; _ ││ │└──────────────────────────────────────┘ 可以切换到文件所在目录下，然后输入 python 文件名.py 来执行python文件 Python交互模式┌────────────────────────────────────────┐│Command Prompt - python - □ x │├────────────────────────────────────────┤│Microsoft Windows [Version 10.0.0] ││(c) 2015 Microsoft Corporation. All rights reserved. ││ ││C:&gt; python ││Python 3.7 … on win32 ││Type “help”, … for more information. ││&gt;&gt;&gt; 100 + 200 ││300 ││&gt;&gt;&gt; _ ││ │└────────────────────────────────────────┘ 输入 python 进入交互模式， 输入 exit() 或 quit() 退出交互模式 文件名 扩展名：.py 文件名：英文字母、数字、下划线 直接运行.py文件 Win Linux Mac 前提： 在hello.py文件的第一行加上一个特殊的注释 #!/usr/bin/env python3 ， 如123#!/usr/bin/env python3print(&quot;Hello World!&quot;) 通过命令给hello.py文件执行权限1$ chmod a+x hello.py 中文编码 Python2 默认编码格式是：ASCII，使用中文会出错解决方法：在文件开头加入 # -*- coding: UTF-8 -*- 或 # coding=utf-8 1234#!/usr/bin/python# -*- coding: UTF-8 -*-print(&quot;放码过来&quot;) Python3 默认编码格式是：UTF-8，所以无需指定编码格式注意：py文件需要存储格式为 UTF-8 123#!/usr/bin/env python3print(&quot;放码过来&quot;) 但最好还是加上 1234#!/usr/bin/env python3# -*- coding: UTF-8 -*-print(&quot;放码过来&quot;) python的一切皆对象123456789101112131415161718192021# 示例如下a=2019b=&quot;一切皆对象&quot;print(type(2019))print(type(int))print(type(b))print(type(str))class Student: passstu = Student()print(type(stu))print(type(Student))print(int.__bases__)print(str.__bases__)print(Student.__bases__)print(type.__bases__)print(object.__bases__)print(type(object))print(type(type)) 运行结果： 12345678910111213&lt;class &#x27;int&#x27;&gt; # 2019是由int这个类创建的实例&lt;class &#x27;type&#x27;&gt; # int这个类是由type这个类创建的实例&lt;class &#x27;str&#x27;&gt; # 同上&lt;class &#x27;type&#x27;&gt;&lt;class &#x27;__main__.Student&#x27;&gt; # stu是类Student创建的实例&lt;class &#x27;type&#x27;&gt; # 类Student是由type这个类创建的实例(&lt;class &#x27;object&#x27;&gt;,) # 类int的基类是object这个类(&lt;class &#x27;object&#x27;&gt;,) # 同上(&lt;class &#x27;object&#x27;&gt;,) # 同上(&lt;class &#x27;object&#x27;&gt;,) # 重点：类type的基类也是object这个基类() # 重点：类object没有基类&lt;class &#x27;type&#x27;&gt; # 难点：类object是由类type创建的实例&lt;class &#x27;type&#x27;&gt; # 难点：类type是由type类自身创建的实例 对于上面图片的解读如下： object是一切对象：list、str、dict、tuple的基类，同时object是type的实例 类type是自身的实例，同时type也继承自object类 由结论1和结论2，得出一切皆对象，同时一切皆继承自object类 类object是一切对象的基类类object是类type的实例 类type继承自类object类type是类type的实例 一切皆对象，一切皆继承自object类","categories":[{"name":"Python","slug":"Python","permalink":"https://www.boii.xyz/categories/Python/"},{"name":"基础","slug":"Python/基础","permalink":"https://www.boii.xyz/categories/Python/%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"Python","slug":"Python","permalink":"https://www.boii.xyz/tags/Python/"}]},{"title":"VUE-note-day2","slug":"VUE-note-day2","date":"2020-04-09T03:34:38.000Z","updated":"2020-04-09T03:34:38.000Z","comments":true,"path":"2020/04/09/VUE-note-day2/","link":"","permalink":"https://www.boii.xyz/2020/04/09/VUE-note-day2/","excerpt":"Vue 的细节是真的多.","text":"Vue 的细节是真的多. v-text123456789101112&lt;div id=&quot;app&quot;&gt; &lt;span&gt;&#123;&#123;msg&#125;&#125;&lt;/span&gt; 等价于 &lt;span v-text=&quot;msg&quot;&gt;&lt;/span&gt;&lt;/div&gt;&lt;script type=&quot;text/javascript&quot;&gt; var app = new Vue(&#123; el: &#x27;#app&#x27;, data: &#123; msg: &#x27;Hello World !&#x27;, &#125; &#125;);&lt;/script&gt; // 显示结果 ==&gt;&gt; Hello World 等价于 Hello World. v-once 形式: v-once 值: 无 作用: 限定所在元素只被渲染一次, 完成后即使值更新了也不再渲染 不管是用 v-text = “msg” 还是用 都会实时的更新,也就是当msg 的值改变的时候, 显示的结果也会改变. 如果只想渲染一次, 可以加上v-once 12345678910111213&lt;div id=&quot;app&quot;&gt; &lt;span&gt;&#123;&#123;msg&#125;&#125;&lt;/span&gt; 不等价于 &lt;span v-text=&quot;msg&quot; v-once&gt;&lt;/span&gt;&lt;/div&gt;&lt;script type=&quot;text/javascript&quot;&gt; var app = new Vue(&#123; el: &#x27;#app&#x27;, data: &#123; msg: &#x27;Hello World !&#x27;, &#125; &#125;); app.msg = &quot;Hello&quot;&lt;/script&gt; 显示结果 ==&gt;&gt; Hello World 不等价于 Hello v-html 形式: v-html = “variable” 值: variable -&gt; string, 取自于data{} 里的属性 ! WARN: 容易导致XSS攻击. 所以, 只在可信内容上使用. 永不用在用户提交的内容上。 作用: 更新元素的innerHTML. 内容按普通的HTML插入, 不会被编译 12345678910111213141516171819202122&lt;div id=&quot;app&quot;&gt; &lt;span v-html=&quot;dodo&quot;&gt;&lt;/span&gt;&lt;/div&gt;&lt;script type=&quot;text/javascript&quot;&gt; var app = new Vue(&#123; el: &#x27;#app&#x27;, data: &#123; dodo: &#x27;&lt;h2&gt;Hello&lt;/h2&gt;&#x27; &#125; &#125;);&lt;/script&gt;&lt;!-- 渲染结果 =&gt;&gt; --&gt;&lt;div id=&quot;app&quot;&gt; &lt;span v-html=&quot;dodo&quot;&gt; &lt;h2&gt;Hello&lt;/h2&gt; &lt;/span&gt;&lt;/div&gt;&lt;!--显示结果 ==&gt;&gt; --&gt;Hello v-on 形式： v-on:event[.qualifier] = “Function | Inline statements | Object” 缩写： @event[.qualifier] = “Function | Inline statements | Object” 值： event -&gt; 要监听的事件， 如click， keyup等 qualifier -&gt; 修饰符，监听事件做一些限定 methods -&gt; 当所监听的事件触发时的响应方法 Inline statements -&gt; 内联语句 Object -&gt; [2.4.0]新增，使用键值对对象作为响应事件，但是不支持任何修饰器 作用： 绑定监听事件。事件类型由event参数指定， 修饰符： .stop - 调用 event.stopPropagation()。 .prevent - 调用 event.preventDefault()。 .capture - 添加事件侦听器时使用 capture 模式。 .self - 只当事件是从侦听器绑定的元素本身触发时才触发回调。 .&#123;keyCode | keyAlias&#125; - 只当事件是从特定键触发时才触发回调。 .native - 监听组件根元素的原生事件。 .once - 只触发一次回调。 .left - (2.2.0) 只当点击鼠标左键时触发。 .right - (2.2.0) 只当点击鼠标右键时触发。 .middle - (2.2.0) 只当点击鼠标中键时触发。 .passive - (2.3.0) 以 &#123; passive: true &#125; 模式添加侦听器 1234567891011121314151617181920212223242526&lt;!--方法处理器--&gt;&lt;button v-on:click=&quot;Function1&quot;&gt;&lt;/button&gt;&lt;!-- 动态事件（2.6.0+） --&gt;&lt;button v-on:[event]=&quot;dosth&quot;&gt;&lt;/button&gt;&lt;!-- 内联语句 --&gt;&lt;button v-on:click=&quot;dosth(&#x27;hello&#x27;, $event)&quot;&gt;&lt;/button&gt;&lt;!-- 缩写 --&gt;&lt;button @click=&quot;dosth&quot;&gt;&lt;/button&gt;&lt;!-- 停止冒泡 --&gt;&lt;button @click.stop=&quot;dosth&quot;&gt;&lt;/button&gt;&lt;!-- 阻止默认行为 --&gt;&lt;button @click.prevent=&quot;dosth&quot;&gt;&lt;/button&gt;&lt;!-- 没有表达式的阻止默认行为 --&gt;&lt;form @click.prevent&gt;&lt;/form&gt;&lt;!-- 串联修饰符 --&gt;&lt;button @click.stop.prevent=&quot;dosth&quot;&gt;&lt;/button&gt;&lt;!-- 键修饰符.键名 --&gt;&lt;button @keyup.enter=&quot;onEnter&quot;&gt;&lt;!-- 键修饰符.键码 --&gt;&lt;button @keyup.13=&quot;onEnter&quot;&gt;&lt;!-- 点击回调只触发一次 --&gt;&lt;button @click.once=&quot;dosth&quot;&gt;&lt;/button&gt;&lt;!-- 对象语法（2.4.0+） --&gt;&lt;button v-on=&quot;&#123;keyup: dosthA, keydown: dosthB&quot;&gt;&lt;/button&gt; v-bind 形式： v-bind:AttributeOrProperty[.qualifier] = “value” 缩写： :AttributeOrProperty=”value” 值： AttributeOrProperty -&gt; 标签的原生属性或特性 value -&gt; 标签原生属性所对应的值 作用：将属性或特性与变量绑定在一起，实现动态修改 修饰符： .prop - 作为一个 DOM property 绑定而不是作为 attribute 绑定。(差别在哪里？) .camel - (2.1.0+) 将 kebab-case attribute 名转换为 camelCase。(从 2.1.0 开始支持) .sync (2.3.0+) 语法糖，会扩展成一个更新父组件绑定值的 v-on 侦听器。 1234567891011121314151617181920212223242526272829303132333435363738&lt;!-- 绑定一个属性 --&gt;&lt;img v-bind:src=&quot;imageSrc&quot;&gt;&lt;!-- 动态 attribute 名 (2.6.0+) --&gt;&lt;button v-bind:[key]=&quot;value&quot;&gt;&lt;/button&gt;&lt;!-- 缩写 --&gt;&lt;img :src=&quot;imageSrc&quot;&gt;&lt;!-- 动态 attribute 名缩写 (2.6.0+) --&gt;&lt;button :[key]=&quot;value&quot;&gt;&lt;/button&gt;&lt;!-- 内联字符串拼接 --&gt;&lt;img :src=&quot;&#x27;/path/to/images/&#x27; + fileName&quot;&gt;&lt;!-- class 绑定 --&gt;&lt;div :class=&quot;&#123; red: isRed &#125;&quot;&gt;&lt;/div&gt;&lt;div :class=&quot;[classA, classB]&quot;&gt;&lt;/div&gt;&lt;div :class=&quot;[classA, &#123; classB: isB, classC: isC &#125;]&quot;&gt;&lt;!-- style 绑定 --&gt;&lt;div :style=&quot;&#123; fontSize: size + &#x27;px&#x27; &#125;&quot;&gt;&lt;/div&gt;&lt;div :style=&quot;[styleObjectA, styleObjectB]&quot;&gt;&lt;/div&gt;&lt;!-- 绑定一个有属性的对象 --&gt;&lt;div v-bind=&quot;&#123; id: someProp, &#x27;other-attr&#x27;: otherProp &#125;&quot;&gt;&lt;/div&gt;&lt;!-- 通过 prop 修饰符绑定 DOM 属性 --&gt;&lt;div v-bind:text-content.prop=&quot;text&quot;&gt;&lt;/div&gt;&lt;!-- prop 绑定。“prop”必须在 my-component 中声明。--&gt;&lt;my-component :prop=&quot;someThing&quot;&gt;&lt;/my-component&gt;&lt;!-- 通过 $props 将父组件的 props 一起传给子组件 --&gt;&lt;child-component v-bind=&quot;$props&quot;&gt;&lt;/child-component&gt;&lt;!-- XLink --&gt;&lt;svg&gt;&lt;a :xlink:special=&quot;foo&quot;&gt;&lt;/a&gt;&lt;/svg&gt; v-model 形式： v-model[.qualifier] = “variable” 值：variable -&gt; 双向数据绑定的变量，通过这个变量实现数据与视图之间的绑定 ! WARN: 只能在 &lt;input&gt;、&lt;select&gt;、&lt;textarea&gt; 和组件上使用 作用： 实现双向数据绑定 修饰符： .lazy - 取代 input 监听 change 事件, 懒加载，会等到失焦才更新 .number - 输入字符串转为有效的数字，限制只有数字有效， 但是如果先输入字符串则该修饰符无效 .trim - 输入首尾空格过滤 1234567891011&lt;p&gt;&#123;&#123;msg&#125;&#125;&lt;/p&gt;&lt;p&gt;v-model.lazy&lt;input type=&quot;text&quot; v-model.lazy=&quot;msg&quot;&gt;&lt;/p&gt;&lt;script type=&quot;text/javascript&quot;&gt; var app = new Vue(&#123; el: &#x27;#app&#x27;, data: &#123; msg: &#x27;Hello World !&#x27; &#125; &#125;);&lt;/script&gt; 加了lazy修饰符， 所以会等到input输入框失去焦点才渲染更新","categories":[{"name":"Note","slug":"Note","permalink":"https://www.boii.xyz/categories/Note/"},{"name":"Vue","slug":"Vue","permalink":"https://www.boii.xyz/categories/Vue/"}],"tags":[{"name":"Vue","slug":"Vue","permalink":"https://www.boii.xyz/tags/Vue/"}]},{"title":"VUE-note-day1","slug":"VUE-note-day1","date":"2020-04-08T04:05:50.000Z","updated":"2020-04-08T04:05:50.000Z","comments":true,"path":"2020/04/08/VUE-note-day1/","link":"","permalink":"https://www.boii.xyz/2020/04/08/VUE-note-day1/","excerpt":"疫情在家真的无聊 T_T，学点Vue吧","text":"疫情在家真的无聊 T_T，学点Vue吧 v-if &amp; v-else-if &amp; v-elsev-if 形式: v-if = “express | variable” 值: true -&gt; 渲染[^1] | false -&gt; 不渲染 作用: vue的一个内部指令, 用在html标签中, 作为标签的一个属性. 用来判断是否渲染所在的标签. 其作用相当于C语言中的 if判断语句 123&lt;div id=&quot;app&quot;&gt; &lt;div v-if=&quot;isLogin&quot;&gt;欢迎来到XXX.&lt;/div&gt;&lt;/div&gt; 12345678&lt;script type=&quot;text/javascript&quot;&gt; new Vue(&#123; el: &#x27;#app&#x27;, data: &#123; isLogin: true &#125; &#125;);&lt;/script&gt; v-else-if [2.1.0新增] 形式: v-else-if = “express | variable” 值: true -&gt; 渲染 | false -&gt; 不渲染 ! WARN: 必须紧跟在 v-if 或 v-else-if后面, 否则将不被识别. 作用: 其作用相当于C语言中的 else if 判断语句. v-else 形式: v-else 值: 无 作用: 同 v-if 一样, vue的一个内部指令, 用在html标签中. ! WARN: 必须紧跟在 v-if 或 v-else-if后面, 否则将不被识别. 综合示例1234567&lt;div v-if=&quot;type === &#x27;A&#x27;&quot;&gt; A &lt;/div&gt;&lt;div v-else-if=&quot;type === &#x27;B&#x27;&quot;&gt; B &lt;/div&gt;&lt;div v-else-if=&quot;type === &#x27;C&#x27;&quot;&gt; C &lt;/div&gt;&lt;div v-else&gt; Not A/B/C &lt;/div&gt; key 管理可复用元素 形式: key = “unique-value” 值: 不固定, 只要是全局唯一即可 作用: vue为了高效渲染使得加载速度变快, 会复用已有元素, 有时候有的元素虽然相同但是我们不想被复用, 可以在元素中添加key属性来避免被vue复用. 使用了key属性的元素会被重新渲染而不是复用 官网示例12345678&lt;template v-if=&quot;loginType === &#x27;username&#x27;&quot;&gt; &lt;label&gt;Username&lt;/label&gt; &lt;input placeholder=&quot;Enter your username&quot;&gt;&lt;/template&gt;&lt;template v-else&gt; &lt;label&gt;Email&lt;/label&gt; &lt;input placeholder=&quot;Enter your email address&quot;&gt;&lt;/template&gt; 这个例子, 如果input 输入框内有内容, 在切换的时候不会被清空, 因为被vue复用了. 12345678&lt;template v-if=&quot;loginType === &#x27;username&#x27;&quot;&gt; &lt;label&gt;Username&lt;/label&gt; &lt;input placeholder=&quot;Enter your username&quot; key=&quot;username-input&quot;&gt;&lt;/template&gt;&lt;template v-else&gt; &lt;label&gt;Email&lt;/label&gt; &lt;input placeholder=&quot;Enter your email address&quot; key=&quot;email-input&quot;&gt;&lt;/template&gt; 而这个例子, 如果&lt;input&gt;输入框内有内容, 在切换时会被清空, 因为不会被复用而是重新渲染. 但是 &lt;label&gt;依然会被高效复用, 因为没有key属性. key属性作用: 避免被复用, 使之重新渲染 v-show 形式: v-show = “express | variable” 值: true -&gt; 显示[^4] | false -&gt; 不显示 作用: vue的一个内部指令, 用在html标签中, 用于判断所在标签是否显示, 而不是是否渲染 1234567891011121314151617&lt;div id=&quot;app&quot;&gt; &lt;h1 v-show=&quot;right&quot;&gt;Hello!&lt;/h1&gt; &lt;!--当right为true时, 该标签会被显示, 为false时不显示--&gt; &lt;h2 v-show=&quot;status === 1&quot;&gt; 当status为1时显示 &lt;/h2&gt;&lt;/div&gt;&lt;script type=&quot;text/javascript&quot;&gt; new Vue(&#123; el: &#x27;#app&#x27;, data:&#123; right: true, status: 2 &#125; &#125;);&lt;/script&gt;渲染后的结果:&lt;h1 style=&quot;display:block;&quot;&gt;Hello!&lt;/h1&gt;&lt;h2 style=&quot;display:none;&quot;&gt; 当status为1时显示 &lt;/h2&gt; v-if VS v-show渲染: v-if 是“真正”的条件渲染，因为它会确保在切换过程中条件块内的事件监听器和子组件适当地被销毁和重建。 v-show只是简单地基于 CSS 进行切换。 渲染时机: v-if 也是惰性的：如果在初始渲染时条件为假，则什么也不做——直到条件第一次变为真时，才会开始渲染条件块。 v-show 就简单得多——不管初始条件是什么，元素总是会被渲染， 开销: v-if 有更高的切换开销，而 v-show 有更高的初始渲染开销。 因此: 如果需要非常频繁地切换，则使用 v-show 较好； 如果在运行时条件很少改变，则使用 v-if 较好。 v-for数组作为数据源 形式: 渲染一个数组 v-for = “alias in source” 或 v-for = “alias of source” v-for = “(alias, index) in source” 值: source -&gt; 数据源, 是一个数组 alias -&gt; 别名, 遍历时的临时变量 index -&gt; 索引(下标), 默认的, 可以取别的名, 但是约定俗成是 index ! WARN: 别名和索引的位置不能换. 即使换了解释器也默认按照 第一个参数是临时变量, 第二个参数是索引, in 后面的参数是数据源 的规则来解释 哪个元素要被循环渲染就写在哪个元素里作为它的属性. 作用: 将数组里的每一个值渲染到标签的插值[^7]中. 12345678910111213141516171819202122232425&lt;div id=&quot;app&quot;&gt; &lt;ul&gt; &lt;li v-for=&quot;age in DemoArray&quot;&gt;&#123;&#123;age&#125;&#125;&lt;/li&gt; &lt;/ul&gt;&lt;/div&gt;&lt;script type=&quot;text/javascript&quot;&gt; new Vue(&#123; el: &#x27;#app&#x27;, data: &#123; DemoArray: [20, 30, 44, 10, 33] &#125; &#125;);&lt;/script&gt;// 渲染结果=&gt;&gt;&lt;div id=&quot;app&quot;&gt; &lt;ul&gt; &lt;li&gt;20&lt;/li&gt; &lt;li&gt;30&lt;/li&gt; &lt;li&gt;44&lt;/li&gt; &lt;li&gt;10&lt;/li&gt; &lt;li&gt;33&lt;/li&gt; &lt;/ul&gt;&lt;/div&gt; // 显示结果 ==&gt;&gt; 20 30 44 10 33 排序 计算的工作都在computed里完成 排序实现在vue对象中的computed, 但是computed里的键名不能和data里的键名相同. 而我们要按排序后的数组渲染, 所以 html 里要改成 v-for = “age in sortArray” 12345678910&lt;div id=&quot;app&quot;&gt; &lt;ul&gt; &lt;li v-for=&quot;age in DemoArray&quot;&gt;&#123;&#123;age&#125;&#125;&lt;/li&gt; &lt;/ul&gt;&lt;/div&gt;&lt;script type=&quot;text/javascript&quot;&gt;4...&lt;/script&gt; 123456789101112131415161718&lt;script type=&quot;text/javascript&quot;&gt; new Vue(&#123; el: &#x27;#app&#x27;, data: &#123; DemoArray: [20, 30, 44, 10, 33] &#125;, computed: &#123; /** 错误写法. 键名重复 DemoArray: function()&#123; return this.DemoArray.sort((a, b) =&gt; a - b); &#125; */ sortItems: function()&#123; return this.DemoArray.sort((a, b) =&gt; a - b); &#125; &#125; &#125;);&lt;/script&gt; 因为 javascript 自带的 bug, 对数组排序 DemoArray.sort()是把每个数组元素的最前面的一位[^5], 所以排序出来是有问题的. 导致这个 bug 的原因我猜想是因为 js 是弱类型语言, 解释器也不知道你这个数组里到底是字符串还是数字还是什么, 又得给你排序, 所以干脆统统按 给字符串排序 的方法处理. 修复方法就是自己实现一个函数. 上述代码中用了箭头函数使得更加简洁. 关键代码即 (a, b) =&gt; a - b 数组更新会修改原数组的方法: 变异方法 push() pop() shift() unshift() splice() sort() reverse() 通过这些方法修改数组, 会触发视图的更新. 不会修改原数组的方法: 非变异方法 filter() concat() slice() 它们不会改变原始数组，而返回一个新数组。 当使用非变异方法时，可以用新数组替换旧数组： 1234567891011var app = new Vue (&#123; el: &#x27;#app&#x27;, data:&#123; items: [ &#123;msg: &quot;m1&quot;&#125;, &#123;msg: &quot;m2&quot;&#125; ] &#125;&#125;);// 替换 app.items = app.items.filter( item =&gt; item.items.match(/mmm/) ) ; ? 这里不清楚怎么实现的, 但是官网的说法是: 并非丢弃现有DOM而重新渲染整个列表, 因为Vue里有些智能的方法, 所以, 数组在改动不大的情况下去替换原有数组的非常高效的, 不必担心. 至于怎么个智能法没说, 有待深挖. 数组更新的注意事项问题:由于不靠谱的JavaScript的限制, 以下两种方法的更新Vue是无法检测到的 利用索引直接设置一个数组项时，例如：vm.items[indexOfItem] = newValue 修改数组的长度时，例如：vm.items.length = newLength 12345678var app = new Vue(&#123; ... data: &#123; array: [0,1,2,3,4,5,6,7,8] &#125;&#125;);app.array[3] = 10 //Vue 检测不到更新, 也不会触发视图更新app.array.length = 8 //Vue 检测不到更新 解决: 问题1123456789101112131415161718192021Vue.set(vm.items, indexOfItem, newValue), // 例如: Vue.set(app.array, 2, 10)// ==&gt;&gt; [0,1,10,3,4,5,6,7,8]或vm.items.splice(indexOfItem, 1, newValue), // 例如: app.array.splice(3, 1, 50)// ==&gt;&gt; [0,1,2,50,4,5,6,7,8] // 关于这个1,可以是任何数, // 0则不吃掉任何元素, // 1则吃掉array[indexOfItem]那个元素,// 2则吃掉array[indexOfItem] 和 array[indexOfItem + 1]两个元素// 以此类推// 例如: app.array.splice(2,2,30)// ==&gt;&gt; [0,1,30,5,6,7,8] 或vm.$set(vm.items, indexOfItem, newValue)// 例如: app.$set(app.array, 2, 10)// ==&gt;&gt; [0,1,10,3,4,5,6,7,8] 解决: 问题21app.array.splice(新长度值) 对象作为数据源 形式: 渲染一个对象 v-for = “value in object” v-for = “(value, key) in object” v-for = “(value, key, index) in object” 值: object -&gt; 数据源, 是一个对象, 要遍历的是它的所有属性 value -&gt; 别名, 遍历时的临时变量, 输出的是每一个属性的值 key -&gt; 索引(键名), 默认的, 可以取别的名, 但是约定俗成是 key, 输出的是每一个属性(键值对)的键名 index -&gt; 索引(下标), 默认的, 可以取别的名, 约定俗成是index, 输出的是每一个属性的下标[^6]. ! WARN: 和遍历数组一样, 键名索引和下标索引的位置不要换. 即使换了解释器也是按照 第一个参数是临时变量,第二个参数是键名索引, 第三个参数是下标索引, in 后面是数据源的规则解释. 哪个元素要被循环渲染就写在哪个元素里作为它的属性. 作用: 将对象里的每一个属性(键值对)的值渲染到标签的插值[^7]中. 123456789101112131415161718192021222324252627&lt;div id=&quot;app&quot;&gt; &lt;ul&gt; &lt;li v-for=&quot;(val, key, idx) in obj&quot;&gt;&#123;&#123;idx&#125;&#125;-&#123;&#123;key&#125;&#125;-&#123;&#123;val&#125;&#125;&lt;/li&gt; &lt;/ul&gt;&lt;/div&gt;&lt;script type=&quot;text/javascript&quot;&gt; new Vue(&#123; el: &#x27;#app&#x27;, data: &#123; obj:&#123; prop1: &#x27;key1&#x27;, prop2: 20, prop3: true &#125; &#125; &#125;);&lt;/script&gt;// 渲染结果 =&gt;&gt;&lt;div id=&quot;app&quot;&gt; &lt;ul&gt; &lt;li&gt;0-prop1-key1&lt;/li&gt; &lt;li&gt;1-prop2-20&lt;/li&gt; &lt;li&gt;2-prop3-true&lt;/li&gt; &lt;/ul&gt;&lt;/div&gt; // 显示结果 ==&gt;&gt; 0-prop1-key1 1-prop2-20 2-prop3-true 对象更新的注意事项问题:由于不靠谱的JavaScript的限制, 对象属性的添加或删除 Vue是检测不到的 12345678var app = new Vue(&#123; el: &#x27;#app&#x27;, data: &#123; a: 1 &#125;&#125;);app.b = 2 // Vue检测不到, 不会更新视图 解决方法app.a app.b 这里a和b叫做根级别响应式属性, 是不允许动态添加的, 但是根级别属性的属性是可以动态添加的. 12345678var app = new Vue(&#123; el: &#x27;#app&#x27;, data: &#123; root:&#123; child: 1 &#125; &#125;&#125;);// app.root 不允许动态添加, app.root.child允许动态添加 添加单个属性的方法 12345678Vue.set(rootAttribute, childKey, childValue)// 例如: Vue.set(app.root, &#x27;age&#x27;, 10)// ==&gt;&gt; data: &#123;// root: &#123; child: 1, age: 10&#125;// &#125;或vm.$set(rootAttribute, childKey, childValue)// 例如: app.$set(app.root, &#x27;age&#x27;, 10) 添加多个属性的方法: 使用 Object.assign() 或 _.extend() 1app.root = Object.assign(&#123;&#125;, app.root, &#123; age: 27, favoriteColor: &#x27;Vue Green&#x27; &#125;) 数组对象作为数据源的排序 计算处理同样是在computed中. 重新定义一个函数, 并作出处理 在v-for调用时 把数据源换成刚刚定义的函数名 12345678computed: &#123;4...4//数组对象方法排序:4sortStudents: function () &#123;4 var key = &quot;age&quot;;4 return this.students.sort((a, b) =&gt; a[key] &lt; b[key] ? -1 : (a[key] &gt; b[key] ? 1 : 0)) &#125;&#125; 范围作为数据源形式: 渲染一个对象 v-for = “value in object” v-for = “(value, key) in object” v-for = “(value, key, index) in object” 值: object -&gt; 数据源, 是一个对象, 要遍历的是它的所有属性 value -&gt; 别名, 遍历时的临时变量, 输出的是每一个属性的值 key -&gt; 索引(键名), 默认的, 可以取别的名, 但是约定俗成是 key, 输出的是每一个属性(键值对)的键名 index -&gt; 索引(下标), 默认的, 可以取别的名, 约定俗成是index, 输出的是每一个属性的下标[^6]. ! WARN: 和遍历数组一样, 键名索引和下标索引的位置不要换. 即使换了解释器也是按照 第一个参数是临时变量,第二个参数是键名索引, 第三个参数是下标索引, in 后面是数据源的规则解释. 哪个元素要被循环渲染就写在哪个元素里作为它的属性. 作用: 将对象里的每一个属性(键值对)的值渲染到标签的插值[^7]中. 形式: v-for=” n in range” 值: n -&gt; 别名, 遍历时的临时变量 range -&gt; 数据源, 遍历的范围 123&lt;div&gt; &lt;span v-for=&quot;n in 10&quot;&gt;&#123;&#123; n &#125;&#125; &lt;/span&gt;&lt;/div&gt; 显示结果 ==&gt;&gt; 1 2 3 4 5 6 7 8 9 10 v-for 和 v-if 一起用时尽量不要把v-for 和 v-if 放在同一个标签里 但他们处在同一个标签内时, v-for 的优先级比 v-if 高 1234&lt;!--尽量不要--&gt;&lt;li v-for=&quot;todo in todos&quot; v-if=&quot;!todo.isComplete&quot;&gt; &#123;&#123; todo &#125;&#125;&lt;/li&gt; 1234567&lt;!--上面是特殊情况下的写法, 下面是正常情况下的规范写法--&gt;&lt;ul v-if=&quot;todos.length&quot;&gt; &lt;li v-for=&quot;todo in todos&quot;&gt; &#123;&#123; todo &#125;&#125; &lt;/li&gt;&lt;/ul&gt;&lt;p v-else&gt;No todos left!&lt;/p&gt; [^1]:渲染, 加载完DOM树之后就开始在页面上加载, 这个过程叫做渲染[^2]:加载, 当浏览器接收到服务器返回的html文件时, 会读取所有html标签形成一颗DOM树[^3][^3]:DOM树, 全部html标签的树状结构[^4]:display: block[^5]:如果是字符串就,第一位就是第一个字符; 如果是数字,第一位就是最大位的那个数字, 比如39的第一位是3[^6]:对象中的属性都是键值对, 属性的下标从0开始, 先定义的属性(键值对)下标就靠前[^7]:插值, HTML标签中间用 &#123;&#123; 插值 &#125;&#125; 包起来的地方","categories":[{"name":"Note","slug":"Note","permalink":"https://www.boii.xyz/categories/Note/"},{"name":"Vue","slug":"Vue","permalink":"https://www.boii.xyz/categories/Vue/"}],"tags":[{"name":"Vue","slug":"Vue","permalink":"https://www.boii.xyz/tags/Vue/"}]},{"title":"全站变灰的实现","slug":"全站变灰的实现","date":"2020-04-06T02:47:03.000Z","updated":"2020-04-06T02:47:03.000Z","comments":true,"path":"2020/04/06/全站变灰的实现/","link":"","permalink":"https://www.boii.xyz/2020/04/06/%E5%85%A8%E7%AB%99%E5%8F%98%E7%81%B0%E7%9A%84%E5%AE%9E%E7%8E%B0/","excerpt":"哀悼日-全站变灰的实现","text":"哀悼日-全站变灰的实现 前言作为一个关心家国大事的青年，在国家有难时因争相出手付出举手之劳，虽然现在时和平年代，但是也会经历 918公祭日、哀悼日等。 每到这些日子，警报响彻神州, 江水呜咽，山川悲鸣; 大江南北，长城内外，国家以最高的祭奠向英雄哀悼，人民以最深的怀念为英雄送行。 除了现场祭奠，线上我们也想表达自己对那些烈士、英雄和逝世同胞的深切哀悼，那么可以通过全站变灰的方式，遮去往日绚烂的色彩，跳脱的动效为他们沉寂。 下面将介绍如何让全站变灰。 青铜操作作为 铂金CV工程师 先来一顿 青铜段 操作: 用最广告的引擎搜索: 全站变灰 点进广告最多的论坛, 将关键代码进行数据读取: Ctrl + C 来到自己的站点启动全站检测: F12 找到html标签, 在style面板中进行数据写入: Ctrl + V 完美~ 白银操作接下来就要进行 白银段 操作了: 这里我用的是Volantis这个主题, 你要找到你自己主题里生成 &lt;head&gt;&lt;/head&gt;标签的那个文件. 进入网站根目录, 找到 themes\\volantis\\layout_partial\\head.ejs 在 &lt;head&gt;&lt;/head&gt; 标签内添加 themes\\volantis\\layout\\_partial\\head.ejs12345678910&lt;style&gt; html &#123; -webkit-filter: grayscale(100%); -moz-filter: grayscale(100%); -ms-filter: grayscale(100%); -o-filter: grayscale(100%); filter: progid:DXImageTransform.Microsoft.BasicImage(grayscale=1); _filter: none; &#125;&lt;/style&gt; 保存,推送: hexo g -d 做到这里其实就够了. 但是你也可以进阶一下 黄金操作再来顿 黄金段 操作: 在刚刚添加 &lt;style&gt;...&lt;/style&gt; 标签外面再套上一句ejs的判断语句 themes\\volantis\\layout\\_partial\\head.ejs123456789101112&lt;% if (theme.style.mourn) &#123; %&gt;&lt;style&gt; html &#123; -webkit-filter: grayscale(100%); -moz-filter: grayscale(100%); -ms-filter: grayscale(100%); -o-filter: grayscale(100%); filter: progid:DXImageTransform.Microsoft.BasicImage(grayscale=1); _filter: none; &#125;&lt;/style&gt;&lt;% &#125; %&gt; 在你的主题目录的配置文件 themes\\volantis\\_config.yml 中, 添加 mourn: true themes\\volantis\\_config.yml123style: ... mourn: true # 哀悼: 全站变灰 保存,推送: hexo g -d 这样当你要关掉的时候就不用再跑去head.ejs中删除了, 直接在主题配置文件中把mourn: false 就行了. 开启 -> mourn: true 关闭 -> mourn: false 也可以把mourn放到最外层, 只要让 mourn字段 前面没有空格就行, 相应的 &lt;% if (theme.style.mourn) &#123; %&gt; 要改成 &lt;% if (theme.mourn) &#123; %&gt; 这是yaml的语法, 不懂的出门左转 铂金操作最后是 铂金段 操作 推送毕竟需要时间, 如果我们想要实现准时准点时间一到自动全站变灰,那就要升级下操作了.只需要把刚刚的代码修改一下. themes\\volantis\\layout\\_partial\\head.ejs1234567891011121314151617&lt;% if (theme.style.mourn.switch)&#123; %&gt;&lt;% var startTime = Date.parse(theme.style.mourn.startTime.replace(/-/g, &quot;/&quot;)); %&gt;&lt;% var endTime = Date.parse(theme.style.mourn.endTime.replace(/-/g, &quot;/&quot;)); %&gt;&lt;% var currentTime = Date.now(); %&gt;&lt;% &#125; %&gt;&lt;% if (currentTime &gt; startTime &amp;&amp; currentTime &lt; endTime) &#123; %&gt; &lt;style&gt; html &#123; -webkit-filter: grayscale(100%); -moz-filter: grayscale(100%); -ms-filter: grayscale(100%); -o-filter: grayscale(100%); filter: progid:DXImageTransform.Microsoft.BasicImage(grayscale=1); _filter: none; &#125; &lt;/style&gt;&lt;% &#125; %&gt; 然后配置中改成: themes\\volantis\\_config.yml123456style: ... mourn: # 哀悼: 全站变灰 switch: true startTime: &#x27;2020-4-4 0:0:0&#x27; endTime: &#x27;2020/4/5 0:0:0&#x27; 这样只需要填写好开启关闭的时间, 然后打开开关switch: true即可 日期用-或者/分隔都可以, 因为ejs中有做格式化时间一定要用(英文)冒号:分隔日期和时间之间要有空格隔开个位数不要添加前缀, 比如凌晨三点要写 3:0:0, 不要写成 03:00:00 心得之前配置主题的时候小心翼翼, 生怕一不小心弄错了就头大.折腾了一段时间积攒了一些经验 一. 边预览边修改1. 可以使用命令hexo s 开启本地预览, 在浏览器输入localhost:4000开启本地预览2. 开启后cmd窗口放在一旁, 在编辑器中做修改, hexo server 一直监听着变化, 每次保存都会自动编译3. 只需要在浏览器里刷新一下就可以看到结果. 有什么编译错误cmd窗口里也会实时的显示出来.二. 学会看报错信息常见的报错信息就那么几个单词, 不懂的翻译一下, 知道错在哪里, 然后思考为什么会错误, 一步步修改, 慢慢的一点点积累就会成长.三. YAML是个好东西掌握了yaml语法以后, 就可以自由的添加自己想要的配置.就上面的修改全站变灰为例, 说白了就是找到自己想要的效果的代码, 然后在ejs里做判断, ejs和yaml配合, 就可以作出自己想要的效果了.","categories":[{"name":"HEXO","slug":"HEXO","permalink":"https://www.boii.xyz/categories/HEXO/"}],"tags":[{"name":"HEXO","slug":"HEXO","permalink":"https://www.boii.xyz/tags/HEXO/"},{"name":"YAML","slug":"YAML","permalink":"https://www.boii.xyz/tags/YAML/"}]},{"title":"Electron Note","slug":"Electron-Note","date":"2020-03-21T08:55:25.000Z","updated":"2021-05-23T04:38:07.378Z","comments":true,"path":"2020/03/21/Electron-Note/","link":"","permalink":"https://www.boii.xyz/2020/03/21/Electron-Note/","excerpt":"","text":"Hello World在项目文件夹下新建两个文件: main.html &amp; main.js 123456789101112131415161718&lt;!--main.html--&gt;&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;Hello World&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;h1 id=&quot;title&quot;&gt; Hello World ! &lt;/h1&gt;&lt;/body&gt;&lt;/html&gt; 12345678910111213141516171819// main.jsconst electron = require(&#x27;electron&#x27;); // 引入electron模块const app = electron.app; // 创建electron引用const BrowserWindow = electron.BrowserWindow; // 创建窗口引用let mainWindow = null; // 声明要打开的主窗口app.on(&#x27;ready&#x27;, () =&gt; &#123; mainWindow = new BrowserWindow(&#123; // 设置打开的窗口大小 width: 800, heigth: 500 &#125;); mainWindow.loadFile(&#x27;main.html&#x27;); // 加载html页面 mainWindow.on(&#x27;closed&#x27;, () =&gt; &#123; // 监听窗口关闭事件 mainWindow = null // 一定要把窗口设置为null,否则会一直占内存 &#125;); // 如同C语言申请内存后一定要free释放内存&#125;); 然后打开cmd命令行, cd到项目的根目录, 执行命令 1npm init 项目根目录就会生成一个 package.json 文件 12345678910111213&#123; &quot;name&quot;: &quot;Hello-World&quot;, &quot;version&quot;: &quot;1.0.0&quot;, &quot;description&quot;: &quot;&quot;, &quot;main&quot;: &quot;main.js&quot;, &quot;scripts&quot;: &#123; &quot;test&quot;: &quot;echo \\&quot;Error: no test specified\\&quot; &amp;&amp; exit 1&quot;, &quot;start&quot;: &quot;electron .&quot; // 这句要自己添加 &#125;, &quot;keywords&quot;: [], &quot;author&quot;: &quot;&quot;, &quot;license&quot;: &quot;ISC&quot;&#125; 然后就可以在 cmd命令行 中执行命令来启动项目 1npm start 或者 electron . 效果如下: 也可以自己添加 main.css 编写样式, 让界面更好看. 所有命名不固定. 主进程与渲染进程主进程 Electron 运行 package.json 的 main属性 的进程被称为主进程 每个应用只有一个主进程 作用: 管理原生GUI , 典型的窗口(BrowserWindow , Tray, Dock, Menu) 创建渲染进程 控制应用生命周期 (app) 模块: **(常用): **app , BrowserWindow , ipcMain , Menu , Tray , MenuItem , dialog , Notification , webContents , autoUpdater , globalShortcut , clipboard , crashReporter SystemPreferences , TouchBar , netLog , powerMonitor , inAppPurchase , net , powerSaveBlocker , contentTracing , BrowserView , session , protocol , Screen , shell , nativelmage 渲染进程 展示web页面的进程称为渲染进程 一个应用可以有多个渲染进程 作用: 通过Node.js, Electron提供的API可以跟系统底层打交道 常用模块: **(常用): **ipcRenderer , remote , desktopCapture , clipboard , crashReporter webFrame , shell , nativelmage 进程间通信通信工具: IPC通信模块 Electron 提供了IPC通信模块, 主进程的 ipcMain 和渲染进程的 ipcRenderer ipcMain 和 ipcRenderer 都是EventEmitter 对象 从渲染进程到主进程 (render to main) Callbake写法: ipcRenderer.send( channer, …args) // 渲染进程中发送 ipcMain.on(channel, handler) // 主进程中响应 123456789101112131415// Render-process.jsconst &#123;ipcRenderer&#125; = require(&#x27;electron&#x27;);ipcRenderer.send(&#x27;通信频段名&#x27;, 0或N个参数);// Main-process.js...function handleIPC() &#123; ipcMain.on(&#x27;通信频段名&#x27;, (err, 0或N个参数) =&gt; &#123; // do something to reply &#125;);&#125;setTimeout(handleIPC, 500);... Promise写法 (Electron 7.0之后, 处理请求 + 响应模式): ipcRenderer.invoke(channel, …args) // 渲染进程中发送 ipcMain.handle(channel, handler) // 主进程中响应 从主进程到渲染进程 (main to render) ipcRenderer.on(channel, handler) // 渲染进程中响应 webContents.send(channel) // 主进程中发送 123456789101112// Main-process.js...mainWindow = new BrowserWindow(&#123;......&#125;);mainWindow.webContents.send(&#x27;通信频段名&#x27;);...// Render-process.jsconst &#123;ipcRenderer&#125; = require(&#x27;electron&#x27;);ipcRenderer.on(&#x27;通信频段名&#x27;, (err, 0或N个参数) =&gt; &#123; // do something to reply&#125;) 从渲染进程到渲染进程 (render to render) 页面间通信页面之间的通信主要做两件事情: 1. 通知事件; 2. 数据共享 通知事件 ipcRenderer.sendTo( webContentsId, channel, …args ) 1234567891011121314151617181920// Main-process.jsconst &#123;app, BrowserWindow, Notification, ipcMain&#125; = require(&#x27;electron&#x27;);let win1 = null;let win2 = null;app.on(&#x27;ready&#x27;, () =&gt; &#123; win1 = new BrowserWindow(&#123; width:500, heigth:500, webPreferences:&#123;nodeIntegration:true&#125; &#125;); win1.loadFile(&#x27;./win1.html&#x27;); win2 = new BrowserWindow(&#123; width:500, heigth:500, webPreferences:&#123;nodeIntegration:true&#125; &#125;); win2.loadFile(&#x27;./win2.html&#x27;); global.sharedObject = &#123; win2WebContentsId: win2.webContents.id &#125; //把win2的id放在全局对象中&#125;); 12345// render1-process.js// senderconst &#123;ipcRenderer, remote&#125; = require(&#x27;electron&#x27;)let win2Id = remote.getGlobal(&#x27;sharedObject&#x27;).win2WenContentsId //获取win2的idipcRenderer.sendTo(win2Id, &#x27;通信频段名&#x27;, 0或N个参数) // 与win2进行通信 123456// render2-process.js// responserconst &#123;ipcRenderer&#125; = require(&#x27;electron&#x27;)ipcRenderer.on(&#x27;通信频段名&#x27;, (err, 0或N个参数) =&gt; &#123; // 响应 // do something to reply&#125;); 数据共享 使用web技术( localStorage , sessionStorage , indexedDB ) 调试渲染进程的调试 用代码打开 Chromiun的开发者工具 12let win = new BrowserWindow();win.webContents.openDevTools(); 输入命令行 electron . 之后, 在窗口按下快捷键 Ctrl + Shift + i 主进程的调试Electron 主进程是一个 Node.js 进程。Node.js 在 8 之后引入了 --inspect 参数用于调试，同样也适用于 Electron 主进程： 1electron . --inspect 默认会监听 9229 端口，应用启动后，在 Chrome 浏览器（或其他基于 Chromium 开发的浏览器）中打开 chrome://inspect 即可看到对应的调试会话，点击会话链接即可打开 devtools 进行调试。 另外，可以在命令行参数中指定端口号，实现同时调试多个应用中的多个进程而不产生冲突： 1electron . --inspect=1234 步骤1.开启命令行开关 启动electron的时候需要带上inspect开关，并配置调试端口. 有两个开关，分别是 --inspect=[port] 和 --inspect-brk=[port]，区别在于后者会暂停在第一行js代码 这里建议在 package.json 的 script 字段添加如下内容 12345&quot;scripts&quot;: &#123; &quot;test&quot;: &quot;echo \\&quot;Error: no test specified\\&quot; &amp;&amp; exit 1&quot;, &quot;start&quot;: &quot;electron .&quot;, &quot;debug&quot;: &quot;electron . --inspect=5858&quot; // 添加这行 &#125;, 2.设置chrome调试器 打开chrome，然后新开一个标签进入chrome://inspect ，这里我们要先配置监听的端口，不然的话，Remote Target列表里是不会出现要调试的electron程序的 &gt;_ &gt;_ 然后在项目目录下就可以直接使用命令 1npm run debug 就可以看到如下画面: &gt;_ 3.调试 点击 inspect 就可以进行调试了. 在 VSCode 中调试上述方法均会打开 devtools 界面，所有的调试操作均在 devtools 中进行。对于某些操作比如代码断点调试，可以进一步与编辑器或 IDE 相结合，提升开发体验。以下将简要介绍如何在 VSCode 进行调试。 以 Electron 官方的模板 electron-quick-start 为例，首先需要为 VSCode 安装一个扩展：Debugger for Chrome（用于调试渲染进程）。克隆代码仓库到本地并安装依赖： 123git clone https://github.com/electron/electron-quick-start.gitcd electron-quick-startnpm install 然后在仓库中添加文件 .vscode/launch.json，内容如下： 12345678910111213141516171819202122232425262728&#123; &quot;version&quot;: &quot;0.2.0&quot;, &quot;configurations&quot;: [ &#123; &quot;name&quot;: &quot;Main&quot;, &quot;type&quot;: &quot;node&quot;, &quot;request&quot;: &quot;launch&quot;, &quot;runtimeExecutable&quot;: &quot;C:\\\\Users\\\\用户名\\\\AppData\\\\Roaming\\\\npm\\\\electron&quot;, &quot;runtimeArgs&quot;: [&quot;--remote-debugging-port=9222&quot;, &quot;.&quot;], &quot;windows&quot;: &#123; &quot;runtimeExecutable&quot;: &quot;C:\\\\Users\\\\用户名\\\\AppData\\\\Roaming\\\\npm\\\\electron.cmd&quot; &#125; &#125;, &#123; &quot;name&quot;: &quot;Renderer&quot;, &quot;type&quot;: &quot;chrome&quot;, &quot;request&quot;: &quot;attach&quot;, &quot;port&quot;: 9222, &quot;webRoot&quot;: &quot;$&#123;workspaceFolder&#125;&quot; &#125; ], &quot;compounds&quot;: [ &#123; &quot;name&quot;: &quot;All&quot;, &quot;configurations&quot;: [&quot;Main&quot;, &quot;Renderer&quot;] &#125; ]&#125; 注意: Windows系统的路径分隔符要写作 “\\\\“ if 普通安装electron ​ then 把”用户名”改成”你系统的用户名”; else 自定义安装electron ​ then 找到你的 electron.cmd; ​ 复制路径; ​ 到 json中修改; if Linux用户 ​ then 系统.路径分隔符 = “/“ if (项目根目录/node_modules/.bin/electron).isExist ​ then 1234&quot;runtimeExecutable&quot;: &quot;$&#123;workspaceFolder&#125;/node_modules/.bin/electron&quot;,&quot;windows&quot;: &#123; &quot;runtimeExecutable&quot;: &quot;$&#123;workspaceFolder&#125;/node_modules/.bin/electron.cmd&quot;&#125; 然后在 VSCode 左侧选择 debug 面板，启动 All 这一项开始调试，此时就可以在 main.js 或 renderer.js 文件中添加断点了： 配置文件中的一些要点解释如下： configurations 中的两项分别对应主进程和渲染进程。compounds 中指定了一个组合会话 All，选择 All 将会同时启动这两个会话。 Renderer 配置中的 webRoot 参数直接使用了 $&#123;workspaceFolder&#125;，是因为在这个工程中，HTML 引用的静态资源位于根目录下。实际使用的时候需要更新到对应的路径才会生效。 实际开发中可能会有编译的流程，比如使用 TypeScript 配合打包工具 Webpack，最终生成的代码与源代码并不在一个路径下。这种情况下需要产出 source map 来建立映射关系。 &gt;_ 经验技巧 少用remote模块 因为每次remote会触发底层的同步IPC事件, 特别影响性能, 处理的不好容易进程卡死 不要用sync模式 一旦写的不好就会整个应用卡死 在请求+响应的通信模式下,需要自定义超时限制 在响应的时候需要设置一个时长限制, 当应用响应超时, 需要response一个异常的超时事件让业务处理, 然后去做对应的交互","categories":[{"name":"Note","slug":"Note","permalink":"https://www.boii.xyz/categories/Note/"},{"name":"Electron","slug":"Electron","permalink":"https://www.boii.xyz/categories/Electron/"}],"tags":[{"name":"note","slug":"note","permalink":"https://www.boii.xyz/tags/note/"},{"name":"Electron","slug":"Electron","permalink":"https://www.boii.xyz/tags/Electron/"}]},{"title":"Git-基本操作说明","slug":"Git-基本操作说明","date":"2019-07-18T00:09:37.000Z","updated":"2021-05-23T04:38:40.865Z","comments":true,"path":"2019/07/18/Git-基本操作说明/","link":"","permalink":"https://www.boii.xyz/2019/07/18/Git-%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C%E8%AF%B4%E6%98%8E/","excerpt":"","text":"经典git关系图 Workspace：工作区 Index / Stage：暂存区 Repository：仓库区（或本地仓库） Remote：远程仓库 初始化刚新建一个项目的时候需要来几条初始化命令 生成本地仓库git init 把工作区的文件提交到暂存区git add .或者git add 文件名 把暂存区的文件提交到本地仓库git commit -m “描述”这里的描述就是到时候看到的下面的这些 先给你要提交的远程仓库起个别名git remote add 仓库别名 Git地址Git地址如下图所示 把本地仓库的文件提交到远程仓库（就是github上能看到的那种）git push -u 仓库别名 分支名分支就是….算了这里是傻瓜备忘不想解释 到这就可以上去github看看了。文件内容都在里面 第二次提交第二次提交的时候一般不是整个项目都有变动对吧？没事git会自动识别修改过的和没修改过的文件 可以看看git识别到哪些git status 红色的，Umerged，表示工作区有改动的文件，还没提交到暂存区git文件的四种状态 untracked 未被追踪的。就是还没添加过的 unmodified 工作区里已经被追踪了，还没修改 modified 工作区的文件修改了但还没提交到暂存区 staged 添加到了暂存区倒是还没提交到远程仓库 把它提交到暂存区去git add . 把它提交到本地仓库去git commit -m “描述” 把它提交到远程仓库去git push -u 远程仓库别名 分支名 搞定！ 拉取远程仓库的文件到本地git pull 远程仓库别名 分支名 多用户共同开发的时候，新用户可能会在本地新建一个文件夹，然后git init, 接着pull可能会出现拉取失败，因为git认为这是两个不同的项目，所以拒绝拉取合并，可以加上--allow-unrelated-histories 1git pull 仓库别名 分支名 --allow-unrelated-histories 总结要把代码写完放在github上就等于 你要从山旮旯里寄东西到北京 工作区 =&gt; 就是你项目的文件夹，你经营的这家客栈暂存区 =&gt; 就是你这个项目的git索引，你这个村里的驿站本地仓库 =&gt; 就是你电脑里的一个存储库，你市里的驿站远程仓库 =&gt; 就是github服务器上面，北京 你东西收拾好了的时候 得找村里的快递站帮你保管和寄送到市里的快递站git add .等你说commit的时候 市里的快递站 就给你 送到省里的快递站git commit -m &quot;描述&quot;等你说push的时候 省里的快递站 就给你 送到北京git push -u 远程仓库别名 分支名 &gt;_","categories":[{"name":"Git","slug":"Git","permalink":"https://www.boii.xyz/categories/Git/"}],"tags":[{"name":"git","slug":"git","permalink":"https://www.boii.xyz/tags/git/"},{"name":"命令","slug":"命令","permalink":"https://www.boii.xyz/tags/%E5%91%BD%E4%BB%A4/"}]},{"title":"SSM-配置文件","slug":"SSM-配置文件","date":"2019-07-14T15:19:12.000Z","updated":"2021-05-23T04:40:33.997Z","comments":true,"path":"2019/07/14/SSM-配置文件/","link":"","permalink":"https://www.boii.xyz/2019/07/14/SSM-%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6/","excerpt":"","text":"前言SSM框架中有几个比较重要的配置文件，一开始学起来会很模糊，这里做一下整理 当一个web程序启动时，Tomcat服务器最先会读取 web.xml 文件，这个文件中会启动一些配置，还会启动Spring配置文件**applicationContext.xml** 和SpringMVC配置文件 springMVC-servlet.xml 这两个文件，在运行 applicationContext.xml 的时候会启动MyBatis的配置文件 **myBatis.xml**，并且会调用到 jdbc.properties 和 log4J.properties 两个资源属性文件里的属性。 web.xml接下来先看看最先启动的 web.xml 是都怎么配置。 在Spring配置中和在Servlet配置中，就启动了applicationContext 和 SpringMVC-servlet 两个配置文件 启动applicationContext 1234&lt;context-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:applicationContext.xml&lt;/param-value&gt;&lt;/context-param&gt; 启动SpringMVC-servlet 1234567891011&lt;!--部署Servlet分发器 DispatcherServlet--&gt;&lt;servlet&gt; &lt;servlet-name&gt;springer&lt;/servlet-name&gt; &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt; &lt;!--注册DispatcherServlet的配置文件--&gt; &lt;init-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:springer-servlet.xml&lt;/param-value&gt; &lt;/init-param&gt; &lt;load-on-startup&gt;1&lt;/load-on-startup&gt;&lt;/servlet&gt; 运行到这的时候就会调用到上述两个文件。 整个文件如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;web-app xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns=&quot;http://xmlns.jcp.org/xml/ns/javaee&quot; xsi:schemaLocation=&quot;http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_3_1.xsd&quot; id=&quot;WebApp_ID&quot; version=&quot;3.1&quot;&gt; &lt;!--以下配置的加载顺序:先 ServletContext &gt;&gt; context-param &gt;&gt; listener &gt;&gt; filter &gt;&gt; servlet &gt;&gt; spring--&gt; &lt;!-- ==================== 欢迎页配置 ==================== --&gt; &lt;!--配置欢迎页--&gt; &lt;welcome-file-list&gt; &lt;welcome-file&gt;index.jsp&lt;/welcome-file&gt; &lt;/welcome-file-list&gt; &lt;!-- ==================== Spring配置 ==================== --&gt; &lt;!--启动Spinrg 配置文件 applicationContext.xml--&gt; &lt;context-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:applicationContext.xml&lt;/param-value&gt; &lt;/context-param&gt; &lt;!--配置监听器，加载Spring 配置文件--&gt; &lt;listener&gt; &lt;listener-class&gt;org.springframework.web.context.ContextLoaderListener&lt;/listener-class&gt; &lt;/listener&gt; &lt;!-- ==================== Serlvet配置 ==================== --&gt; &lt;!--部署Servlet分发器 DispatcherServlet--&gt; &lt;servlet&gt; &lt;servlet-name&gt;springer&lt;/servlet-name&gt; &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt; &lt;!--注册DispatcherServlet的配置文件--&gt; &lt;init-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:springer-servlet.xml&lt;/param-value&gt; &lt;/init-param&gt; &lt;load-on-startup&gt;1&lt;/load-on-startup&gt; &lt;/servlet&gt; &lt;!--配置DispatcherServlet的作用范围，这里作用于整个web目录--&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;springer&lt;/servlet-name&gt; &lt;url-pattern&gt;/&lt;/url-pattern&gt; &lt;/servlet-mapping&gt; &lt;!-- ==================== 过滤器配置 ==================== --&gt; &lt;!--配置过编码滤器--&gt; &lt;filter&gt; &lt;filter-name&gt;characterEncodingFilter&lt;/filter-name&gt; &lt;filter-class&gt;org.springframework.web.filter.CharacterEncodingFilter&lt;/filter-class&gt; &lt;!--编码格式：UTF-8--&gt; &lt;init-param&gt; &lt;param-name&gt;encoding&lt;/param-name&gt; &lt;param-value&gt;UTF-8&lt;/param-value&gt; &lt;/init-param&gt; &lt;!--是否全部过滤，包括符合格式的文件/请求--&gt; &lt;init-param&gt; &lt;param-name&gt;forceEncoding&lt;/param-name&gt; &lt;param-value&gt;true&lt;/param-value&gt; &lt;/init-param&gt; &lt;/filter&gt; &lt;!--配置过滤器的作用范围，这里作用于整个WEB目录--&gt; &lt;filter-mapping&gt; &lt;filter-name&gt;characterEncodingFilter&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt; &lt;/filter-mapping&gt; &lt;!-- ==================== 错误页面配置 ==================== --&gt; &lt;!--404错误页面注册--&gt; &lt;error-page&gt; &lt;error-code&gt;404&lt;/error-code&gt; &lt;location&gt;/WEB-INF/jsp/404.jsp&lt;/location&gt; &lt;/error-page&gt;&lt;/web-app&gt; applicationContext.xml这个文件是第二个启动的配置文件 在这个文件里主要做了几件事情： 加载jdbc.properties资源属性文件 配置数据源 配置Mybatis工厂 指定数据源 指定Mybatis配置文件 批量配置Mapper接口 设置需要扫描的dao包 配置sqlSessionFactory对象 添加事务支持 配置事务管理器 配置通知 配置切面 扫描service包 下面一个一个解释： 1.加载jdbc.properties1&lt;context:property-placeholder location=&quot;classpath:jdbc.properties&quot; /&gt; 把连接数据库的一些数据分离出来写在jdbc.properties这个文件中，加载了这个文件就可以使用这些属性 而在 jdbc.properties 文件中的内容如下（这里演示的是MySQL8.0）: 1234567jdbc.driver=com.mysql.cj.jdbc.Driverjdbc.url=jdbc:mysql://localhost:3306/transactional?useSSL=false?serverTimezone=Hongkong?characterEncoding=utf-8?autoReconnect=truejdbc.username=rootjdbc.password=123456jdbc.maxTotal=30jdbc.maxIdle=10jdbc.initialSize=5 至于如何调用，则在下面的配置数据源中演示 2.配置数据源123456789101112&lt;bean id=&quot;dSource&quot; class=&quot;org.apache.commons.dbcp2.BasicDataSource&quot;&gt; &lt;property name=&quot;driverClassName&quot; value=&quot;$&#123;jdbc.driver&#125;&quot;/&gt; &lt;property name=&quot;url&quot; value=&quot;$&#123;jdbc.url&#125;&quot;/&gt; &lt;property name=&quot;username&quot; value=&quot;$&#123;jdbc.username&#125;&quot;/&gt; &lt;property name=&quot;password&quot; value=&quot;$&#123;jdbc.password&#125;&quot;/&gt; &lt;!-- 最大连接数 --&gt; &lt;property name=&quot;maxTotal&quot; value=&quot;$&#123;jdbc.maxTotal&#125;&quot;/&gt; &lt;!-- 最大空闲连接数 --&gt; &lt;property name=&quot;maxIdle&quot; value=&quot;$&#123;jdbc.maxIdle&#125;&quot;/&gt; &lt;!-- 初始化连接数 --&gt; &lt;property name=&quot;initialSize&quot; value=&quot;$&#123;jdbc.initialSize&#125;&quot;/&gt; &lt;/bean&gt; 在上面已经加载了jdbc.properties，所以在配置数据源的时候直接用 $&#123;属性名&#125; 就可以使用该属性。这样做的好处是，在多处调用 jdbc.properties 里的那些属性的时候，如果要该一个属性比如数据库密码，只需要修改jdbc.properties 中的 jdbc.password 的值就行了。 3.配置Mybatis工厂123456784&lt;!-- 配置MyBatis工厂，同时指定数据源，并与MyBatis完美整合 --&gt; &lt;bean id=&quot;sqlSessionFactory&quot; class=&quot;org.mybatis.spring.SqlSessionFactoryBean&quot;&gt; &lt;!--指定数据源--&gt; &lt;property name=&quot;dataSource&quot; ref=&quot;dSource&quot;/&gt; &lt;!-- configLocation的属性值为MyBatis的核心配置文件 --&gt; &lt;property name=&quot;configLocation&quot; value=&quot;classpath:mybatis-config.xml&quot;/&gt; &lt;/bean&gt; 注意指定数据源的 &lt;property&gt; 标签中的 ref 属性，要和数据源的 id 对应 在第二个 &lt;property&gt; 中指定和启动了Mybatis的配置文件 4.配置数据映射接口数据映射接口，也就是dao，通过Mybatis配置文件映射到数据库操作文件 12345&lt;bean class=&quot;org.mybatis.spring.mapper.MapperScannerConfigurer&quot;&gt; &lt;!-- mybatis-spring组件的扫描器 ，必须写全dao的包名，且只能扫描一个dao包 --&gt; &lt;property name=&quot;basePackage&quot; value=&quot;dao&quot;/&gt; &lt;property name=&quot;sqlSessionFactoryBeanName&quot; value=&quot;sqlSessionFactory&quot;/&gt;&lt;/bean&gt; 配置以后，Spring会自动扫描MyBatis的接口并装配（Spring将指定包中所有被@Mapper注解标注的接口自动装配为MyBatis的映射接口） 在Eclipse中的进行项目的话要写全dao 的包名，比如 com.github.java.dao 这样，而在IDEA中一般会配置好项目的source root 根目录 和 resource root 资源目录，所以写dao包名就好。 例如我的目录结构，我设置了java为source root 根目录，所以不用写全包名 5.添加事务支持12345&lt;bean id=&quot;txManager&quot; class=&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;&gt;4&lt;property name=&quot;dataSource&quot; ref=&quot;dSource&quot; /&gt;&lt;/bean&gt;&lt;!-- 开启事务注解 --&gt;&lt;tx:annotation-driven transaction-manager=&quot;txManager&quot; /&gt; 事务支持有很多种方法，这种是基于@Transactional注解的事务管理。 还有一种是声明式事务管理 6.扫描service包1&lt;context:component-scan base-package=&quot;service&quot;/&gt; 完整文件123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:context=&quot;http://www.springframework.org/schema/context&quot; xmlns:tx=&quot;http://www.springframework.org/schema/tx&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx.xsd&quot;&gt;4 &lt;!--=================== 加载jdbc.properties ===================--&gt;4&lt;context:property-placeholder location=&quot;classpath:jdbc.properties&quot;/&gt; &lt;!--======================== 配置数据源 ========================--&gt; &lt;bean id=&quot;dSource&quot; class=&quot;org.apache.commons.dbcp2.BasicDataSource&quot;&gt; &lt;property name=&quot;driverClassName&quot; value=&quot;$&#123;jdbc.driver&#125;&quot;/&gt; &lt;property name=&quot;url&quot; value=&quot;$&#123;jdbc.url&#125;&quot;/&gt; &lt;property name=&quot;username&quot; value=&quot;$&#123;jdbc.username&#125;&quot;/&gt; &lt;property name=&quot;password&quot; value=&quot;$&#123;jdbc.password&#125;&quot;/&gt; &lt;!-- 最大连接数 --&gt; &lt;property name=&quot;maxTotal&quot; value=&quot;$&#123;jdbc.maxTotal&#125;&quot;/&gt; &lt;!-- 最大空闲连接数 --&gt; &lt;property name=&quot;maxIdle&quot; value=&quot;$&#123;jdbc.maxIdle&#125;&quot;/&gt; &lt;!-- 初始化连接数 --&gt; &lt;property name=&quot;initialSize&quot; value=&quot;$&#123;jdbc.initialSize&#125;&quot;/&gt; &lt;/bean&gt; &lt;!--======================== 配置MyBatis工厂 ========================--&gt;4&lt;!-- 配置MyBatis工厂，同时指定数据源，并与MyBatis完美整合 --&gt;4&lt;bean id=&quot;sqlSessionFactory&quot; class=&quot;org.mybatis.spring.SqlSessionFactoryBean&quot;&gt;44&lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot; /&gt;44&lt;!-- configLocation的属性值为MyBatis的核心配置文件 --&gt;44&lt;property name=&quot;configLocation&quot; value=&quot;classpath:com/mybatis/mybatis-config.xml&quot; /&gt;4&lt;/bean&gt; &lt;!--======================== Mapper代理 ========================--&gt; 4&lt;!--Mapper代理开发，使用Spring自动扫描MyBatis的接口并装配（Spring将指定包中所有被@Mapper注解标注的接口自动装配为MyBatis的映射接口） --&gt;4&lt;bean class=&quot;org.mybatis.spring.mapper.MapperScannerConfigurer&quot;&gt;44&lt;!-- mybatis-spring组件的扫描器 ，必须写全dao的包名，且只能扫描一个dao包 --&gt;44&lt;property name=&quot;basePackage&quot; value=&quot;com.dao&quot; /&gt;44&lt;property name=&quot;sqlSessionFactoryBeanName&quot; value=&quot;sqlSessionFactory&quot; /&gt;4&lt;/bean&gt; 4&lt;!--======================== 扫描Service包 ========================--&gt; 4&lt;!-- dao包在mybatis-spring组件中已经扫描，这里不再需要扫描 --&gt;4&lt;context:component-scan base-package=&quot;com.service&quot; /&gt; &lt;!--======================== 配置事务支持 ========================--&gt; 4&lt;!-- 添加事务支持 --&gt;4&lt;bean id=&quot;txManager&quot; class=&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;&gt;44&lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot; /&gt;4&lt;/bean&gt;4&lt;!-- 开启事务注解 --&gt;4&lt;tx:annotation-driven transaction-manager=&quot;txManager&quot; /&gt;&lt;/beans&gt; SpringMVC-servlet.xml123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:context=&quot;http://www.springframework.org/schema/context&quot; xmlns:mvc=&quot;http://www.springframework.org/schema/mvc&quot; xmlns:p=&quot;http://www.springframework.org/schema/p&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/mvc http://www.springframework.org/schema/mvc/spring-mvc.xsd&quot;&gt; &lt;context:component-scan base-package=&quot;controller&quot;/&gt; &lt;context:component-scan base-package=&quot;converter&quot;/&gt; &lt;context:component-scan base-package=&quot;formatter&quot;/&gt; &lt;context:component-scan base-package=&quot;utils&quot;/&gt; &lt;context:component-scan base-package=&quot;po&quot;/&gt; &lt;mvc:annotation-driven/&gt; &lt;mvc:resources location=&quot;/css/&quot; mapping=&quot;/css/**&quot;/&gt; &lt;mvc:resources location=&quot;/html/&quot; mapping=&quot;/html/**&quot;/&gt; &lt;mvc:resources location=&quot;/images/&quot; mapping=&quot;/images/**&quot;/&gt; &lt;!--==================== 配置视图解析器 ====================--&gt; &lt;bean class=&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot; id=&quot;internalResourceViewResolver&quot;&gt; &lt;property name=&quot;prefix&quot; value=&quot;/WEB-INF/jsp/&quot;/&gt; &lt;property name=&quot;suffix&quot; value=&quot;.jsp&quot;/&gt; &lt;/bean&gt; &lt;!--==================== 注册类型转换器 ====================--&gt; &lt;bean id=&quot;conversionService&quot; class=&quot;org.springframework.context.support.ConversionServiceFactoryBean&quot;&gt; &lt;property name=&quot;converters&quot;&gt; &lt;list&gt; &lt;bean class=&quot;converter.GoodsConverter&quot;/&gt; &lt;/list&gt; &lt;/property&gt; &lt;/bean&gt; &lt;!--启动类型转换器--&gt; &lt;mvc:annotation-driven conversion-service=&quot;conversionService&quot;/&gt; &lt;!--==================== 注册格式化转换器 ====================--&gt; &lt;bean id=&quot;formattingConversionService&quot; class=&quot;org.springframework.format.support.FormattingConversionServiceFactoryBean&quot;&gt; &lt;property name=&quot;formatters&quot;&gt; &lt;set&gt; &lt;bean class=&quot;formatter.GoodsFormatter&quot;/&gt; &lt;/set&gt; &lt;/property&gt; &lt;/bean&gt; &lt;!--启动格式化转换器--&gt; &lt;mvc:annotation-driven conversion-service=&quot;formattingConversionService&quot;/&gt; &lt;!--==================== 配置校验器 ====================--&gt; &lt;!--配置错误消息资源--&gt; &lt;bean id=&quot;msgSource&quot; class=&quot;org.springframework.context.support.ReloadableResourceBundleMessageSource&quot;&gt; &lt;property name=&quot;basenames&quot; value=&quot;errorMessages&quot;/&gt; &lt;!--资源文件编码格式--&gt; &lt;property name=&quot;fileEncodings&quot; value=&quot;utf-8&quot;/&gt; &lt;!--对资源文件内容缓存时间，单位秒--&gt; &lt;property name=&quot;cacheSeconds&quot; value=&quot;120&quot;/&gt; &lt;/bean&gt; &lt;!--注册校验器--&gt; &lt;bean id=&quot;validator&quot; class=&quot;org.springframework.validation.beanvalidation.LocalValidatorFactoryBean&quot;&gt; &lt;!--hibernate校验器--&gt; &lt;property name=&quot;providerClass&quot; value=&quot;org.hibernate.validator.HibernateValidator&quot;/&gt; &lt;!--指定校验使用的资源为将，在文件中配置校验错误信息--&gt; &lt;property name=&quot;validationMessageSource&quot; ref=&quot;msgSource&quot;/&gt; &lt;/bean&gt; &lt;!--启动spring的valid校验功能--&gt; &lt;mvc:annotation-driven conversion-service=&quot;conversionService&quot; validator=&quot;validator&quot;/&gt; &lt;!--==================== 配置拦截器 ====================--&gt; &lt;mvc:interceptors&gt; &lt;!--&lt;bean class=&quot;interceptor.AllInterceptor&quot;/&gt;--&gt; &lt;mvc:interceptor&gt; &lt;mvc:mapping path=&quot;/**&quot;/&gt; &lt;mvc:exclude-mapping path=&quot;/&quot;/&gt; &lt;bean class=&quot;interceptor.Interceptor1&quot;/&gt; &lt;/mvc:interceptor&gt; &lt;mvc:interceptor&gt; &lt;mvc:mapping path=&quot;/five&quot;/&gt; &lt;bean class=&quot;interceptor.Interceptor2&quot;/&gt; &lt;/mvc:interceptor&gt; &lt;/mvc:interceptors&gt; &lt;!--==================== 配置文件上传和下载 ====================--&gt; &lt;bean id=&quot;multipartResolver&quot; class=&quot;org.springframework.web.multipart.commons.CommonsMultipartResolver&quot; p:defaultEncoding=&quot;UTF-8&quot; p:maxUploadSize=&quot;5400000&quot; p:uploadTempDir=&quot;fileUpload/temp&quot;&gt; &lt;/bean&gt; &lt;!--==================== 配置异常处理 ====================--&gt; &lt;!--使用@ExceptionHandler注解时注释掉，因为@ExceptionHandler注解方法不能有任何配置--&gt; &lt;!--统一异常处理，托管MyExceptionHandler--&gt; &lt;!--&lt;bean class=&quot;exception.MyExceptionHandler&quot;/&gt;--&gt; &lt;!--统一异常处理，使用SimpleMappingExceptionResolver异常处理器处理异常--&gt; &lt;!--&lt;bean class=&quot;org.springframework.web.servlet.handler.SimpleMappingExceptionResolver&quot;&gt;--&gt; &lt;!--&amp;lt;!&amp;ndash;定义默认的异常处理页面，当该异常类型注册时使用&amp;ndash;&amp;gt;--&gt; &lt;!--&lt;property name=&quot;defaultErrorView&quot; value=&quot;error&quot;/&gt;--&gt; &lt;!--&amp;lt;!&amp;ndash;定义异常处理页面用来获取异常信息的变量名，默认名为exception&amp;ndash;&amp;gt;--&gt; &lt;!--&lt;property name=&quot;exceptionAttribute&quot; value=&quot;ex&quot;/&gt;--&gt; &lt;!--&amp;lt;!&amp;ndash;定义需要特殊处理的异常，用类名活完全路径名为key，异常页名为值&amp;ndash;&amp;gt;--&gt; &lt;!--&lt;property name=&quot;exceptionMappings&quot;&gt;--&gt; &lt;!--&lt;props&gt;--&gt; &lt;!--&lt;prop key=&quot;exception.MyException&quot;&gt;my-error&lt;/prop&gt;--&gt; &lt;!--&lt;prop key=&quot;java.sql.SQLException&quot;&gt;sql-error&lt;/prop&gt;--&gt; &lt;!--&amp;lt;!&amp;ndash;这里还可以继续扩展对不同异常类型的处理&amp;ndash;&amp;gt;--&gt; &lt;!--&lt;/props&gt;--&gt; &lt;!--&lt;/property&gt;--&gt; &lt;!--&lt;/bean&gt;--&gt;&lt;/beans&gt;","categories":[{"name":"Java","slug":"Java","permalink":"https://www.boii.xyz/categories/Java/"},{"name":"SSM","slug":"SSM","permalink":"https://www.boii.xyz/categories/SSM/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://www.boii.xyz/tags/Java/"},{"name":"SSM","slug":"SSM","permalink":"https://www.boii.xyz/tags/SSM/"},{"name":"SSM配置","slug":"SSM配置","permalink":"https://www.boii.xyz/tags/SSM%E9%85%8D%E7%BD%AE/"}]},{"title":"SSM-8-Spring事务管理","slug":"SSM-8-Spring事务管理","date":"2019-07-13T09:04:13.000Z","updated":"2021-05-23T04:40:25.880Z","comments":true,"path":"2019/07/13/SSM-8-Spring事务管理/","link":"","permalink":"https://www.boii.xyz/2019/07/13/SSM-8-Spring%E4%BA%8B%E5%8A%A1%E7%AE%A1%E7%90%86/","excerpt":"","text":"前言事务：也就是一个用户操作中，需要包含哪些具体操作。这些操作集合在一起，就是事务。这些操作必须是具体的，必要的，不可分割的。要么全部完成，要么全部失败。 比如你给你朋友转账1000块的操作，分成几个步骤就是： 自己的账户扣1000块钱 对方的账户加1000块钱 把这笔转账行为记录在服务器中 这三个步骤就具备了原子性，一致性，隔离性，持久性。 原子性：要么全部完成，有一个完成不了就全部回滚。比如自己的账户扣钱成功，但是对方的账户加钱失败，那么就回滚，自己的账户的钱恢复到转账钱的余额。 一致性： 一致性代表了底层数据存储的完整性。例如你转账给朋友1000块，那你的账户要扣1000块，你朋友的账户得增加1000块，如果只增加了500块，那就是不一致。 隔离性：隔离性意味着事务必须在不干扰其他进程或事务的前提下独立执行。也就是，在事务或工作单元执行完毕之前，其所访问的数据不能受系统其他部分的影响。比如你在给朋友转账的时候，别人给你转账是转不了的。因为要确保你的账户的隔离。 持久性：持久性表示在某个事务的执行过程中，对数据所作的所有改动都必须在事务成功结束前保存至某种物理存储设备。转账后要把这次转账记录在服务器里，不管过了多久都可以查。 事务的三个主要方法：开启事务 BeginTranscation()，提交 commit() ，回滚 rollback()","categories":[{"name":"Java","slug":"Java","permalink":"https://www.boii.xyz/categories/Java/"},{"name":"SSM","slug":"SSM","permalink":"https://www.boii.xyz/categories/SSM/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://www.boii.xyz/tags/Java/"},{"name":"SSM","slug":"SSM","permalink":"https://www.boii.xyz/tags/SSM/"},{"name":"事务管理","slug":"事务管理","permalink":"https://www.boii.xyz/tags/%E4%BA%8B%E5%8A%A1%E7%AE%A1%E7%90%86/"}]},{"title":"SSM-7-统一异常处理","slug":"SSM-7-统一异常处理","date":"2019-07-11T12:55:10.000Z","updated":"2021-05-23T04:40:18.147Z","comments":true,"path":"2019/07/11/SSM-7-统一异常处理/","link":"","permalink":"https://www.boii.xyz/2019/07/11/SSM-7-%E7%BB%9F%E4%B8%80%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/","excerpt":"","text":"摘要程序运行过程中总会遇到一些可预知的，不可预知的异常。如果不对这些异常进行捕捉和处理，就会导致程序崩溃、停止运行、闪退等诸多令人体验极差的现象。如果对这些异常一个一个单独处理，则代码显得很臃肿，耦合度高（独立性差），所以要用统一异常处理对所有的代码进行异常处理 SpringMVC处理异常有三种方式： 简单异常处理SimpleMappingExceptionResolver 实现HandlerExceptionResolver接口自定义异常 使用@ExceptionHandler注解实现异常处理 在程序中可能出现异常的地方进行捕捉，程序发生异常被捕捉到后，就会调用我们编写的统一异常处理类进行处理 效果图 使用步骤由于我们太完美了程序暂时没有什么异常，所以我们得自己制造点异常。 我们先做一个列表，把控制层，业务层，模型层的各种异常集中链接在这里。 1234567891011121314151617181920&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; %&gt;&lt;%@ page isELIgnored=&quot;false&quot; %&gt;&lt;% String path = request.getContextPath(); String basePath = request.getScheme() + &quot;://&quot; + request.getServerName() + &quot;:&quot; + request.getServerPort() + path + &quot;/&quot;;%&gt;&lt;html&gt;&lt;head&gt; &lt;base href=&quot;&lt;%=basePath%&gt;&quot;/&gt; &lt;title&gt;Exception&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;div id=&quot;body&quot;&gt; &lt;h3&gt;&lt;a href=&quot;db&quot;&gt;控制器中数据库异常&lt;/a&gt;&lt;/h3&gt; &lt;h3&gt;&lt;a href=&quot;my&quot;&gt;控制器中自定义异常&lt;/a&gt;&lt;/h3&gt; &lt;h3&gt;&lt;a href=&quot;no&quot;&gt;控制器中未知异常&lt;/a&gt;&lt;/h3&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 如下图： 这些链接点击后跳转到控制层里进行处理。而程序不会无端端的就异常，所以我们得先在控制器里弄点异常：自己主动抛出一个异常 。 先主动搞个异常1throw new SQLException(&quot;控制器中数据库异常&quot;); 这句话就是主动抛出一个异常。 整体的代码如下： 123456789101112131415@Controllerpublic class ExceptionController&#123; @RequestMapping(&quot;/db&quot;) public void db() throws Exception &#123; throw new SQLException(&quot;控制器中数据库异常&quot;); &#125; @RequestMapping(&quot;/my&quot;) public void my() throws Exception &#123; throw new MyException(&quot;控制器中自定义异常&quot;); &#125; @RequestMapping(&quot;/no&quot;) public void no() throws Exception &#123; throw new Exception(&quot;控制器中未知异常&quot;); &#125;&#125; 好了制造好了异常，现在开始来处理。一共有三种方法 实现HandlerExceptionResolver接口1.编写一个类实现HandlerExceptionResolver接口异常抛出后，就会被捕捉，捕捉后就要进行处理啦。我们编写一个类，这个类要实现 HandlerExceptionResolver接口里的 resolveException() 方法。 123456789101112131415161718192021222324252627282930public class MyExceptionHandler implements HandlerExceptionResolver &#123; /** * 重写接口方法 * * @param arg0 servlet请求 * @param arg1 servlet响应 * @param obj 目标对象 * @param ex 异常 * @return 返回相应的视图 */ @Override public ModelAndView resolveException(HttpServletRequest arg0, HttpServletResponse arg1, Object obj, Exception ex) &#123; Map&lt;String, Object&gt; model = new HashMap&lt;&gt;(); model.put(&quot;ex&quot;, ex); // 根据不同错误转向不同页面（统一处理），即异常与view的对应关系 // 如果异常属于自定义异常类型 if (ex instanceof MyException) &#123; return new ModelAndView(&quot;exception/my-error&quot;, model); // 如果异常属于数据库异常类型 &#125; else if (ex instanceof SQLException) &#123; return new ModelAndView(&quot;exception/sql-error&quot;, model); // 如果异常属于未知类型 &#125; else &#123; return new ModelAndView(&quot;exception/error&quot;, model); &#125; &#125;&#125; 控制层里制造了三种不同的异常 ，这些异常被捕捉后会被送到这里进行处理。这里主要就是根据异常的不同类型返回不同的视图页面。 3. 在SpringMVC配置文件中配置1&lt;bean class=&quot;exception.MyExceptionHandler&quot;/&gt; 使用@ExceptionHandler注解实现异常处理这种是最容易的一种方式，集成简单，扩展性好。 1.创建一个BaseController类创建一个抽象类，并在类中使用@ExceptionHandler注解声明异常处理方法 12345678910111213141516171819public abstract class BaseController &#123; /** * 异常处理方法 * @param request Servlet请求 * @param ex 异常实例 * @return 返回一个视图页面的名称 */ @ExceptionHandler public String exception(HttpServletRequest request, Exception ex)&#123; request.setAttribute(&quot;ex&quot;, ex); if (ex instanceof SQLException) &#123; return &quot;404&quot;; &#125; else if ( ex instanceof MyException) &#123; return &quot;exception/my-error&quot;; &#125; else &#123; return &quot;exception/error&quot;; &#125; &#125;&#125; 2.让其他控制器继承这个类让其他需要处理异常的类继承这个BaseController类 123public class ExceptionController extends BaseController&#123; ......&#125; 3. 注意使用这种方法是配置文件中不要配置任何其他异常处理方法。注意使用这种方法是配置文件中不要配置任何其他异常处理方法！！！ 注意使用这种方法是配置文件中不要配置任何其他异常处理方法！！！ 注意使用这种方法是配置文件中不要配置任何其他异常处理方法！！！ 简单异常处理SimpleMappingExceptionResolver1234567891011121314&lt;bean class=&quot;org.springframework.web.servlet.handler.SimpleMappingExceptionResolver&quot;&gt; &lt;!--定义默认的异常处理页面，当该异常类型注册时使用--&gt; &lt;property name=&quot;defaultErrorView&quot; value=&quot;error&quot;/&gt; &lt;!--定义异常处理页面用来获取异常信息的变量名，默认名为exception--&gt; &lt;property name=&quot;exceptionAttribute&quot; value=&quot;ex&quot;/&gt; &lt;!--定义需要特殊处理的异常，用类名活完全路径名为key，异常页名为值--&gt; &lt;property name=&quot;exceptionMappings&quot;&gt; &lt;props&gt; &lt;prop key=&quot;exception.MyException&quot;&gt;my-error&lt;/prop&gt; &lt;prop key=&quot;java.sql.SQLException&quot;&gt;sql-error&lt;/prop&gt; &lt;!--这里还可以继续扩展对不同异常类型的处理--&gt; &lt;/props&gt; &lt;/property&gt; &lt;/bean&gt; 在SpringMVC配置文件中配置 SimpleMappingExceptionResolver异常处理器 ，即可实现对异常的统一处理。 主要分默认异常处理页面，获取异常信息的变量名，还有一些需要特殊处理的异常。 总结最简单的使用@ExceptionHandler注解的方法，虽然有集成简单，可扩展性好等优点，但是该方法对已有代码存在入侵性，需要修改已有代码，是相关类继承于BaseController。 而第一种写一个HandlerExceptionResolver的实现类的方法则比较温和，不会对代码进行入侵。记得要在SpringMVC配置文件中托管这个实现类：&lt;bean class=&quot;exception.MyExceptionHandler&quot;/&gt; 最后一种其实最方便啦，配置好就OK，不用增加什么文件。","categories":[{"name":"Java","slug":"Java","permalink":"https://www.boii.xyz/categories/Java/"},{"name":"SSM","slug":"SSM","permalink":"https://www.boii.xyz/categories/SSM/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://www.boii.xyz/tags/Java/"},{"name":"SSM","slug":"SSM","permalink":"https://www.boii.xyz/tags/SSM/"},{"name":"统一异常处理","slug":"统一异常处理","permalink":"https://www.boii.xyz/tags/%E7%BB%9F%E4%B8%80%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/"}]},{"title":"SSM-6-上传和下载","slug":"SSM-6-上传和下载","date":"2019-07-09T17:04:18.000Z","updated":"2021-05-23T04:40:08.867Z","comments":true,"path":"2019/07/10/SSM-6-上传和下载/","link":"","permalink":"https://www.boii.xyz/2019/07/10/SSM-6-%E4%B8%8A%E4%BC%A0%E5%92%8C%E4%B8%8B%E8%BD%BD/","excerpt":"","text":"摘要文件上传和下载是web经常要面对的问题。 上传的方式有多种，包括： 使用文件流手工编程上传 基于commons-fileupload组件的文件上传 基于Servlet3及以上版本文件上传 下载经常有两种方式： 通过超链接实现下载，但是会暴露下载文件的真实位置，并且只能下载存放在web应用所在的目录下的文件。 利用程序编码实现下载，可以增加安全访问控制，还可以从任意位置提供下载的数据，比如数据库。 效果图上传 选择文件前 选择文件后 上传文件后 下载 可以被下载的文件列表 选择文件存储位置 使用步骤导入jar包SpringMVC框架的文件上传是基于commons-fileupload组件，所以需要commons-fileupload和commons-io的jar包。 maven项目：配置pom.xml 1234567891011&lt;!--上传下载--&gt;&lt;dependency&gt; &lt;groupId&gt;commons-fileupload&lt;/groupId&gt; &lt;artifactId&gt;commons-fileupload&lt;/artifactId&gt; &lt;version&gt;1.4&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;commons-io&lt;/groupId&gt; &lt;artifactId&gt;commons-io&lt;/artifactId&gt; &lt;version&gt;2.6&lt;/version&gt;&lt;/dependency&gt; 非maven项目：将下载好的 commons-fileupload 和 commons-io 的jar放到 webapps\\WEB-INF\\lib 目录下 单文件上传1. 编写领域模型文件上传后保存在服务器里是一个对象，这个对象我们得定义它的属性。文件上传的时候的文件描述（备注），文件的创建时间等等，最重要的文件本身的类型是 MultipartFile 1234567891011121314151617181920public class FileDomain &#123; private String description; private MultipartFile myFile; public String getDescription() &#123; return description; &#125; public void setDescription(String description) &#123; this.description = description; &#125; public MultipartFile getMyFile() &#123; return myFile; &#125; public void setMyFile(MultipartFile myFile) &#123; this.myFile = myFile; &#125;&#125; 2. 编写一个提交页面12345678910111213141516171819&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; %&gt;&lt;%@ page isELIgnored=&quot;false&quot; %&gt;&lt;% String path = request.getContextPath(); String basePath = request.getScheme() + &quot;://&quot; + request.getServerName() + &quot;:&quot; + request.getServerPort() + path + &quot;/&quot;;%&gt;&lt;html&gt;&lt;head&gt; &lt;base href=&quot;&lt;%=basePath%&gt;&quot;/&gt; &lt;title&gt;onFile&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;form action=&quot;six/oneFileUpLoad&quot; method=&quot;post&quot; enctype=&quot;multipart/form-data&quot;&gt; 选择文件：&lt;input type=&quot;file&quot; name=&quot;myFile&quot;/&gt;&lt;br&gt; 文件描述：&lt;input type=&quot;text&quot; name=&quot;description&quot;/&gt;&lt;br&gt; &lt;input type=&quot;submit&quot; value=&quot;提交&quot;&gt;&lt;/form&gt;&lt;/body&gt;&lt;/html&gt; input标签的type属性为file时，就变成选择文件了。 **要注意的是：表单form的enctype属性应设置为 multipart/form-data**。然后就可以把表单提交到控制器了： action=&quot;six/oneFileUpload&quot; 3. 编写控制器123456789101112131415161718192021222324252627@Controller@RequestMapping(&quot;/six&quot;)public class SixController &#123; private static final Log logger = LogFactory.getLog(SixController.class); @RequestMapping(&quot;/oneFileUpLoad&quot;) public String oneFileUpload(@ModelAttribute FileDomain fileDomain, HttpServletRequest request) &#123; // 获取存储路径 String realpath = request.getServletContext().getRealPath(&quot;fileUpload&quot;); // 获取文件名 String fileName = fileDomain.getMyFile().getOriginalFilename(); // 如果文件名不为null &amp;&amp; 目标文件夹不存在，则新建文件夹 assert fileName != null; File targetFile = new File(realpath, fileName); if (!targetFile.exists()) &#123; targetFile.mkdirs(); &#125; // 开始上传文件 try &#123; fileDomain.getMyFile().transferTo(targetFile); logger.info(&quot;成功&quot;); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; return &quot;6/showOne&quot;; &#125;&#125; 表单提交到控制器后就由控制器进行处理。 先获取realPath：文件保存到服务器的哪个地方，也叫存储路径。文件上传后都是存在服务器的，所以这里说的路径是指在服务器上的存储路径。 然后获取文件的文件名 如果realPath这个目录不存在，就创建目录 然后就开始上传文件。上传的关键方法就是 transferTo() 这里上传成功就会跳转到 /WEB-INF/jsp/6/showOne 页面 &gt;_ 4. 编写结果页面也就是上面要跳转的 /WEB-INF/jsp/6/showOne 页面 12345678910111213141516&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; %&gt;&lt;%@ page isELIgnored=&quot;false&quot; %&gt;&lt;% String path = request.getContextPath(); String basePath = request.getScheme() + &quot;://&quot; + request.getServerName() + &quot;:&quot; + request.getServerPort() + path + &quot;/&quot;;%&gt;&lt;html&gt;&lt;head&gt; &lt;base href=&quot;&lt;%=basePath%&gt;&quot;/&gt; &lt;title&gt;ShowOne&lt;/title&gt;&lt;/head&gt;&lt;body&gt;$&#123;fileDomain.description&#125;&lt;br&gt;$&#123;fileDomain.myFile.originalFilename&#125;&lt;/body&gt;&lt;/html&gt; 多文件上传多文件上传和单文件的上传过程是相同的，但是他们的模型是不同的。多文件上传的模型是列表list 1.领域模型1234567891011121314151617181920public class MultiFileDomain &#123; private List&lt;String&gt; description; private List&lt;MultipartFile&gt; myFile; public List&lt;String&gt; getDescription() &#123; return description; &#125; public void setDescription(List&lt;String&gt; description) &#123; this.description = description; &#125; public List&lt;MultipartFile&gt; getMyFile() &#123; return myFile; &#125; public void setMyFile(List&lt;MultipartFile&gt; myFile) &#123; this.myFile = myFile; &#125;&#125; 跟单文件上传的类型差不多，不同在于用list去装载。 2.编写提交页面1234567891011121314151617181920212223&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; %&gt;&lt;%@ page isELIgnored=&quot;false&quot; %&gt;&lt;% String path = request.getContextPath(); String basePath = request.getScheme() + &quot;://&quot; + request.getServerName() + &quot;:&quot; + request.getServerPort() + path + &quot;/&quot;;%&gt;&lt;html&gt;&lt;head&gt; &lt;base href=&quot;&lt;%=basePath%&gt;&quot;/&gt; &lt;title&gt;MultiFile&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;form action=&quot;six/mutliFile&quot; method=&quot;post&quot; enctype=&quot;multipart/form-data&quot;&gt; 选择文件1：&lt;input type=&quot;file&quot; name=&quot;myFile&quot;/&gt; &lt;br&gt; 文件描述1：&lt;input type=&quot;text&quot; name=&quot;description&quot;/&gt;&lt;br&gt; 选择文件2：&lt;input type=&quot;file&quot; name=&quot;myFile&quot;/&gt; &lt;br&gt; 文件描述2：&lt;input type=&quot;text&quot; name=&quot;description&quot;/&gt;&lt;br&gt; 选择文件3：&lt;input type=&quot;file&quot; name=&quot;myFile&quot;/&gt; &lt;br&gt; 文件描述3：&lt;input type=&quot;text&quot; name=&quot;description&quot;/&gt;&lt;br&gt; &lt;input type=&quot;submit&quot; value=&quot;提交&quot;/&gt;&lt;/form&gt;&lt;/body&gt;&lt;/html&gt; 同样是enctype属性要设置成 multipart/form-data ，通过action属性提交到控制器 3.控制器12345678910111213141516171819202122232425262728293031@Controller@RequestMapping(&quot;/six&quot;)public class SixController &#123; private static final Log logger = LogFactory.getLog(SixController.class); 4@RequestMapping(&quot;/mutliFile&quot;) public String multiFile(@ModelAttribute MultiFileDomain multiFileDomain, HttpServletRequest request) &#123; // 获取真实路径 String realpath = request.getServletContext().getRealPath(&quot;fileUpload&quot;); // 如果目标文件夹不存在则新建文件夹 File targetDir = new File(realpath); if (!targetDir.exists()) &#123; targetDir.mkdirs(); &#125; // 将文件放置到list中 List&lt;MultipartFile&gt; files = multiFileDomain.getMyFile(); // 将list中的文件逐个上传 for (MultipartFile file : files) &#123; String fileName = file.getOriginalFilename(); assert fileName != null; File targetFile = new File(realpath, fileName); try &#123; file.transferTo(targetFile); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; logger.info(&quot;成功&quot;); return &quot;6/showMulti&quot;; &#125;&#125; 控制器里前部分也是相同的，获取存储路径，获取文件名，检查目标目录是否存在。 区别在于：将传过来的文件放在一个新的List中 1List&lt;MultipartFile&gt; files = multiFileDomain.getMyFile(); 然后循环遍历整个List，将文件一个一个上传，然后返回 /WEB-INF/jsp/6/showMulti 页面 下载利用程序实现下载需要设置两个报头： 设置Content-Type的值为：application/x-msdownload，因为web服务器需要告诉浏览器所输出内容的类型不是普通文件文件或是HTML，而是一个要保存到本地的下载文件。 设置Content-Disposition的值为：attachment，后面还可以指定filename参数。filename参数就是那个默认保存文件名。如下图红框所示： 12response.setHeader(&quot;Content-Type&quot;, &quot;application/x-msdownload&quot;);response.setHeader(&quot;Content-Disposition&quot;, &quot;attachment;filename=&quot; + toUTF8(filename)); 1. 编写跳转页面12345678910111213141516171819202122&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; %&gt;&lt;%@ page isELIgnored=&quot;false&quot; %&gt;&lt;% String path = request.getContextPath(); String basePath = request.getScheme() + &quot;://&quot; + request.getServerName() + &quot;:&quot; + request.getServerPort() + path + &quot;/&quot;;%&gt;&lt;html&gt;&lt;head&gt; &lt;base href=&quot;&lt;%=basePath%&gt;&quot;/&gt; &lt;title&gt;MultiFile&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;a href=&quot;six/showDownFiles&quot;&gt;文件下载&lt;/a&gt; &lt;/form&gt;&lt;/body&gt;&lt;/html&gt; 整个页面只有一个a标签的链接。点击之后会跳转到 showDownFiles 控制器 2.编写列表控制器12345678910111213141516171819202122232425@Controller@RequestMapping(&quot;/six&quot;)public class SixController &#123; private static final Log logger = LogFactory.getLog(SixController.class); 4@RequestMapping(&quot;/showDownFiles&quot;) public String showDown(HttpServletRequest request, Model model) &#123; // 获取存储目录 String realpath = request.getServletContext().getRealPath(&quot;fileUpload&quot;); // 实例化为一个File对象 File dir = new File(realpath); // 将目录下的文件放到File数组中 File[] files = dir.listFiles(); // 创建一个数组列表，用于返回到前台页面 ArrayList&lt;String&gt; fileName = new ArrayList&lt;&gt;(); assert files != null; // 逐一将目录下的文件添加到数组列表中 for (File file : files) &#123; fileName.add(file.getName()); &#125; // 将数组列表返回给前台页面 model.addAttribute(&quot;files&quot;, fileName); return &quot;6/showDownFiles&quot;; &#125;&#125; 列出控制器还是比较简单的： 获取存储位置 将路径实例化成一个File对象 将存储位置里的文件放到File数组中 创建一个数组列表，然后将文件逐个添加到数组列表中 将数组列表返回给前台页面 3. 编写下载列表展示页面1234567891011121314151617181920212223&lt;%@ taglib prefix=&quot;c&quot; uri=&quot;http://java.sun.com/jsp/jstl/core&quot; %&gt;&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; %&gt;&lt;%@ page isELIgnored=&quot;false&quot; %&gt;&lt;% String path = request.getContextPath(); String basePath = request.getScheme() + &quot;://&quot; + request.getServerName() + &quot;:&quot; + request.getServerPort() + path + &quot;/&quot;;%&gt;&lt;html&gt;&lt;head&gt; &lt;base href=&quot;&lt;%=basePath%&gt;&quot;/&gt; &lt;title&gt;ShowDownFiles&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;table&gt; &lt;tr&gt;&lt;td&gt;被下载文件名&lt;/td&gt;&lt;/tr&gt; &lt;c:forEach items=&quot;$&#123;files&#125;&quot; var=&quot;filename&quot;&gt;&lt;%--@elvariable id=&quot;filesname&quot; type=&quot;po.six.FileDomain&quot;--%&gt; &lt;tr&gt; &lt;td&gt;&lt;a href=&quot;six/down?filename=$&#123;filename&#125;&quot;&gt;$&#123;filename&#125;&lt;/a&gt;&lt;/td&gt; &lt;/tr&gt; &lt;/c:forEach&gt;&lt;/table&gt;&lt;/body&gt;&lt;/html&gt; 这里用了表单标签库中的 &lt;c:forEach&gt; 标签，将存储目录中的文件列出来，列出来的每一项都是一个超链接，链接指向 six/down 这个下载控制器。效果如下： 4.编写下载控制器1234567891011121314151617181920212223242526272829303132@Controller@RequestMapping(&quot;/six&quot;)public class SixController &#123; private static final Log logger = LogFactory.getLog(SixController.class); 4@RequestMapping(&quot;/down&quot;) public String down(@RequestParam String filename, HttpServletRequest request, HttpServletResponse response) &#123; try &#123; // 获取存储位置 String savePath = request.getServletContext().getRealPath(&quot;fileUpload&quot;); // 设置报头 response.setHeader(&quot;Content-Type&quot;, &quot;application/x-msdownload&quot;); response.setHeader(&quot;Content-Disposition&quot;, &quot;attachment;filename=&quot; + toUTF8(filename)); // 读取服务器上的文件并写入到输出对象中，也就是下载 FileInputStream in = new FileInputStream(savePath + &quot;\\\\&quot; + filename); ServletOutputStream out = response.getOutputStream(); out.flush(); int aRead; byte[] b = new byte[1024]; while ((aRead = in.read(b)) != -1) &#123; out.write(b, 0, aRead); &#125; out.flush(); out.close(); in.close(); &#125; catch (Throwable e) &#123; e.printStackTrace(); &#125; logger.info(&quot;下载成功&quot;); return null; &#125;&#125; 下载控制器则做了几件事情： 获取存储目录 设置报头 将目标文件从输入流读取出来，转移到Servlet输出流写入进去，完成下载这个动作 因为报头的 Content-Disposition 设置为 attachment，所以下载之前浏览器会询问保存位置。 总结上传和下载是web中很重要的一项功能，需要彻底掌握。上传的方式有多种，基于commons-fileupload的文件上传还是比较容易的，关键代码就是transferTo()方法。而下载选择用编码实现是为了不暴露文件的真实位置，还有就是可以下载任意位置的文件，所以可以将文件放在数据库中，然后让下载控制器去数据库中读取下载。虽然步骤比较麻烦，但是安全，规范。","categories":[{"name":"Java","slug":"Java","permalink":"https://www.boii.xyz/categories/Java/"},{"name":"SSM","slug":"SSM","permalink":"https://www.boii.xyz/categories/SSM/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://www.boii.xyz/tags/Java/"},{"name":"SSM","slug":"SSM","permalink":"https://www.boii.xyz/tags/SSM/"},{"name":"上传下载","slug":"上传下载","permalink":"https://www.boii.xyz/tags/%E4%B8%8A%E4%BC%A0%E4%B8%8B%E8%BD%BD/"}]},{"title":"SSM-5-拦截器","slug":"SSM-5-拦截器","date":"2019-07-07T04:04:18.000Z","updated":"2021-05-23T04:40:01.843Z","comments":true,"path":"2019/07/07/SSM-5-拦截器/","link":"","permalink":"https://www.boii.xyz/2019/07/07/SSM-5-%E6%8B%A6%E6%88%AA%E5%99%A8/","excerpt":"","text":"摘要拦截器 Interceptor 主要用于在 请求到达控制器之前进行验证 ，有点类似过滤器。主要用于拦截用户请求并做出相应的处理。通常应用在权限验证，记录请求信息的日志，判断用户是否登录等功能上。 主要的实现方法有两种： 通过实现 HandlerInterceptor接口 或继承 HandlerInterceptor接口 的实现类来定义。 通过实现 WebRequestInterceptor接口 或继承WebRequestInterceptor接口 的实现类来定义。 效果图拦截器的拦截时间点在这里面分三种： 请求到达控制器之前调用，比如点击我的购物车的时候，判断用户有没有登录先 控制器调用之后，返回视图之前。 解析试图之后。比如访问了XXX的QQ空间，就在视图解析完后记录到访问记录中 &gt;_ 这里的案例只是在这些方法里打印了一些话来表示出拦截器在什么时间点做了什么 使用步骤1. 配置先在springmvc-servlet.xml中配置拦截器。 123&lt;mvc:interceptors&gt; &lt;bean class=&quot;interceptor.AllInterceptor&quot;/&gt;&lt;/mvc:interceptors&gt; 这样的配置方式默认对所有请求拦截，也就是任何请求要到达控制器之前都会经过拦截器。 这种方式的话就是拦截所有的请求，但是请求如果是到/abc这个控制器的话就例外，不拦截。 1234567&lt;mvc:interceptors&gt; &lt;mvc:interceptor&gt; &lt;mvc:mapping path=&quot;/**&quot;/&gt; &lt;mvc:exclude-mapping path=&quot;/abc&quot;/&gt; &lt;bean class=&quot;interceptor.Interceptor1&quot;/&gt; &lt;/mvc:interceptor&gt;&lt;/mvc:interceptors&gt; 这种呢就是对发送到/6这个控制器的请求，进行指定的拦截器拦截。 123456&lt;mvc:interceptors&gt; &lt;mvc:interceptor&gt; &lt;mvc:mapping path=&quot;/6&quot;/&gt; &lt;bean class=&quot;interceptor.Interceptor2&quot;/&gt; &lt;/mvc:interceptor&gt;&lt;/mvc:interceptors&gt; 2. 实现接口HandlerInterceptor接口中已经有默认的实现方法了，所以implements之后并不会提醒重写方法。 preHandle：在请求到达控制器之前进行拦截 postHandle：控制器调用之后，解析试图之前进行拦截 afterCompletion：在解析试图之后进行拦截 12345678910111213141516171819202122232425package interceptor;import org.springframework.web.servlet.HandlerInterceptor;import org.springframework.web.servlet.ModelAndView;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;public class AllInterceptor implements HandlerInterceptor &#123; @Override public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception &#123; System.out.println(&quot;preHandle，请求到达控制器之前&quot;); return true; &#125; @Override public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView) throws Exception &#123; System.out.println(&quot;postHandle,控制器调用之后，解析试图之前&quot;); &#125; @Override public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception &#123; System.out.println(&quot;afterCompletion,解析视图之后&quot;); &#125;&#125; 总结拦截器是一个比较重要的东西。使用也简单，主要是两点 编写拦截器的工作，preHandle要干嘛，postHandle要干嘛，afterCompletion要干嘛。 在springmvc配置文件里编写拦截规则，是全部都拦截用一个全局拦截器？还是某个控制器用某个拦截器？","categories":[{"name":"Java","slug":"Java","permalink":"https://www.boii.xyz/categories/Java/"},{"name":"SSM","slug":"SSM","permalink":"https://www.boii.xyz/categories/SSM/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://www.boii.xyz/tags/Java/"},{"name":"SSM","slug":"SSM","permalink":"https://www.boii.xyz/tags/SSM/"},{"name":"拦截器","slug":"拦截器","permalink":"https://www.boii.xyz/tags/%E6%8B%A6%E6%88%AA%E5%99%A8/"}]},{"title":"SSM-4-数据绑定","slug":"SSM-4-数据绑定","date":"2019-07-07T02:04:18.000Z","updated":"2021-05-23T04:39:47.410Z","comments":true,"path":"2019/07/07/SSM-4-数据绑定/","link":"","permalink":"https://www.boii.xyz/2019/07/07/SSM-4-%E6%95%B0%E6%8D%AE%E7%BB%91%E5%AE%9A/","excerpt":"","text":"摘要数据绑定是将用户参数输入值绑定到领域模型（POJO）的一种特性，在SpringMVC的Controller和View参数传递数据的过程中，所有HTTP请求参数的类型均为字符串，如果模型需要绑定的类型为double或int，则需要手动进行类型转换，而有了数据绑定后： 不需要手动转型数据了。 当表单输入验证失败时，会重新生成一个HTML表单，无需重新填写已输入字段。 效果图第一次加载的样子 验证失败后重新加载的样子，前面填过的数据依然保留着 验证成功后进入这个页面 使用步骤1. 导入jar包maven项目：配置pom.xml 12345678910&lt;dependency&gt; &lt;groupId&gt;jstl&lt;/groupId&gt; &lt;artifactId&gt;jstl&lt;/artifactId&gt; &lt;version&gt;1.2&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;taglibs&lt;/groupId&gt; &lt;artifactId&gt;standard&lt;/artifactId&gt; &lt;version&gt;1.1.2&lt;/version&gt;&lt;/dependency&gt; 非maven项目：将下载好的 taglibs 和 jstl 的jar放到 webapps\\WEB-INF\\lib 目录下 2. web.xml中配置编码过滤器12345678910111213141516&lt;filter&gt; &lt;filter-name&gt;characterEncodingFilter&lt;/filter-name&gt; &lt;filter-class&gt;org.springframework.web.filter.CharacterEncodingFilter&lt;/filter-class&gt; &lt;init-param&gt; &lt;param-name&gt;encoding&lt;/param-name&gt; &lt;param-value&gt;UTF-8&lt;/param-value&gt; &lt;/init-param&gt; &lt;init-param&gt; &lt;param-name&gt;forceEncoding&lt;/param-name&gt; &lt;param-value&gt;true&lt;/param-value&gt; &lt;/init-param&gt;&lt;/filter&gt;&lt;filter-mapping&gt; &lt;filter-name&gt;characterEncodingFilter&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt;&lt;/filter-mapping&gt; 3. 编写领域模型定义各种属性和getter&amp;setter方法，太简单，不赘述 4. 编写控制层Controller因为视图层用的都是表单标签库，所以数据要在controller层定义 然后通过model.addAttribute()方法将数据传送出去 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162@Controller@RequestMapping(&quot;/four&quot;)public class FourController &#123; private static final Log logger = LogFactory.getLog(FourController.class); private final FourUserService fourUserService; @Autowired public FourController(FourUserService fourUserService) &#123; this.fourUserService = fourUserService; &#125; /** * 第一次加载表单会触发这个方法 */ @RequestMapping(&quot;/input&quot;) public String inputUser(Model model) &#123; HashMap&lt;String, String&gt; hobbys = getMap();44// 虽然是第一次加载，但是也要在model添加一个领域模型的对象，否则表单标签无法找到modelAttribute属性指定的form backing object model.addAttribute(&quot;user&quot;, new User()); model.addAttribute(&quot;hobbys&quot;, hobbys); model.addAttribute(&quot;carrers&quot;, new String[]&#123;&quot;教师&quot;, &quot;学生&quot;, &quot;码农&quot;, &quot;民工&quot;&#125;); model.addAttribute(&quot;houseRegister&quot;, new String[]&#123;&quot;北京&quot;, &quot;上海&quot;, &quot;广州&quot;, &quot;深圳&quot;&#125;); return &quot;userAdd&quot;; &#125; /** * 表单提交的时候会触发这个方法 */ @RequestMapping(&quot;/save&quot;) public String addUser(@ModelAttribute User user, Model model) &#123; // 进入业务层验证业务逻辑 if (fourUserService.addUser(user)) &#123; logger.info(&quot;成功&quot;); // 重定向到本控制器里的list控制方法 return &quot;redirect:list&quot;; &#125; logger.info(&quot;失败&quot;); // 验证失败的时候就到了这里，相当于重新加载，但是会带着已经填过的数据，用户就不用再次填写已经填写过的输入，注意这里没有在model.addAttribute()中new bean()。看不懂请对比上面的input方法 HashMap&lt;String, String&gt; hobbys = getMap(); model.addAttribute(&quot;hobbys&quot;, hobbys); model.addAttribute(&quot;carrers&quot;, new String[]&#123;&quot;教师&quot;, &quot;学生&quot;, &quot;码农&quot;, &quot;民工&quot;&#125;); model.addAttribute(&quot;houseRegister&quot;, new String[]&#123;&quot;北京&quot;, &quot;上海&quot;, &quot;广州&quot;, &quot;深圳&quot;&#125;); return &quot;userAdd&quot;; &#125; @RequestMapping(&quot;/list&quot;) public String listUsers(Model model) &#123; List&lt;User&gt; users = fourUserService.getUsers(); model.addAttribute(&quot;users&quot;, users); return &quot;userList&quot;; &#125; private HashMap&lt;String, String&gt; getMap() &#123; HashMap&lt;String, String&gt; hobbys = new HashMap&lt;&gt;(5); hobbys.put(&quot;篮球&quot;, &quot;篮球&quot;); hobbys.put(&quot;乒乓球&quot;, &quot;乒乓球&quot;); hobbys.put(&quot;电玩&quot;, &quot;电玩&quot;); hobbys.put(&quot;游泳&quot;, &quot;游泳&quot;); return hobbys; &#125;&#125; 5. 编写业务逻辑层Service业务层，业务逻辑都在这里判断 123456789101112131415161718192021222324252627282930package service.four;import org.springframework.stereotype.Service;import po.four.User;import java.util.ArrayList;/** * @author pr919 */@Servicepublic class FourUserServiceImpl implements FourUserService &#123; private static ArrayList&lt;User&gt; users = new ArrayList&lt;&gt;(); @Override public boolean addUser(User u) &#123; String magicValue = &quot;民工&quot;; if (!magicValue.equals(u.getCarrer()) &amp;&amp; !&quot;&quot;.equals(u.getUsername()))&#123; users.add(u); return true; &#125; return false; &#125; @Override public ArrayList&lt;User&gt; getUsers() &#123; return users; &#125;&#125; 6. 编写视图层View视图层的表单标签通过控制层和领域模型绑定在一起，实现了数据绑定。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374&lt;%-- userAdd.jsp --%&gt;&lt;%@ taglib prefix=&quot;form&quot; uri=&quot;http://www.springframework.org/tags/form&quot; %&gt;&lt;%-- Created by IntelliJ IDEA. User: pr919 Date: 2019.6.24 Time: 14:41 To change this template use File | Settings | File Templates.--%&gt;&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; %&gt;&lt;%@ page isELIgnored=&quot;false&quot; %&gt;&lt;% String path = request.getContextPath(); String basePath = request.getScheme() + &quot;://&quot; + request.getServerName() + &quot;:&quot; + request.getServerPort() + path + &quot;/&quot;;%&gt;&lt;html&gt;&lt;head&gt; &lt;base href=&quot;&lt;%=basePath%&gt;&quot;/&gt; &lt;title&gt;dataBind&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;%--@elvariable id=&quot;user&quot; type=&quot;po.four.User&quot;--%&gt;&lt;form:form modelAttribute=&quot;user&quot; mothod=&quot;post&quot; action=&quot;four/save&quot;&gt; &lt;fieldset&gt; &lt;legend&gt;添加一个用户&lt;/legend&gt; &lt;p&gt; &lt;label&gt;用户名：&lt;/label&gt; &lt;form:input path=&quot;username&quot;/&gt; &lt;/p&gt; &lt;p&gt; &lt;label&gt;爱好：&lt;/label&gt; &lt;%--@elvariable id=&quot;hobbys&quot; type=&quot;java.util.List&quot;--%&gt; &lt;form:checkboxes items=&quot;$&#123;hobbys&#125;&quot; path=&quot;hobby&quot;/&gt; &lt;/p&gt; &lt;p&gt; &lt;label&gt;朋友：&lt;/label&gt; &lt;form:checkbox path=&quot;friends&quot; value=&quot;张三&quot;/&gt;1 &lt;form:checkbox path=&quot;friends&quot; value=&quot;李四&quot;/&gt;2 &lt;form:checkbox path=&quot;friends&quot; value=&quot;王五&quot;/&gt;3 &lt;form:checkbox path=&quot;friends&quot; value=&quot;赵六&quot;/&gt;4 &lt;/p&gt; &lt;p&gt; &lt;label&gt;职业：&lt;/label&gt; &lt;form:select path=&quot;carrer&quot;&gt; &lt;option&gt;&lt;/option&gt; 请选择职业 &lt;%--@elvariable id=&quot;carrers&quot; type=&quot;java.util.List&quot;--%&gt; &lt;form:options items=&quot;$&#123;carrers&#125;&quot;/&gt; &lt;/form:select&gt; &lt;/p&gt; &lt;p&gt; &lt;label&gt;户籍：&lt;/label&gt; &lt;form:select path=&quot;houseRegister&quot;&gt; &lt;option&gt;&lt;/option&gt; 请选择户籍 &lt;%--@elvariable id=&quot;houseRegister&quot; type=&quot;java.util.List&quot;--%&gt; &lt;form:options items=&quot;$&#123;houseRegister&#125;&quot;/&gt; &lt;/form:select&gt; &lt;/p&gt; &lt;p&gt; &lt;label&gt;个人描述：&lt;/label&gt; &lt;form:textarea path=&quot;remark&quot; rows=&quot;5&quot;/&gt; &lt;/p&gt; &lt;p id=&quot;buttons&quot;&gt; &lt;input id=&quot;reset&quot; type=&quot;reset&quot; /&gt; &lt;input id=&quot;submit&quot; type=&quot;submit&quot; value=&quot;添加&quot;&gt; &lt;/p&gt; &lt;/fieldset&gt;&lt;/form:form&gt;&lt;/body&gt;&lt;/html&gt; 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556&lt;%-- userAdd.jsp --%&gt;&lt;%@ taglib prefix=&quot;c&quot; uri=&quot;http://java.sun.com/jsp/jstl/core&quot; %&gt;&lt;%-- Created by IntelliJ IDEA. User: pr919 Date: 2019.6.24 Time: 15:18 To change this template use File | Settings | File Templates.--%&gt;&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; %&gt;&lt;%@ page isELIgnored=&quot;false&quot; %&gt;&lt;% String path = request.getContextPath(); String basePath = request.getScheme() + &quot;://&quot; + request.getServerName() + &quot;:&quot; + request.getServerPort() + path + &quot;/&quot;;%&gt;&lt;html&gt;&lt;head&gt; &lt;base href=&quot;&lt;%=basePath%&gt;&quot;/&gt; &lt;title&gt;dataList&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;h1&gt;用户列表&lt;/h1&gt;&lt;a href=&quot;&lt;c:url value=&quot;four/input&quot;/&gt;&quot;&gt;继续添加&lt;/a&gt;&lt;table&gt; &lt;tr&gt; &lt;th&gt;用户名&lt;/th&gt; &lt;th&gt;兴趣爱好&lt;/th&gt; &lt;th&gt;朋友&lt;/th&gt; &lt;th&gt;职业&lt;/th&gt; &lt;th&gt;户籍&lt;/th&gt; &lt;th&gt;个人描述&lt;/th&gt; &lt;/tr&gt; &lt;c:forEach items=&quot;$&#123;users&#125;&quot; var=&quot;user&quot;&gt; &lt;tr&gt; &lt;td&gt;$&#123;user.username&#125;&lt;/td&gt; &lt;td&gt; &lt;c:forEach items=&quot;$&#123;user.hobby&#125;&quot; var=&quot;hobby&quot;&gt; $&#123;hobby&#125;&amp;nbsp; &lt;/c:forEach&gt; &lt;/td&gt; &lt;td&gt; &lt;c:forEach items=&quot;$&#123;user.friends&#125;&quot; var=&quot;friend&quot;&gt; $&#123;friend&#125;&amp;nbsp; &lt;/c:forEach&gt; &lt;/td&gt; &lt;td&gt;$&#123;user.carrer&#125;&lt;/td&gt; &lt;td&gt;$&#123;user.houseRegister&#125;&lt;/td&gt; &lt;td&gt;$&#123;user.remark&#125;&lt;/td&gt; &lt;/tr&gt; &lt;/c:forEach&gt;&lt;/table&gt;&lt;/body&gt;&lt;/html&gt; 总结目前来说，除了不用手动转型之外，我还没想到这个数据绑定有什么用。如果是为了验证输入的话，用javaScript或ajax就够了。","categories":[{"name":"Java","slug":"Java","permalink":"https://www.boii.xyz/categories/Java/"},{"name":"SSM","slug":"SSM","permalink":"https://www.boii.xyz/categories/SSM/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://www.boii.xyz/tags/Java/"},{"name":"SSM","slug":"SSM","permalink":"https://www.boii.xyz/tags/SSM/"},{"name":"数据绑定","slug":"数据绑定","permalink":"https://www.boii.xyz/tags/%E6%95%B0%E6%8D%AE%E7%BB%91%E5%AE%9A/"}]},{"title":"C-Note","slug":"C-Note","date":"2019-06-09T05:03:26.000Z","updated":"2021-05-23T04:41:50.075Z","comments":true,"path":"2019/06/09/C-Note/","link":"","permalink":"https://www.boii.xyz/2019/06/09/C-Note/","excerpt":"C语言笔记","text":"C语言笔记 指针12345定义指针: dataType * pointerName = NULL;int * ptr_a = NULL;指针赋值：pointerName = &amp;varName;int a = 10;ptr_a = &amp;a; 对于指针，其实就是存放地址的变量 int a = 10; 这句话等于申请了一块内存，放了个值10进去，起个别命叫a 。那这个空间的地址假设是 0028FF，那ptr_a = &amp;a 这句话就是再申请一块内存，把0028FF放进去，起个别名叫ptr_a 。 &amp; 这个符号是取地址的意思 * 这个符号则是取这个指针变量中，那个地址的内存中的 值，也就是直接操作内存，修改内存里的内容 值传递 引用传递值传递：传递一份副本，传递后操作的只是副本，也就是对变量的副本进行操作，变量本身不会变化 1234567891011void change(int num)&#123; num ++;&#125;void main()&#123;4int num = 9;4change(num);4printf(&quot;num = %d&quot;, num);&#125;结果：9 引用传递：&amp;var， 传递的是地址，传递后操作的是该地址中的值，也就是对变量本身进行操作 1234567891011void change(int * num)&#123;4*num ++;&#125;void main()&#123;4int num = 9; change(&amp;num); printf(&quot;num = %d&quot;, num);&#125;结果：10 值传递就是普通操作，引用传递就是操作指针（骚操作） 变量的生存周期 存储类型说明符 存储类型 说明 auto 自动存储 只能用于块作用域中的变量，局部变量默认情况下归为自动存储类型 register 寄存器存储 只能用于块作用域中的变量，请求速度快，适用在循环次数多的循环变量/反复使用的变量。 static 静态存储 载入程序时创建对象，程序结束时对象消失。 extern 外部变量 说明符表示生命的变量定义在别处。作用域是整个程序，生存周期贯穿应用程序的开始和结束。跟static一样。 头文件123456#ifndef HEADFILENAME_H_INCLUDE#define HEADFILENAME_H_INCLUDE44// TODO#endif","categories":[{"name":"C Language","slug":"C-Language","permalink":"https://www.boii.xyz/categories/C-Language/"},{"name":"Note","slug":"Note","permalink":"https://www.boii.xyz/categories/Note/"}],"tags":[{"name":"C Language","slug":"C-Language","permalink":"https://www.boii.xyz/tags/C-Language/"},{"name":"note","slug":"note","permalink":"https://www.boii.xyz/tags/note/"}]},{"title":"Java-About-Hash","slug":"Java-About-Hash","date":"2019-06-08T17:26:48.000Z","updated":"2021-05-23T04:42:37.866Z","comments":true,"path":"2019/06/09/Java-About-Hash/","link":"","permalink":"https://www.boii.xyz/2019/06/09/Java-About-Hash/","excerpt":"","text":"HashTableHashTable 散列表 哈希表： 是一种数据结构，它提供快速的插入和查找操作，不管表中有多少数据，插入删除和查找的时间都接近O(1) 优点：HashTable其实是基于数组的，所以在查询方面非常的快，同时它不像普通数组那样紧密排列，在数值未满的时候所有的值其实是散部在数组中的某个位置上的，所以在插入和删除的时候不用像普通数组一样让余下的值一个个的挪。 缺点：同时也因为它的基于数组的，所以创建以后难以扩展，当HashTable被基本填满的时候，性能严重下降，而且不能顺序遍历。 一个输入传进来的时候会经过散列函数，计算出一个值，这个值就是这个输入在HashTable中的位置，称为HashCode 哈希值 散列值。 当HashTable中的值还不多的时候各种操作的效率是非常高的，但是HashTable快满的时候各种操作的效率就开始变低了 开放寻址法线性探测方法 比如一个HashTable的长度是8，现在只剩下 6 这个位置是空的 而一个输入经过散列函数计算之后得到的结果是 7 ，一看 7 上面有人占了，怎么办呢？ 往下找空位咯，7 下面是 0 ，有人了，下一个 1 ，有人了，下一个 2 ，有人了…下一个 6 ，耶没人，上去！ 这样几乎遍历了一整个数组，效率是非常低的，HashTable小的时候还能忍受，如果HashTable长度是2000呢?20000呢？ 上述的方法其实就是当散列函数计算出来的值上面已经有值的时候的解决方法之一，开放寻址法中的线性探测，往下找空位，找到进填进去。最坏的情况下就是几乎遍历整个数组。 二次探测方法另一种的思路有那么点像二分查找法，叫做二次探测方法 比如表中只有 3 是有空位的，其余都是满的 而一个输入经过散列函数计算之后得到的结果是 7，一看 7 上面有人了，怎么办呢？ CurrentCode + 0，CurrentCode + 1^2^ ，CurrentCode - 1 ^2^，CurrentCode + 2^2^，CurrentCode - 2^2^，…… 7不行就 + 1^2^ = 8，8还是不行，那就7 - 1^2^ = 6，6还是不行，那就7 - 2^2^ = 3，3可以，上去！ 因为进行试探的步长都是二次方，所以叫 二次探测方法 双重散列方法还有一种方法叫做 双重散列方法 就是使用第一个哈希函数计算的值如果被占用了，就找第二个哈希函数，直到找到空闲的存储位置 不管用那种方法，只要HashTable空位不多的时候散列冲突的概率就会大大提高，尽可能保证HashTable中有一定比例的空位。 一般用加载因子来表示空位的多少。加载因子越大表示约满，反之亦然。 链表法HashTable中每个元素对应一条链表，所有散列值相同的元素放到相同的链表中。如下图 查找的时候先通过HashCode找到位置，然后将值与链表中的值逐个使用 equals() 对比。 But但其实HashTable是元素数量不能超过总容量的一半，当HashTable太满的时候，一个选择是扩容数组，创建一个新的容量为 CurrentCapacity * 1.34 + n = 2^m 的数组，把值放到新数组，但是元素的索引没法复制，会被重新哈希化。$$CurrentCapacity * 1.34 + n = 2^m = NewCapacity$$ 举个栗子一本字典有1000页，当你要查找Link这个词的时候，肯定想去翻目录，目录显示在第666页，那么你是不是可以直接翻到666页找这个单词？也就是所Link这个单词在散列表[666]，但是第666页可能不止这一个单词哦，那你是不是要一个一个进行equals才能知道是哪个呢？因为知道在哪一条链表上，所以尽管遍历看起来很慢，但总比遍历所有链表快吧？","categories":[{"name":"Java","slug":"Java","permalink":"https://www.boii.xyz/categories/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://www.boii.xyz/tags/Java/"},{"name":"Hash","slug":"Hash","permalink":"https://www.boii.xyz/tags/Hash/"}]},{"title":"Java-反射","slug":"Java-反射","date":"2019-06-08T16:58:48.000Z","updated":"2021-05-23T04:42:06.979Z","comments":true,"path":"2019/06/09/Java-反射/","link":"","permalink":"https://www.boii.xyz/2019/06/09/Java-%E5%8F%8D%E5%B0%84/","excerpt":"","text":"12345678910111213141516171819Person p = new Person();/**获取*/Class&lt;?&gt; clazz = p.getClass(); // 得知道类对象Class&lt;?&gt; clazz = Person.class; //得知道类名Class&lt;?&gt; clazz = Class.forName(&quot;com.tcp404.Person&quot;);//得知道类的全路径名/** 获取方法 */Method method = clazz.getDeclaredMethod(&quot;方法名&quot;, new Class()&#123;[参数类型.class, 参数类型.class, ...]&#125;);Methods[] methods = clazz.getDeclaredMethods();/** 获取属性 */Field field = clazz.getDeclaredField(&quot;属性名字&quot;);Field[] fields = clazz.getDeclaredFields();/** 获取构造器 */Constructor&lt;?&gt; con = clazz.getDeclaredConstructor(new Class()&#123;[参数类型.class, 参数类型.class, ...]&#125;);Constructor&lt;?&gt;[] cs = clazz.getDeclaredConstructors();","categories":[{"name":"Java","slug":"Java","permalink":"https://www.boii.xyz/categories/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://www.boii.xyz/tags/Java/"},{"name":"反射","slug":"反射","permalink":"https://www.boii.xyz/tags/%E5%8F%8D%E5%B0%84/"}]},{"title":"Git命令大全","slug":"Git命令大全","date":"2019-05-19T07:15:19.000Z","updated":"2021-05-23T04:38:56.546Z","comments":true,"path":"2019/05/19/Git命令大全/","link":"","permalink":"https://www.boii.xyz/2019/05/19/Git%E5%91%BD%E4%BB%A4%E5%A4%A7%E5%85%A8/","excerpt":"","text":"Git 常用命令&gt;_ Workspace：工作区 Index / Stage：暂存区 Repository：仓库区（或本地仓库） Remote：远程仓库 先放上一张常用Git 命令导航图 一、新建代码库12345678在当前目录新建一个Git代码库（常用）git init新建一个目录，将其初始化为Git代码库git init [project-name]下载一个项目和它的整个代码历史（常用）git clone [url] 二、配置Git的设置文件为.gitconfig，它可以在用户主目录下（全局配置），也可以在项目目录下（项目配置）。 123456789显示当前的Git配置git config --list编辑Git配置文件git config -e [--global]设置提交代码时的用户信息git config [--global] user.name &quot;[name]&quot;git config [--global] user.email &quot;[email address]&quot; 三、增加/删除文件123456789101112131415161718192021添加指定文件到暂存区（常用）git add [file1] [file2] ...添加指定目录到暂存区，包括子目录git add [dir]添加当前目录的所有文件到暂存区（常用）git add .添加每个变化前，都会要求确认对于同一个文件的多处变化，可以实现分次提交git add -p删除工作区文件，并且将这次删除放入暂存区git rm [file1] [file2] ...停止追踪指定文件，但该文件会保留在工作区git rm --cached [file]改名文件，并且将这个改名放入暂存区git mv [file-original] [file-renamed] 四、代码提交123456789101112131415161718提交暂存区到仓库区（常用）git commit -m [message]提交暂存区的指定文件到仓库区（常用）git commit [file1] [file2] ... -m [message]提交工作区自上次commit之后的变化，直接到仓库区git commit -a提交时显示所有diff信息git commit -v使用一次新的commit，替代上一次提交如果代码没有任何新变化，则用来改写上一次commit的提交信息git commit --amend -m [message]重做上一次commit，并包括指定文件的新变化git commit --amend [file1] [file2] ... 五、分支123456789101112131415161718192021222324252627282930313233343536373839404142列出所有本地分支（常用）git branch列出所有远程分支git branch -r列出所有本地分支和远程分支（常用）git branch -a新建一个分支，但依然停留在当前分支（常用）git branch [branch-name]新建一个分支，并切换到该分支（常用）git checkout -b [branch]新建一个分支，指向指定commitgit branch [branch] [commit]新建一个分支，与指定的远程分支建立追踪关系git branch --track [branch] [remote-branch]切换到指定分支，并更新工作区（常用）git checkout [branch-name]切换到上一个分支（常用）git checkout -建立追踪关系，在现有分支与指定的远程分支之间git branch --set-upstream [branch] [remote-branch]合并指定分支到当前分支git merge [branch]选择一个commit，合并进当前分支git cherry-pick [commit]删除分支（常用）git branch -d [branch-name]删除远程分支git push origin --delete [branch-name]git branch -dr [remote/branch] 六、标签1234567891011121314151617181920212223242526列出所有taggit tag新建一个tag在当前commitgit tag [tag]新建一个tag在指定commitgit tag [tag] [commit]删除本地taggit tag -d [tag]删除远程taggit push origin :refs/tags/[tagName]查看tag信息git show [tag]提交指定taggit push [remote] [tag]提交所有taggit push [remote] --tags新建一个分支，指向某个taggit checkout -b [branch] [tag] 七、查看信息123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263显示有变更的文件（常用）git status显示当前分支的版本历史（常用）git log显示commit历史，以及每次commit发生变更的文件git log --stat搜索提交历史，根据关键词git log -S [keyword]显示某个commit之后的所有变动，每个commit占据一行git log [tag] HEAD --pretty=format:%s显示某个commit之后的所有变动，其&quot;提交说明&quot;必须符合搜索条件git log [tag] HEAD --grep feature显示某个文件的版本历史，包括文件改名git log --follow [file]git whatchanged [file]显示指定文件相关的每一次diffgit log -p [file]显示过去5次提交git log -5 --pretty --oneline显示所有提交过的用户，按提交次数排序git shortlog -sn显示指定文件是什么人在什么时间修改过git blame [file]显示暂存区和工作区的代码差异（常用）git diff显示暂存区和上一个commit的差异git diff --cached [file]显示工作区与当前分支最新commit之间的差异git diff HEAD显示两次提交之间的差异git diff [first-branch]...[second-branch]显示今天你写了多少行代码git diff --shortstat &quot;@&#123;0 day ago&#125;&quot;显示某次提交的元数据和内容变化（常用）git show [commit]显示某次提交发生变化的文件git show --name-only [commit]显示某次提交时，某个文件的内容git show [commit]:[filename]显示当前分支的最近几次提交git reflog从本地master拉取代码更新当前分支：branch 一般为mastergit rebase [branch] 八、远程同步123456789101112131415161718192021222324git remote update --更新远程仓储（常用）下载远程仓库的所有变动git fetch [remote]显示所有远程仓库git remote -v显示某个远程仓库的信息git remote show [remote]增加一个新的远程仓库，并命名git remote add [shortname] [url]取回远程仓库的变化，并与本地分支合并（常用）git pull [remote] [branch]上传本地指定分支到远程仓库（常用）git push [remote] [branch]强行推送当前分支到远程仓库，即使有冲突git push [remote] --force推送所有分支到远程仓库git push [remote] --all 九、撤销12345678910111213141516171819202122232425262728293031恢复暂存区的指定文件到工作区git checkout [file]恢复某个commit的指定文件到暂存区和工作区git checkout [commit] [file]恢复暂存区的所有文件到工作区git checkout .重置暂存区的指定文件，与上一次commit保持一致，但工作区不变git reset [file]重置暂存区与工作区，与上一次commit保持一致(取消所有修改)（常用）git reset --hard重置当前分支的指针为指定commit，同时重置暂存区，但工作区不变git reset [commit]重置当前分支的HEAD为指定commit，同时重置暂存区和工作区，与指定commit一致git reset --hard [commit]重置当前HEAD为指定commit，但保持暂存区和工作区不变git reset --keep [commit]新建一个commit，用来撤销指定commit后者的所有变化都将被前者抵消，并且应用到当前分支git revert [commit]暂时将未提交的变化移除，稍后再移入（常用）git stashgit stash pop 十、其他12生成一个可供发布的压缩包（常用）git archive","categories":[{"name":"Git","slug":"Git","permalink":"https://www.boii.xyz/categories/Git/"}],"tags":[{"name":"git","slug":"git","permalink":"https://www.boii.xyz/tags/git/"},{"name":"命令","slug":"命令","permalink":"https://www.boii.xyz/tags/%E5%91%BD%E4%BB%A4/"}]},{"title":"多端同步管理Hexo博客","slug":"多端同步管理Hexo博客","date":"2019-05-18T03:37:35.000Z","updated":"2021-05-23T03:09:53.691Z","comments":true,"path":"2019/05/18/多端同步管理Hexo博客/","link":"","permalink":"https://www.boii.xyz/2019/05/18/%E5%A4%9A%E7%AB%AF%E5%90%8C%E6%AD%A5%E7%AE%A1%E7%90%86Hexo%E5%8D%9A%E5%AE%A2/","excerpt":"","text":"多端管理其实很简单。 hexo 其实是帮我们编译好放在博客根目录\\public目录下的，然后把public目录推送到github上的，所以说github.io上面都是编译过的文件，他们是光鲜亮丽的演员，但离不开默默付出的后台人员。这些默默付出的后台人员就是除了public之外的所有的文件。 我们的博客是发布到master主分支的，那就建另一个分支，把所有文件都传上去，在别的电脑上都拉下去就可以了。 1. 首先填写忽略声明文件.gitignore12345678.DS_StoreThumbs.dbdb.json*.lognode_modules/public/.deploy*/_config.yml public 每次都会编译覆盖，所以不需要它 .deploy* 编译产生的文件，也不需要 _config.yml 配置文件里会有一些id/key的重要信息，所以不上传 2. 初始化仓库和提交之前我以为hexo就是帮我们操作git，所以不明白为什么还能再初始化git 后来才知道不是那么回事。但是hexo是怎么操作我还是没明白。这里不管 像往常一样，在根目录右键 git bash here 注意！！！大坑！！！ 如果你用的是第三方的主题theme，是使用git clone下来的话，要把主题文件夹下面把.git文件夹删除掉，不然主题无法push到远程仓库，导致你发布的博客是一片空白。所以先去检查你使用的主题有没有.git这个目录 123456git init //初始化本地仓库git add . //添加本地所有文件到仓库 git commit -m &quot;blog源文件&quot; //添加commitgit branch backup //添加本地仓库分支hexogit remote add origin &lt;server&gt; //添加远程仓库 &lt;server&gt; 是指在线仓库的地址 origin是本地分支,remote add操作会将本地仓库映射到云端git push origin backup //将本地仓库的源文件推送到远程仓库hexo分支 在另一台电脑的操作首先肯定要搭建环境啦（Node 和 Git） 完了后用这个命令 123git clone &lt;server&gt; hexo //&lt;server&gt; 是指在线仓库的地址cd hexo npm install npm install的时候会根据package.json中的插件列表自动加载相应插件。 本机的同步完成。 因为在上传博客源文件的时候忽略了配置文件（_config.yml这是站点的配置文件）的上传，也就是没有上传配置文件的，在克隆下来的时候记得把配置文件拿过来，不然会报错。主题里面的配置文件也要（themes/next/_config.yml这是主题配置文件） 这里贴一张常用Git命令 &gt;_","categories":[{"name":"HEXO","slug":"HEXO","permalink":"https://www.boii.xyz/categories/HEXO/"},{"name":"Note","slug":"Note","permalink":"https://www.boii.xyz/categories/Note/"},{"name":"Git","slug":"Git","permalink":"https://www.boii.xyz/categories/Git/"}],"tags":[{"name":"HEXO","slug":"HEXO","permalink":"https://www.boii.xyz/tags/HEXO/"},{"name":"note","slug":"note","permalink":"https://www.boii.xyz/tags/note/"},{"name":"git","slug":"git","permalink":"https://www.boii.xyz/tags/git/"}]},{"title":"几句话区分并行和并发","slug":"几句话区分并行和并发","date":"2019-05-15T02:04:18.000Z","updated":"2021-06-04T05:10:44.887Z","comments":true,"path":"2019/05/15/几句话区分并行和并发/","link":"","permalink":"https://www.boii.xyz/2019/05/15/%E5%87%A0%E5%8F%A5%E8%AF%9D%E5%8C%BA%E5%88%86%E5%B9%B6%E8%A1%8C%E5%92%8C%E5%B9%B6%E5%8F%91/","excerpt":"吃饭和打电话你选择哪个？","text":"吃饭和打电话你选择哪个？ 举个栗子 你在吃饭，电话进来，你等到吃完了才接电话 –&gt; 你不支持【并行或者并发】 （1个CPU，队列式执行任务，这个做完了才做下一个，不允许插队） 你在吃饭，电话进来，接一下电话，吃一下饭，交替进行，说明你支持【并发】 （一个CPU，多个任务同时进行，这个做一下，那个做一下，回过来这个再做一下…，允许插队） 你在吃饭，电话进来，你继续吃饭，秘书帮你接电话，说明你支持【并行】 （多于一个CPU，多个任务同时进行，各忙各的） &gt;_ 正儿八经的胡说一下并发主要是指：同一时间 【段】 “同时”做多件事 比如一边打电话一边吃饭。人脑肯定是没法同时专注在两个事情上的，所以你的注意力会一下在电话上（听电话里说什么），一下在吃饭上（大脑下达抬手张嘴咀嚼的指令），CPU也是如此。 吃饭一个线程，接电话一个线程。分给吃饭线程一点时间片，分给接电话一点时间片，吃饭的时间片执行完了切到电话线程执行，电话线程的时间片执行完了切到吃饭线程，因为切换的快，所以感觉像同时进行。 这里时间片不懂的话就姑且理解为能量条，CPU切过来执行吃饭线程，吃饭线程的能量条就开始消耗，消耗完了CPU就走了去消耗电话线程的能量条了。与此同时吃饭线程的能量条在CPU切走的时候瞬间满了，CPU那边消耗完了又过来吃饭线程消耗这边的能量条，耗完了又走了。如此往复直到任务执行完毕。 并行只要是指：同一时间 【点】 “同时”做多件事 还是上面吃饭打电话的例子，电话来了你吃你的，电话秘书帮你接。你处理吃饭的事情，秘书处理电话的事情，所以就不用CPU切来切去的。因为有两个CPU了嘛（你 和 秘书）。 总结 一个收银员，只能排一条队伍，一个一个来，就是不支持并发并行 一个收银员，可以排多条队伍，这边忙忙那边忙忙，就是支持并发 多个收银员，可以排多条队伍，一个收银员处理一条队伍，就是支持并行 可见CPU只有一个的时候，就是假同时；多个CPU的时候，才是真正意义上的同时。","categories":[{"name":"Java","slug":"Java","permalink":"https://www.boii.xyz/categories/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://www.boii.xyz/tags/Java/"},{"name":"并行与并发","slug":"并行与并发","permalink":"https://www.boii.xyz/tags/%E5%B9%B6%E8%A1%8C%E4%B8%8E%E5%B9%B6%E5%8F%91/"}]},{"title":"当小程序开发完成后","slug":"当小程序开发完成后","date":"2019-05-13T07:35:21.000Z","updated":"2019-05-13T07:35:21.000Z","comments":true,"path":"2019/05/13/当小程序开发完成后/","link":"","permalink":"https://www.boii.xyz/2019/05/13/%E5%BD%93%E5%B0%8F%E7%A8%8B%E5%BA%8F%E5%BC%80%E5%8F%91%E5%AE%8C%E6%88%90%E5%90%8E/","excerpt":"开发小程序后的一点总结","text":"开发小程序后的一点总结 本来没想搞小程序的，谁知道寒假突然脑子发热，看了点视频和文章，就着现成的点子开始搞起来。 从1月20日到4月2日，平均每天投入10+小时，历经三次改版，一次阉割，无数次和UI吵架，总算把GoTE小程序做出来了。 小程序1234567小程序名：GoTE行程发布小程序样式库：ColorUI插件：WxValidate.js（表单验证）外部API：高德地图开放平台（用于获取打车费用&lt;已阉割&gt;）前端：小程序原生后端：小程序云开发环境数据库：云开发 -&gt; 云数据库 &gt;_ &gt;_ 项目最初的出发点是由于学校地处偏僻，出行不便，坐公车经常拥挤且一站到底。打车费用又十分昂贵，且独自出行来往于学校这偏僻之地具有一定危险性。校外非法黑车趁机拉帮结派，用略低于滴滴的价格拉拢学生乘坐。为了大幅盈利设置了拼车一项，一行4人35元，但是单人拼车费用要17元！ 所以我决定自己开发一个小程序供同学们发布行程信息，有相同行程的人可以互相联系一同出行，即节省了出行成本，又避免单独外出。 于是1月20日正式开动，在此后的不间断每天投入10+小时在其中，从产品定位，功能定义，开发，测试等等，历经73天最终定版，提交审核。 正当我满心欢喜的提交审核两天之后，审核团队冷冰冰的打回，再之后不管多少次修改都只有冷冰冰的这么一句话 &gt;_ 我只是一个单纯的行程发布平台，连个车字都没有哪来的涉及拼车？不管是反馈还是重新提交都只有这么冷冰冰的一句话。 此项目对我来说有非凡的意义， 第一个完整的个人项目 第一次完成想法落地实现的完整执行 第一次靠自学完成一个项目 总结在被腾讯审核团队冷冰冰的打回N次之后，开始有些心灰意冷。在这次项目中，还是有一些体会的。 在开发过程中慢慢明白了，小程序其实可以理解为一个微信内置浏览器，开发小程序的过程就跟开发网页类似。不过小程序封装了很多接口，提供了很多实现。如果是有开发经验的程序员，稍微熟悉语法就可以快速开发出一个完整的小程序，不夸张的说，一个商城，从零开始，快则半月，慢则一月。 小程序本身的局限性所致，小程序注定无法完全替代App。作为分销引流可以，要完全替代不太现实。小程序开发完全部资源包括代码不能超过2M，且运行载荷不能太大，否则会被微信的机制强制退出。如果你手机太老，还会把你的微信给强制退出（闪退）。所以承担一点分销展示的任务可以，完全搬上小程序会导致体验极其的差。参考 微信支付 -&gt; 酒店 -&gt; 同程艺龙小程序。大量的网络请求，实测 Iphone6 plus IOS 10.2 上运行体验很差. 像微信小程序，支付宝小程序，百度小程序等这种开发都是寄人篱下。用人家的平台，人家接口，享受人家封装好带来的便利，需要付出的代价就是非常严格的审核。这种情况下只能祈福于客服，出了问题或是疑问有个靠谱的客服或者回应显得尤为重要。像微信这种机器人只能说(ta)呵(ma)呵(de)了。 做成一件事情很难，特别是这种涉及很多用户，用户之间产生交流的事情，你要够专业，够团结，够投入，够拼，能力够强。GoTE是一个面向学生的，开放的平台，也就是说用户与用户之间会产生交流。在涉及到这种用户之间交流（社交）的时候就需要格外小心。比如GoTE： 第一要面临的问题就是用户身份验证。怎么确定你是学生？哪个学校的学生？目前能想到的就是利用超级课程表的方式，利用爬虫接入各学校教务系统，学生提供账号密码验证码，登录到教务系统中验证。 第二怎么保障共同出行过程的顺利？怎么尽量确保双方之间不会发生矛盾（因为路费或是任何问题）？ 看似简单的两个问题其实需要大量的工作。不过我只有一个人，很需要帮手。 此文作为第一次实际行动的总结记录 谨此","categories":[{"name":"Other","slug":"Other","permalink":"https://www.boii.xyz/categories/Other/"}],"tags":[{"name":"note","slug":"note","permalink":"https://www.boii.xyz/tags/note/"}]},{"title":"通信中的加密与解密-详细版","slug":"通信中的加密与解密-详细版","date":"2019-04-26T01:54:27.000Z","updated":"2021-05-23T04:24:41.532Z","comments":true,"path":"2019/04/26/通信中的加密与解密-详细版/","link":"","permalink":"https://www.boii.xyz/2019/04/26/%E9%80%9A%E4%BF%A1%E4%B8%AD%E7%9A%84%E5%8A%A0%E5%AF%86%E4%B8%8E%E8%A7%A3%E5%AF%86-%E8%AF%A6%E7%BB%86%E7%89%88/","excerpt":"换个详细点的捋一捋","text":"换个详细点的捋一捋 首先，用户的操作系统会内置一些CA机构的CA证书 CA证书：CA机构颁发给自己的证书 组成： CA的公钥 颁发者 颁发机构 有效期 其他内容 签名（CA私钥加密过）： 对以上内容进行hash=&gt;hash值 hash的算法 这里签名是CA私钥加密过的，如果黑客用公钥解开签名，然后篡改信息再Hash，带上hash算法，就没办法加密回去，因为没CA私钥。 如果篡改成自己的公钥，再hash，带上hash算法，用自己的私钥加密（签名），这就是伪造CA证书，这样等于白干，因为操作系统会提示这个证书不可信，不过CA证书一般都是操作系统内置的，不需要网络请求，所以没机会拦截篡改。一般问题都出在CA机构内部。 那一个网站，它首先要找CA机构认证，认证完CA机构会给一张证书，这个就是网站证书了 网站证书：CA机构给网站颁发的证书 组成： 网站的公钥 颁发者（CA机构） 颁发机构（网站） 有效期 其他内容 CA签名，也就是指纹（CA私钥加密过的）： 对以上内容进行hash=&gt;hash值 hash的算法 这里的CA签名也是用CA私钥加密过的，如果黑客用CA公钥解开签名，然后篡改网站的公钥再hash，带上hash算法，就没法加密回去，因为没CA私钥。用黑客自己的私钥加密回去的话，用户拿到证书，根据颁发者（CA机构）拿出CA公钥，它解不开黑客的私钥。那就通信终止了。 场景： 首先用户请求网站给个证书看看 网站给了网站证书 用户就根据证书的颁发者去操作系统找颁发者的证书（也就是操作系统中的CA证书），去拿到CA公钥出来 然后用CA公钥解开CA签名拿到hash值1和hash算法 然后用hash算法自己计算整个证书的内容得到hash值2 对比hash值1和hash值2来验证网站证书有没有被篡改 验证通过后会生成一串随机字符串，自己保留一份，然后发一份让网站用网站的私钥加密这串随机字符串 网站把这串随机字符串用网站的私钥加密，发回给客户 用户再用证书上的网站的公钥去解，能解开，解开后对比回来的随机字符串和自己保留的那份随机字符串是不是一致 一致则说明对方就是服务器，而不是黑客瞎搞 为了服务器安全所以用户先hash一下再发，服务器加密就行了。用户解密完对比回来的hash跟自己留着的hash是不是一直就行了。hash过才能防止黑客发送一些有规律的字符串给服务器，从而寻找加密的规律。以此保护服务器私钥的安全 如果证书没问题，对方却是黑客，那字符串用黑客的私钥加密，用户用网站的公钥是解不开的。除非黑客能弄到网站的私钥，才能在这插一脚，像上面说的黑客发送有规律的字符串不过被hash解决了，接下来就要传输密钥了。 用户验证了一直，就用自己生成一串密钥，然后用网站的公钥加密，发给网站网站用网站的私钥解密，得到密钥。然后双方开始用密钥加密信息通信。 通信的时候用户的数据写完，会先把内容hash一下生成摘要，再用密钥加密网站收到之后会先用密钥解密，然后网站自己hash一下内容生成摘要，对比传过来的摘要看看是否一致是就没问题，不一致则说明黑客在中间捣乱。则断开连接 所以用密钥的时候，其实是 信息内容本身+hash出来的信息摘要，然后才加密","categories":[{"name":"RSA","slug":"RSA","permalink":"https://www.boii.xyz/categories/RSA/"}],"tags":[{"name":"RSA","slug":"RSA","permalink":"https://www.boii.xyz/tags/RSA/"}]},{"title":"GoLang-Note-one","slug":"GoLang-Note-one","date":"2019-04-25T04:53:34.000Z","updated":"2021-05-23T04:39:18.533Z","comments":true,"path":"2019/04/25/GoLang-Note-one/","link":"","permalink":"https://www.boii.xyz/2019/04/25/GoLang-Note-one/","excerpt":"感觉Go会成为下一个C语言","text":"感觉Go会成为下一个C语言 Go语言简介和环境安装特色： 简洁、快速、安全 并行、有趣、开源 内存管理、v数组安全、编译迅速 用途：应用于搭载 Web 服务器，存储集群或类似用途的巨型中央服务器高性能分布式系统领域，Go 语言无疑比大多数其它语言有着更高的开发效率。它提供了海量并行的支持 环境安装：安装包下载地址为：https://golang.org/dl/ windows默认安装在C:\\Go目录下。 环境变量：C:\\Go\\bin 测试 &gt; go run FileName.go 语言结构Go 语言的基础组成有以下几个部分： 包声明 引入包 函数 变量 语句 &amp; 表达式 注释 不朽经典 =&gt; HelloWorld 12345678package main //包声明import &quot;fmt&quot; //引入包func main() &#123; //主函数 /* 注释 */ fmt.Println(&quot;Hello, World!&quot;) //语句&#125; 行末不需要分号 &gt; ;注释//单行注释/*多行注释*/ 标识符（变量名）AZ | az | 0~9 | _ (下划线)第一个字符必须字母or下划线，不可以是数字开头 数据类型布尔型 =&gt; true 或 false数字型 =&gt;整型int，浮点型float字符串型 =&gt; 使用UTF-8编码标识Unicode文本。派生类型 =&gt;(a) 指针类型 (Pointer)(b) 数组类型(c) 结构化类型 (struct)(d) 联合体类型 (union)(e) 函数类型(f) 切片类型 (Slice)(g) 接口类型 (interface)(h) Map 类型(i) Channel 类型 变量声明一般形式是使用var 关键字 -&gt; var num int 0x00 指明数据类型,如果不赋值则使用默认值 var name value_type var sum int 0x01 根据值自动判断类型var name = value var sum = 100 0x02 省略var ，使用赋值符号 -&gt; := ，使用这种方式，变量必须是没声明过的。只能在函数体中使用name := value sum := 10 0x03 多个变量同时声明var vname1, vname2, vname3 type var name4, name5, name6 = 10, true, “hello”name7, name8 := “world”, false 0x04 这种只能出现在全局变量中，不支持在函数体内var ( name9 int name10 float)注意： 全局变量允许声明了不使用，但是局部变量声明了却不使用会报错 重复声明会报错。如：var a float a:= 20 空白标识符 ：_ 用于抛弃值，如：_ , i := 5 , 7 ( _ 实际上是一个只写变量，你不能得到它的值) 常量定义格式：const name [type] = value const SUM int = 100 枚举格式 12345count ( SUM = 100 STR = &quot;Hello&quot; ATOB = len(STR)) 注意：常量可以用len(), cap(), unsafe.Sizeof()常量计算表达式的值。常量表达式中，函数必须是内置函数，否则编译不过 运算符算术运算符 / % ++ – 加 减 乘 除 取余数 自增 自减 关系运算符== != &gt; &lt; &gt;= &lt;=等于 不等于 大于 小于 大于等于 小于等于 逻辑运算符 &amp;&amp; || ! 与 或 非 位运算符 符号 意义 说明 &amp; 按位与 两者都为1时，结果为1 | 按位或 两者有一者为1时，结果为1 ^ 按位异或 两者不同时，结果为1 ~ 取反 1变0，0变1 &lt;&lt; 左移 每一位数都向左移动，增大 &gt; 右移 每一位书都先右移动，变小","categories":[{"name":"Note","slug":"Note","permalink":"https://www.boii.xyz/categories/Note/"},{"name":"GoLang","slug":"GoLang","permalink":"https://www.boii.xyz/categories/GoLang/"}],"tags":[{"name":"note","slug":"note","permalink":"https://www.boii.xyz/tags/note/"},{"name":"GoLang","slug":"GoLang","permalink":"https://www.boii.xyz/tags/GoLang/"}]},{"title":"LeetCode-笔记【No-4】0x09-回文数","slug":"LeetCode-笔记【No-4】0x09-回文数","date":"2019-04-25T03:30:48.000Z","updated":"2021-05-23T04:22:15.981Z","comments":true,"path":"2019/04/25/LeetCode-笔记【No-4】0x09-回文数/","link":"","permalink":"https://www.boii.xyz/2019/04/25/LeetCode-%E7%AC%94%E8%AE%B0%E3%80%90No-4%E3%80%910x09-%E5%9B%9E%E6%96%87%E6%95%B0/","excerpt":"LeetCode 第9题","text":"LeetCode 第9题 题目判断一个整数是否是回文数。回文数是指正序（从左向右）和倒序（从右向左）读都是一样的整数。 示例 1:输入: 121输出: true 示例 2:输入: -121输出: false 解释: 从左向右读, 为 -121 。 从右向左读, 为 121- 。因此它不是一个回文数。 示例 3:输入: 10输出: false 解释: 从右向左读, 为 01 。因此它不是一个回文数。 进阶:你能不将整数转为字符串来解决这个问题吗？ 思路 首先根据题意，负数肯定是不符合要求的。那第一步先判断给进来的数是不是小于0，是直接返回出去。 要达成回文数一般都要三位数，但是0~9，11，22，33…也可以是回文数，所以小于100的数也要处理一下 现在开始解题，会有两种情况，数字长度为奇数 和 偶数 如果是偶数，只要后半段 == 前半段，return ture 如果是奇数，只要前半段 == 后半段 / 10，return ture 代码过程和计算水仙花数类似 把传进来的数x取余数k赋值给res，然后x 自除 10，第二轮res自乘10再＋取余数k res向上迭代，x向下迭代，最后进行比较。如果遇到数字位数是奇数位就比较前半段是否等于后半段÷10 代码1234567891011class Solution &#123; public boolean isPalindrome(int x) &#123; if (x &lt; 0 || x % 10 == 0 ) return false; int res = 0; while (x &gt; res)&#123; res = res * 10 + x % 10; x /= 10; &#125; return x == res || x == res / 10; &#125;&#125; 输入 1221，我们可以将数字“1221”的后半部分从“21”反转为“12”，并将其与前半部分“12”进行比较，因为二者相同，我们得知数字 1221 是回文。","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://www.boii.xyz/categories/LeetCode/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://www.boii.xyz/tags/%E7%AE%97%E6%B3%95/"},{"name":"LeetCode","slug":"LeetCode","permalink":"https://www.boii.xyz/tags/LeetCode/"}]},{"title":"LeetCode-笔记【No-3】0x0D-罗马数字转整数","slug":"LeetCode-笔记【No-3】0x0D-罗马数字转整数","date":"2019-04-25T03:29:48.000Z","updated":"2021-05-23T04:22:18.474Z","comments":true,"path":"2019/04/25/LeetCode-笔记【No-3】0x0D-罗马数字转整数/","link":"","permalink":"https://www.boii.xyz/2019/04/25/LeetCode-%E7%AC%94%E8%AE%B0%E3%80%90No-3%E3%80%910x0D-%E7%BD%97%E9%A9%AC%E6%95%B0%E5%AD%97%E8%BD%AC%E6%95%B4%E6%95%B0/","excerpt":"LeetCode 第13题","text":"LeetCode 第13题 题目罗马数字包含以下七种字符: I， V， X， L，C，D 和 M。 字符 数值 I 1 V 5 X 10 L 50 C 100 D 500 M 1000 例如， 罗马数字 2 写做 II ，即为两个并列的 1。12 写做 XII ，即为 X + II 。 27 写做 XXVII, 即为 XX + V + II 。 通常情况下，罗马数字中小的数字在大的数字的右边。但也存在特例，例如 4 不写做 IIII，而是 IV。数字 1 在数字 5 的左边，所表示的数等于大数 5 减小数 1 得到的数值 4 。同样地，数字 9 表示为 IX。这个特殊的规则只适用于以下六种情况： I 可以放在 V (5) 和 X (10) 的左边，来表示 4 和 9。 X 可以放在 L (50) 和 C (100) 的左边，来表示 40 和 90。 C 可以放在 D (500) 和 M (1000) 的左边，来表示 400 和 900。 给定一个罗马数字，将其转换成整数。输入确保在 1 到 3999 的范围内。 示例 1: 输入: “III” 输出: 3 示例 2: 输入: “IV” 输出: 4 示例 3: 输入: “IX” 输出: 9 示例 4: 输入: “LVIII” 输出: 58 解释: L = 50, V= 5, III = 3. 示例 5: 输入: “MCMXCIV” 输出: 1994 解释: M = 1000, CM = 900, XC = 90, IV = 4. 思路 首先建立一个HashMap来映射符号和值 然后对字符串从左到右来，如果当前字符代表的值不小于其右边，就加上该值；否则就减去该值。 以此类推到最右边的数，最终得到的结果即是答案 这是LeetCode评论上的一条思路。非常简单粗暴。 代码12345678910111213141516171819202122232425262728class Solution &#123; public int romanToInt(String s) &#123; Map&lt;Character,Integer&gt; map = new HashMap&lt;&gt;(); map.put(&#x27;I&#x27;,1); map.put(&#x27;V&#x27;,5); map.put(&#x27;X&#x27;,10); map.put(&#x27;L&#x27;,50); map.put(&#x27;C&#x27;,100); map.put(&#x27;D&#x27;,500); map.put(&#x27;M&#x27;,1000); int res = 0; int size = s.length(); //最后一位不需要判断所以循环次数是size-1 for (int i = 0; i &lt; size - 1; i ++) &#123; //如果左边的数字小于右边的数字 if (map.get(s.charAt(i)) &gt;= map.get(s.charAt(i+1)))&#123; res += map.get(s.charAt(i)); &#125; else &#123; //如果左边数字小于右边的数字（也就是通常4和9的情况） res -= map.get(s.charAt(i)); &#125; &#125; //最后一位没被判断到，所以没被加上，记得加上去 res += map.get(s.charAt(size - 1)); return res; &#125;&#125; 这里的if判断先写多数的情况，也就是左边的数大于右边的数。 这样才不会把时间浪费在 先判断少数情况（左边 小于右边），再执行多数情况的运算","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://www.boii.xyz/categories/LeetCode/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://www.boii.xyz/tags/%E7%AE%97%E6%B3%95/"},{"name":"LeetCode","slug":"LeetCode","permalink":"https://www.boii.xyz/tags/LeetCode/"}]},{"title":"LeetCode-笔记【No-2】0x07-整数反转","slug":"LeetCode-笔记【No-2】0x07-整数反转","date":"2019-04-25T02:44:48.000Z","updated":"2021-05-23T04:22:20.187Z","comments":true,"path":"2019/04/25/LeetCode-笔记【No-2】0x07-整数反转/","link":"","permalink":"https://www.boii.xyz/2019/04/25/LeetCode-%E7%AC%94%E8%AE%B0%E3%80%90No-2%E3%80%910x07-%E6%95%B4%E6%95%B0%E5%8F%8D%E8%BD%AC/","excerpt":"LeetCode 第7题","text":"LeetCode 第7题 题目 给出一个 32 位的有符号整数，你需要将这个整数中每位上的数字进行反转。示例 1: 输入: 123 输出: 321示例 2: 输入: -123 输出: -321示例 3: 输入: 120 输出: 21注意: 假设我们的环境只能存储得下 32 位的有符号整数，则其数值范围为 [−2^31, 2^31 − 1]。请根据这个假设，如果反转后整数溢出那么就返回 0。 思路一开始的思路是把数字取模然后放到int数组里，但是这样复杂又难实现，时间复杂度上也没优势 后来看到网络上的答案，思路是这样的： 首先把要判断这个数是否超范围 然后再把这个数x拿来取模，获得最后一个数并赋值给一个新的变量 然后x自除10，进入下一次循环 第二次循环的时候新变量自乘10再加取模得到的数。最后返回这个新变量 代码123456789101112131415class Solution &#123; public int reverse(int x) &#123; int rev = 0; //新变量 while (x != 0) &#123; //判断我们取得的数是否超范围 // 2^31-1 = 2147483647 | -2^31 = -2147483648 if (rev &gt; Integer.MAX_VALUE/10 || (rev == Integer.MAX_VALUE / 10 &amp;&amp; pop &gt; 7)) return 0; if (rev &lt; Integer.MIN_VALUE/10 || (rev == Integer.MIN_VALUE / 10 &amp;&amp; pop &lt; -8)) return 0; int pop = x % 10; //取模拿到个位数 rev = rev * 10 + pop; //自身×10空出个位，然后加上刚刚取模出来的数 x /= 10; //迭代条件。因为x是int类型，所以÷10以后小数点就被省略了 &#125; return rev; &#125;&#125; 这种思路，就不需要把数字切成一个一个再拼接。直接利用数字的特性，通过取模和乘除运算带达到效果。 时间复杂度：O(log(x))，x 中大约有 log{10}(x)位数字。 空间复杂度：O(1)","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://www.boii.xyz/categories/LeetCode/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://www.boii.xyz/tags/%E7%AE%97%E6%B3%95/"},{"name":"LeetCode","slug":"LeetCode","permalink":"https://www.boii.xyz/tags/LeetCode/"}]},{"title":"LeetCode-笔记【No-1】0x01-两数之和","slug":"LeetCode-笔记【No-1】0x01-两数之和","date":"2019-04-25T02:44:47.000Z","updated":"2021-05-23T04:22:04.801Z","comments":true,"path":"2019/04/25/LeetCode-笔记【No-1】0x01-两数之和/","link":"","permalink":"https://www.boii.xyz/2019/04/25/LeetCode-%E7%AC%94%E8%AE%B0%E3%80%90No-1%E3%80%910x01-%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C/","excerpt":"LeetCode 第1题","text":"LeetCode 第1题 题目给定一个整数数组 nums 和一个目标值 target，请你在该数组中找出和为目标值的那 两个 整数，并返回他们的数组下标。 你可以假设每种输入只会对应一个答案。但是，你不能重复利用这个数组中同样的元素。 示例给定 nums = [2, 7, 11, 15], target = 9 因为 nums[0] + nums[1] = 2 + 7 = 9 所以返回 [0, 1] 思路思路非常简单，就是把要找的数字target，减去第一个的差，是否等于第二个数 如果是，返回这两个数的下标，如果不是，循环继续。 代码123456789101112class Solution &#123; public int[] twoSum(int[] nums, int target) &#123; for (int i = 0; i &lt; nums.length - 1; i++) &#123; for (int j = i+1; j &lt; nums.length; j ++) &#123; if (nums[j] == target - nums[i]) &#123; return new int[] &#123; i , j &#125;; &#125; &#125; &#125; return null; &#125;&#125; 第一层循环取第一个数i，然后进入第二层循环， 第二层循环从第二个数j 开始，判断要找的数-第一个数i 的差 是否等于 第二个数 j 如果不是第二层取第三个数，再进行比较。 如果第二层遍历完还没结果说明第一层的第一个数i不对，所以第一层取第二个数 再次进入第二层依次遍历。 当差等于第二层的某个数的时候，说明找到了，返回i和j的下标。 时间复杂度：O(n) 空间复杂度：O(n)","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://www.boii.xyz/categories/LeetCode/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://www.boii.xyz/tags/%E7%AE%97%E6%B3%95/"},{"name":"LeetCode","slug":"LeetCode","permalink":"https://www.boii.xyz/tags/LeetCode/"}]},{"title":"通信中的加密与解密","slug":"通信中的加密与解密","date":"2019-04-25T01:52:52.000Z","updated":"2021-05-26T16:17:41.537Z","comments":true,"path":"2019/04/25/通信中的加密与解密/","link":"","permalink":"https://www.boii.xyz/2019/04/25/%E9%80%9A%E4%BF%A1%E4%B8%AD%E7%9A%84%E5%8A%A0%E5%AF%86%E4%B8%8E%E8%A7%A3%E5%AF%86/","excerpt":"怎么和聊天才能不被人看到信息内容？","text":"怎么和聊天才能不被人看到信息内容？ 加密与解密 应用场景：通信 传统的通信场景：明文&gt;_ 如果这时候有个Hacker在中间嗅探他们的通信链路，那他们的内容就全都被看到了，甚至会被篡改 &gt;_ 加密&amp;解密明文有问题，那就加密，让中间的Hacker看不懂 凯撒密码通过约定的偏移和回正，达到A、B都看得懂，中间人看不懂的目的 加密：A发送的信息，全部右偏移3个字母 解密：B接收后左回正3个字母，就得到正确信息了。 例如：Hello world 右偏移后变成 Khnnr zrung 但是这样的加密太容易被破解了。凯撒密码是一种很古老的在战争中使用过的一种加密信件的方式，这里不说汉字，就说英文26个字母，最多进行（回正1，回正2，回正3…回正25,回正-1，回正-2…回正-25）共50次就可以破解。 对称加密A、B都将信息异或运算 如果将信息转成二进制，然后和另一个二进制(这里用E表示)，得到加密结果 那加密结果和E异或就能得到原本的信息的二进制，再转换成文字就得到了信息。 A ^ E = C C ^ E = A 例如： 加密的一方 假设 Hello world 的二进制是 0110 0101 1101 E 是： 0101 1001 1010 加密（异或）的结果就是: 0011 1100 0111 解密的一方 收到了加密的信息: 0011 1100 0111 E 是： 0101 1001 1010 解密（异或）的结果就是：0110 0101 1101 &gt;_ 这就是利用异或的特性来进行信息的加密。所以关键的E 就叫做密钥（所以拿到密钥就能破解了）。 要确保双方都有 E 这把密钥。 对称加密有3个特点： 仅做XOR（异或）运算，速度快 –优点 密钥跟数据长度相等 –缺点 双方需要提前拥有密钥 加密分片对称加密的缺点也明显，密钥长度跟数据长度相等。 解决的办法是： 把信息分组，每组对应一段密钥，分别做异或运算就可以得到密文分片，再合并到一起就得到密文（加密的信息）了。 接收的一方分别做异或运算得到明文分片，在合并到一起就得到原本的信息了。 加密分片的特点： 数据按密钥长度分组，不足的填充 可以并行计算各个分组，优化了性能 密文跟明文的序列存在规律对应关系 上面说的就是DES的ECB模式加密 不过这种简单的分组模式也是很容易发现规律 一般的改进思路是：信息第一次分组、加密、合并得到了一次密文，然后再进行第二次分组、加密、合并得到二次密文。 或者第一次分组，一次加密、二次加密、合并。 非对称加密请求方请求公钥，接收方发送公钥，请求方加密后发送，接收方用私钥解密 那密钥这么好，但是有个问题：E（密钥）怎么传输？明文还是密文？ 答案是：明文。 那密钥是明文的，被Hacker嗅探到了，那上面那些不都白费了。 所以就有了 非对称加密 &gt;_ 简单说就是：我先要个保险箱，然后把密钥放进去，关上。这个保险箱只有你开的了，所以被Hacker截获了他也开不了。 这就是非对称加密。谁都可以跟B拿保险箱，只有B自己才开得了保险箱。 12345打开状态的[保险箱] == 公钥关闭状态的[保险箱] == 密文保险箱钥匙 == 私钥 他们的特点就是： 任何人都可以请求并拿到公钥 用公钥加密明文变成密文 仅能用私钥解开密文得到明文 私钥不能丢失 RSA就是这样一个公钥（保险箱）私钥（钥匙）的算法，具体的数学应用利用了 大质数相乘难以分解，费马小定理 等数学理论，使得它难以破解（思考：所以从质数、小定理这些数学理论入手，是不是有机会破解非对称加密？）。 非对称加密需要做乘法模除等运算，性能效率比对称加密差很多。 对称加密需要做异或预算，性能效率比较高。 那么就综合起来，用非对称加密传输密钥E，然后再用对称加密传输数据。 认证找个我们都信得过的组织来保证我们不会被骗走密钥 接上面的思考，其实不用那么麻烦，硬刚刚不赢，可以曲线救国嘛~~ &gt;_ 如上，因为Hacker在中间截胡，所以他两边欺骗，然后只是做一个转发的工作。这个过程中，信息就给他看完了，而A、B都以为自己在跟对方通信，其实都被Hacker欺骗了。接下来开始传输数据的时候，Hacker前面拿到了密钥，所以他能解密任何数据，这样就绕过了非对称加密，保险箱不起作用了。 CA证书 那要怎么保证A请求B的公钥（保险箱）后，对方发过来的公钥（保险箱）就一定是B的呢？ 这里就需要一个彼此信任的组织，给每个人发身份证。就好像我们信任政府发的个人身份证（假设身份证没法伪造），所以我们看到个人身份证的时候就相信这个叫身份证上的名字。 在加密中，这个政府就是CA，身份证就是CA证书、CA数字签名。 大家都信任CA，所以检查CA证书后我们就相信B 是 B。 这个证书里面有两个重要的内容：B的公钥+CA做的数字签名 CA证书是反过来的，用私钥加密，用公钥解密。 CA用自己的私钥加密B的信息，A手里都有CA的公钥，在收到信息的时候，用CA的公钥解密，如果能解开，就证明B就是B。 换句话说，A请求B发保险箱过来，B先把保险箱给CA做个记号（CA认证加密），然后再发给A，A收到后看看记号跟CA约定的一不一样（CA的公钥解不解得开），如果Hacker发一个自己的保险箱，上面是没记号的（或者记号跟约定的不一样），那就说明这个保险箱是假的。 &gt;_ 以上就是一个简单的过程，Hacker发的假保险箱（公钥）跟CA约定的不一样（CA公钥解不开），A就停止发送密钥，Hacker欺骗失败 完整性非对称加密 和 认证 解决了保密性和真实性，但是完整性还没有一个保障。 如果Hacker等A、B非对称加密传输完密钥之后，在对称加密传输数据这个环节入手，篡改信息怎么办？ 答案是：哈希一下 单向哈希（Hash）可以把一个输入变成一个定长的输出串，它的特点就是无法从这个输入逆向还原输入内容，并且输入只要有一点改变，哪怕是那么一丢丢，输出串都会完全不同。 &gt;_ 这里哈希并不是这么简单，只需要知道哈希不可逆，一点点改变都会导致结果完全不同。 总结安全可靠的通信： B让CA用 # CA私钥 # 签名 [B的公钥]（给B的保险箱做个记号） A请求B给 [B的公钥]（打开的保险箱） B发送签名过的 [[B的公钥]]（带记号的保险箱）给A A用 ## CA的公钥 ## 校验B发来的 [[ B的公钥 ]]（检查记号） 用 [ B的公钥 ] 加密 “密钥E”（密钥放进保险箱关上门） B用【B的私钥】解密 “密钥E” A 用 “密钥E” 加密后传输数据 B 用 “密钥E” 解密数据 &gt;_","categories":[{"name":"RSA","slug":"RSA","permalink":"https://www.boii.xyz/categories/RSA/"}],"tags":[{"name":"RSA","slug":"RSA","permalink":"https://www.boii.xyz/tags/RSA/"}]},{"title":"RSA加密原理","slug":"RSA加密原理","date":"2019-04-25T00:09:08.000Z","updated":"2021-05-23T04:43:38.317Z","comments":true,"path":"2019/04/25/RSA加密原理/","link":"","permalink":"https://www.boii.xyz/2019/04/25/RSA%E5%8A%A0%E5%AF%86%E5%8E%9F%E7%90%86/","excerpt":"数学是一种很奇妙的东西","text":"数学是一种很奇妙的东西 质数：只能被1和自身整除的数 互质数：两个数的公约数只有1，这两个为互质数 欧拉函数：OL(n)=x，x：从0到n的范围内，和n互质的数 的 个数，也就是从0到n的范围内，和n的公约数只有1的数的个数 RSA加密原理 P：质数1 Q：质数2 N：最小公倍数 OL(N)=X -&gt; X：小于N &amp; 和N互质 的数的个数 E：公钥 D：私钥 M：明文 C：密文 找出P、Q 比如：P = 3 Q=11 找公共模数（求最小公倍数） N = P * Q = 3 * 11 = 33 N=33 欧拉函数 OL(N) = (P - 1)(Q - 1) OL(33) = (3 - 1)(11 - 1) = 20 计算公钥E 1 &lt; E &lt; OL(N) = 1 &lt; (1,20) &lt; 20 E的取值范围{3，5，7，11，13，17，19} E必须是整数，E必须和**OL(N)**互质 假设E=3，3是整数，3和20互质 计算私钥D E * D % OL(N) = 1 = 3 * D % 20 = 1，得出D=7 到这我们就计算出公钥和密钥了，现在我们开始用公钥加密，然后用私钥解密 加密解密 公钥加密 比如我们加密数字2：M=2 C = ME mod N; 即 密文 = 明文公钥 % 最小公倍数 C = 23 % 33 = 8 C = 8 明文2经过RSA加密后变成密文8 私钥解密 M = Cd mod N; 即 明文 = 密文私钥 % 最小公倍数 M = 87 % 33 = 2 M = 2 密文8经过RSA解密后变成明文2","categories":[{"name":"RSA","slug":"RSA","permalink":"https://www.boii.xyz/categories/RSA/"}],"tags":[{"name":"RSA","slug":"RSA","permalink":"https://www.boii.xyz/tags/RSA/"}]},{"title":"Hello World","slug":"Hello-World","date":"2018-12-31T16:00:00.000Z","updated":"2021-05-23T03:11:38.351Z","comments":true,"path":"2019/01/01/Hello-World/","link":"","permalink":"https://www.boii.xyz/2019/01/01/Hello-World/","excerpt":"Hello world !","text":"Hello world ! Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server or 1$ hexo s More info: Server Generate static files1$ hexo generate or 1$ hexo g More info: Generating Deploy to remote sites1$ hexo deploy or 1$ hexo d More info: Deployment","categories":[{"name":"HEXO","slug":"HEXO","permalink":"https://www.boii.xyz/categories/HEXO/"}],"tags":[{"name":"HEXO","slug":"HEXO","permalink":"https://www.boii.xyz/tags/HEXO/"}]}],"categories":[{"name":"DataStruction","slug":"DataStruction","permalink":"https://www.boii.xyz/categories/DataStruction/"},{"name":"HEXO","slug":"HEXO","permalink":"https://www.boii.xyz/categories/HEXO/"},{"name":"Note","slug":"Note","permalink":"https://www.boii.xyz/categories/Note/"},{"name":"Git","slug":"Git","permalink":"https://www.boii.xyz/categories/Git/"},{"name":"Python","slug":"Python","permalink":"https://www.boii.xyz/categories/Python/"},{"name":"爬虫","slug":"Python/爬虫","permalink":"https://www.boii.xyz/categories/Python/%E7%88%AC%E8%99%AB/"},{"name":"基础","slug":"Python/爬虫/基础","permalink":"https://www.boii.xyz/categories/Python/%E7%88%AC%E8%99%AB/%E5%9F%BA%E7%A1%80/"},{"name":"内置库","slug":"Python/内置库","permalink":"https://www.boii.xyz/categories/Python/%E5%86%85%E7%BD%AE%E5%BA%93/"},{"name":"OPP","slug":"Python/OPP","permalink":"https://www.boii.xyz/categories/Python/OPP/"},{"name":"进阶","slug":"Python/进阶","permalink":"https://www.boii.xyz/categories/Python/%E8%BF%9B%E9%98%B6/"},{"name":"IO","slug":"Python/进阶/IO","permalink":"https://www.boii.xyz/categories/Python/%E8%BF%9B%E9%98%B6/IO/"},{"name":"进程、线程","slug":"Python/进阶/进程、线程","permalink":"https://www.boii.xyz/categories/Python/%E8%BF%9B%E9%98%B6/%E8%BF%9B%E7%A8%8B%E3%80%81%E7%BA%BF%E7%A8%8B/"},{"name":"错误与调试","slug":"Python/进阶/错误与调试","permalink":"https://www.boii.xyz/categories/Python/%E8%BF%9B%E9%98%B6/%E9%94%99%E8%AF%AF%E4%B8%8E%E8%B0%83%E8%AF%95/"},{"name":"高级特性","slug":"Python/高级特性","permalink":"https://www.boii.xyz/categories/Python/%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7/"},{"name":"基础","slug":"Python/基础","permalink":"https://www.boii.xyz/categories/Python/%E5%9F%BA%E7%A1%80/"},{"name":"Vue","slug":"Vue","permalink":"https://www.boii.xyz/categories/Vue/"},{"name":"Electron","slug":"Electron","permalink":"https://www.boii.xyz/categories/Electron/"},{"name":"Java","slug":"Java","permalink":"https://www.boii.xyz/categories/Java/"},{"name":"SSM","slug":"SSM","permalink":"https://www.boii.xyz/categories/SSM/"},{"name":"C Language","slug":"C-Language","permalink":"https://www.boii.xyz/categories/C-Language/"},{"name":"Other","slug":"Other","permalink":"https://www.boii.xyz/categories/Other/"},{"name":"RSA","slug":"RSA","permalink":"https://www.boii.xyz/categories/RSA/"},{"name":"GoLang","slug":"GoLang","permalink":"https://www.boii.xyz/categories/GoLang/"},{"name":"LeetCode","slug":"LeetCode","permalink":"https://www.boii.xyz/categories/LeetCode/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"https://www.boii.xyz/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"DataStruction","slug":"DataStruction","permalink":"https://www.boii.xyz/tags/DataStruction/"},{"name":"HEXO","slug":"HEXO","permalink":"https://www.boii.xyz/tags/HEXO/"},{"name":"note","slug":"note","permalink":"https://www.boii.xyz/tags/note/"},{"name":"git","slug":"git","permalink":"https://www.boii.xyz/tags/git/"},{"name":"Python","slug":"Python","permalink":"https://www.boii.xyz/tags/Python/"},{"name":"爬虫","slug":"爬虫","permalink":"https://www.boii.xyz/tags/%E7%88%AC%E8%99%AB/"},{"name":"json","slug":"json","permalink":"https://www.boii.xyz/tags/json/"},{"name":"正则表达式","slug":"正则表达式","permalink":"https://www.boii.xyz/tags/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"},{"name":"函数式编程","slug":"函数式编程","permalink":"https://www.boii.xyz/tags/%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B/"},{"name":"Vue","slug":"Vue","permalink":"https://www.boii.xyz/tags/Vue/"},{"name":"YAML","slug":"YAML","permalink":"https://www.boii.xyz/tags/YAML/"},{"name":"Electron","slug":"Electron","permalink":"https://www.boii.xyz/tags/Electron/"},{"name":"命令","slug":"命令","permalink":"https://www.boii.xyz/tags/%E5%91%BD%E4%BB%A4/"},{"name":"Java","slug":"Java","permalink":"https://www.boii.xyz/tags/Java/"},{"name":"SSM","slug":"SSM","permalink":"https://www.boii.xyz/tags/SSM/"},{"name":"SSM配置","slug":"SSM配置","permalink":"https://www.boii.xyz/tags/SSM%E9%85%8D%E7%BD%AE/"},{"name":"事务管理","slug":"事务管理","permalink":"https://www.boii.xyz/tags/%E4%BA%8B%E5%8A%A1%E7%AE%A1%E7%90%86/"},{"name":"统一异常处理","slug":"统一异常处理","permalink":"https://www.boii.xyz/tags/%E7%BB%9F%E4%B8%80%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/"},{"name":"上传下载","slug":"上传下载","permalink":"https://www.boii.xyz/tags/%E4%B8%8A%E4%BC%A0%E4%B8%8B%E8%BD%BD/"},{"name":"拦截器","slug":"拦截器","permalink":"https://www.boii.xyz/tags/%E6%8B%A6%E6%88%AA%E5%99%A8/"},{"name":"数据绑定","slug":"数据绑定","permalink":"https://www.boii.xyz/tags/%E6%95%B0%E6%8D%AE%E7%BB%91%E5%AE%9A/"},{"name":"C Language","slug":"C-Language","permalink":"https://www.boii.xyz/tags/C-Language/"},{"name":"Hash","slug":"Hash","permalink":"https://www.boii.xyz/tags/Hash/"},{"name":"反射","slug":"反射","permalink":"https://www.boii.xyz/tags/%E5%8F%8D%E5%B0%84/"},{"name":"并行与并发","slug":"并行与并发","permalink":"https://www.boii.xyz/tags/%E5%B9%B6%E8%A1%8C%E4%B8%8E%E5%B9%B6%E5%8F%91/"},{"name":"RSA","slug":"RSA","permalink":"https://www.boii.xyz/tags/RSA/"},{"name":"GoLang","slug":"GoLang","permalink":"https://www.boii.xyz/tags/GoLang/"},{"name":"算法","slug":"算法","permalink":"https://www.boii.xyz/tags/%E7%AE%97%E6%B3%95/"},{"name":"LeetCode","slug":"LeetCode","permalink":"https://www.boii.xyz/tags/LeetCode/"}]}